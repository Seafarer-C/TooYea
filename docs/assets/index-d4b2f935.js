var SS = Object.defineProperty;
var wS = (n, e, t) =>
  e in n
    ? SS(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
    : (n[e] = t);
var Fe = (n, e, t) => (wS(n, typeof e != "symbol" ? e + "" : e, t), t);
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const o of r)
      if (o.type === "childList")
        for (const p of o.addedNodes)
          p.tagName === "LINK" && p.rel === "modulepreload" && i(p);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const o = {};
    return (
      r.integrity && (o.integrity = r.integrity),
      r.referrerpolicy && (o.referrerPolicy = r.referrerpolicy),
      r.crossorigin === "use-credentials"
        ? (o.credentials = "include")
        : r.crossorigin === "anonymous"
        ? (o.credentials = "omit")
        : (o.credentials = "same-origin"),
      o
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const o = t(r);
    fetch(r.href, o);
  }
})();
var Fl =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function sp(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function TS(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      if (this instanceof i) {
        var r = [null];
        r.push.apply(r, arguments);
        var o = Function.bind.apply(e, r);
        return new o();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (i) {
      var r = Object.getOwnPropertyDescriptor(n, i);
      Object.defineProperty(
        t,
        i,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return n[i];
              },
            }
      );
    }),
    t
  );
}
var Ne = {},
  CS = {
    get exports() {
      return Ne;
    },
    set exports(n) {
      Ne = n;
    },
  },
  Eu = {},
  Ce = {},
  MS = {
    get exports() {
      return Ce;
    },
    set exports(n) {
      Ce = n;
    },
  },
  qe = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gl = Symbol.for("react.element"),
  ES = Symbol.for("react.portal"),
  AS = Symbol.for("react.fragment"),
  PS = Symbol.for("react.strict_mode"),
  OS = Symbol.for("react.profiler"),
  LS = Symbol.for("react.provider"),
  DS = Symbol.for("react.context"),
  RS = Symbol.for("react.forward_ref"),
  IS = Symbol.for("react.suspense"),
  kS = Symbol.for("react.memo"),
  FS = Symbol.for("react.lazy"),
  ng = Symbol.iterator;
function NS(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (ng && n[ng]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var y_ = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  __ = Object.assign,
  x_ = {};
function Po(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = x_),
    (this.updater = t || y_);
}
Po.prototype.isReactComponent = {};
Po.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
Po.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function b_() {}
b_.prototype = Po.prototype;
function op(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = x_),
    (this.updater = t || y_);
}
var ap = (op.prototype = new b_());
ap.constructor = op;
__(ap, Po.prototype);
ap.isPureReactComponent = !0;
var ig = Array.isArray,
  S_ = Object.prototype.hasOwnProperty,
  lp = { current: null },
  w_ = { key: !0, ref: !0, __self: !0, __source: !0 };
function T_(n, e, t) {
  var i,
    r = {},
    o = null,
    p = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (p = e.ref),
    e.key !== void 0 && (o = "" + e.key),
    e))
      S_.call(e, i) && !w_.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var s = Array(a), u = 0; u < a; u++) s[u] = arguments[u + 2];
    r.children = s;
  }
  if (n && n.defaultProps)
    for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: gl,
    type: n,
    key: o,
    ref: p,
    props: r,
    _owner: lp.current,
  };
}
function BS(n, e) {
  return {
    $$typeof: gl,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function cp(n) {
  return typeof n == "object" && n !== null && n.$$typeof === gl;
}
function zS(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var rg = /\/+/g;
function vh(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? zS("" + n.key)
    : e.toString(36);
}
function Pc(n, e, t, i, r) {
  var o = typeof n;
  (o === "undefined" || o === "boolean") && (n = null);
  var p = !1;
  if (n === null) p = !0;
  else
    switch (o) {
      case "string":
      case "number":
        p = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case gl:
          case ES:
            p = !0;
        }
    }
  if (p)
    return (
      (p = n),
      (r = r(p)),
      (n = i === "" ? "." + vh(p, 0) : i),
      ig(r)
        ? ((t = ""),
          n != null && (t = n.replace(rg, "$&/") + "/"),
          Pc(r, e, t, "", function (u) {
            return u;
          }))
        : r != null &&
          (cp(r) &&
            (r = BS(
              r,
              t +
                (!r.key || (p && p.key === r.key)
                  ? ""
                  : ("" + r.key).replace(rg, "$&/") + "/") +
                n
            )),
          e.push(r)),
      1
    );
  if (((p = 0), (i = i === "" ? "." : i + ":"), ig(n)))
    for (var a = 0; a < n.length; a++) {
      o = n[a];
      var s = i + vh(o, a);
      p += Pc(o, e, t, s, r);
    }
  else if (((s = NS(n)), typeof s == "function"))
    for (n = s.call(n), a = 0; !(o = n.next()).done; )
      (o = o.value), (s = i + vh(o, a++)), (p += Pc(o, e, t, s, r));
  else if (o === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return p;
}
function Nl(n, e, t) {
  if (n == null) return n;
  var i = [],
    r = 0;
  return (
    Pc(n, i, "", "", function (o) {
      return e.call(t, o, r++);
    }),
    i
  );
}
function US(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var hn = { current: null },
  Oc = { transition: null },
  jS = {
    ReactCurrentDispatcher: hn,
    ReactCurrentBatchConfig: Oc,
    ReactCurrentOwner: lp,
  };
qe.Children = {
  map: Nl,
  forEach: function (n, e, t) {
    Nl(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      Nl(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      Nl(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!cp(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
qe.Component = Po;
qe.Fragment = AS;
qe.Profiler = OS;
qe.PureComponent = op;
qe.StrictMode = PS;
qe.Suspense = IS;
qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = jS;
qe.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var i = __({}, n.props),
    r = n.key,
    o = n.ref,
    p = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((o = e.ref), (p = lp.current)),
      e.key !== void 0 && (r = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (s in e)
      S_.call(e, s) &&
        !w_.hasOwnProperty(s) &&
        (i[s] = e[s] === void 0 && a !== void 0 ? a[s] : e[s]);
  }
  var s = arguments.length - 2;
  if (s === 1) i.children = t;
  else if (1 < s) {
    a = Array(s);
    for (var u = 0; u < s; u++) a[u] = arguments[u + 2];
    i.children = a;
  }
  return { $$typeof: gl, type: n.type, key: r, ref: o, props: i, _owner: p };
};
qe.createContext = function (n) {
  return (
    (n = {
      $$typeof: DS,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: LS, _context: n }),
    (n.Consumer = n)
  );
};
qe.createElement = T_;
qe.createFactory = function (n) {
  var e = T_.bind(null, n);
  return (e.type = n), e;
};
qe.createRef = function () {
  return { current: null };
};
qe.forwardRef = function (n) {
  return { $$typeof: RS, render: n };
};
qe.isValidElement = cp;
qe.lazy = function (n) {
  return { $$typeof: FS, _payload: { _status: -1, _result: n }, _init: US };
};
qe.memo = function (n, e) {
  return { $$typeof: kS, type: n, compare: e === void 0 ? null : e };
};
qe.startTransition = function (n) {
  var e = Oc.transition;
  Oc.transition = {};
  try {
    n();
  } finally {
    Oc.transition = e;
  }
};
qe.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
qe.useCallback = function (n, e) {
  return hn.current.useCallback(n, e);
};
qe.useContext = function (n) {
  return hn.current.useContext(n);
};
qe.useDebugValue = function () {};
qe.useDeferredValue = function (n) {
  return hn.current.useDeferredValue(n);
};
qe.useEffect = function (n, e) {
  return hn.current.useEffect(n, e);
};
qe.useId = function () {
  return hn.current.useId();
};
qe.useImperativeHandle = function (n, e, t) {
  return hn.current.useImperativeHandle(n, e, t);
};
qe.useInsertionEffect = function (n, e) {
  return hn.current.useInsertionEffect(n, e);
};
qe.useLayoutEffect = function (n, e) {
  return hn.current.useLayoutEffect(n, e);
};
qe.useMemo = function (n, e) {
  return hn.current.useMemo(n, e);
};
qe.useReducer = function (n, e, t) {
  return hn.current.useReducer(n, e, t);
};
qe.useRef = function (n) {
  return hn.current.useRef(n);
};
qe.useState = function (n) {
  return hn.current.useState(n);
};
qe.useSyncExternalStore = function (n, e, t) {
  return hn.current.useSyncExternalStore(n, e, t);
};
qe.useTransition = function () {
  return hn.current.useTransition();
};
qe.version = "18.2.0";
(function (n) {
  n.exports = qe;
})(MS);
const W = sp(Ce);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var HS = Ce,
  VS = Symbol.for("react.element"),
  WS = Symbol.for("react.fragment"),
  GS = Object.prototype.hasOwnProperty,
  $S = HS.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  XS = { key: !0, ref: !0, __self: !0, __source: !0 };
function C_(n, e, t) {
  var i,
    r = {},
    o = null,
    p = null;
  t !== void 0 && (o = "" + t),
    e.key !== void 0 && (o = "" + e.key),
    e.ref !== void 0 && (p = e.ref);
  for (i in e) GS.call(e, i) && !XS.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: VS,
    type: n,
    key: o,
    ref: p,
    props: r,
    _owner: $S.current,
  };
}
Eu.Fragment = WS;
Eu.jsx = C_;
Eu.jsxs = C_;
(function (n) {
  n.exports = Eu;
})(CS);
var Vf = {},
  co = {},
  YS = {
    get exports() {
      return co;
    },
    set exports(n) {
      co = n;
    },
  },
  In = {},
  Wf = {},
  KS = {
    get exports() {
      return Wf;
    },
    set exports(n) {
      Wf = n;
    },
  },
  M_ = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(j, C) {
    var R = j.length;
    j.push(C);
    e: for (; 0 < R; ) {
      var A = (R - 1) >>> 1,
        O = j[A];
      if (0 < r(O, C)) (j[A] = C), (j[R] = O), (R = A);
      else break e;
    }
  }
  function t(j) {
    return j.length === 0 ? null : j[0];
  }
  function i(j) {
    if (j.length === 0) return null;
    var C = j[0],
      R = j.pop();
    if (R !== C) {
      j[0] = R;
      e: for (var A = 0, O = j.length, H = O >>> 1; A < H; ) {
        var I = 2 * (A + 1) - 1,
          E = j[I],
          k = I + 1,
          $ = j[k];
        if (0 > r(E, R))
          k < O && 0 > r($, E)
            ? ((j[A] = $), (j[k] = R), (A = k))
            : ((j[A] = E), (j[I] = R), (A = I));
        else if (k < O && 0 > r($, R)) (j[A] = $), (j[k] = R), (A = k);
        else break e;
      }
    }
    return C;
  }
  function r(j, C) {
    var R = j.sortIndex - C.sortIndex;
    return R !== 0 ? R : j.id - C.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var o = performance;
    n.unstable_now = function () {
      return o.now();
    };
  } else {
    var p = Date,
      a = p.now();
    n.unstable_now = function () {
      return p.now() - a;
    };
  }
  var s = [],
    u = [],
    d = 1,
    l = null,
    c = 3,
    h = !1,
    m = !1,
    g = !1,
    f = typeof setTimeout == "function" ? setTimeout : null,
    v = typeof clearTimeout == "function" ? clearTimeout : null,
    y = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function _(j) {
    for (var C = t(u); C !== null; ) {
      if (C.callback === null) i(u);
      else if (C.startTime <= j)
        i(u), (C.sortIndex = C.expirationTime), e(s, C);
      else break;
      C = t(u);
    }
  }
  function x(j) {
    if (((g = !1), _(j), !m))
      if (t(s) !== null) (m = !0), ie(b);
      else {
        var C = t(u);
        C !== null && re(x, C.startTime - j);
      }
  }
  function b(j, C) {
    (m = !1), g && ((g = !1), v(w), (w = -1)), (h = !0);
    var R = c;
    try {
      for (
        _(C), l = t(s);
        l !== null && (!(l.expirationTime > C) || (j && !V()));

      ) {
        var A = l.callback;
        if (typeof A == "function") {
          (l.callback = null), (c = l.priorityLevel);
          var O = A(l.expirationTime <= C);
          (C = n.unstable_now()),
            typeof O == "function" ? (l.callback = O) : l === t(s) && i(s),
            _(C);
        } else i(s);
        l = t(s);
      }
      if (l !== null) var H = !0;
      else {
        var I = t(u);
        I !== null && re(x, I.startTime - C), (H = !1);
      }
      return H;
    } finally {
      (l = null), (c = R), (h = !1);
    }
  }
  var S = !1,
    T = null,
    w = -1,
    P = 5,
    F = -1;
  function V() {
    return !(n.unstable_now() - F < P);
  }
  function J() {
    if (T !== null) {
      var j = n.unstable_now();
      F = j;
      var C = !0;
      try {
        C = T(!0, j);
      } finally {
        C ? z() : ((S = !1), (T = null));
      }
    } else S = !1;
  }
  var z;
  if (typeof y == "function")
    z = function () {
      y(J);
    };
  else if (typeof MessageChannel < "u") {
    var B = new MessageChannel(),
      G = B.port2;
    (B.port1.onmessage = J),
      (z = function () {
        G.postMessage(null);
      });
  } else
    z = function () {
      f(J, 0);
    };
  function ie(j) {
    (T = j), S || ((S = !0), z());
  }
  function re(j, C) {
    w = f(function () {
      j(n.unstable_now());
    }, C);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (j) {
      j.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      m || h || ((m = !0), ie(b));
    }),
    (n.unstable_forceFrameRate = function (j) {
      0 > j || 125 < j
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (P = 0 < j ? Math.floor(1e3 / j) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return c;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(s);
    }),
    (n.unstable_next = function (j) {
      switch (c) {
        case 1:
        case 2:
        case 3:
          var C = 3;
          break;
        default:
          C = c;
      }
      var R = c;
      c = C;
      try {
        return j();
      } finally {
        c = R;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (j, C) {
      switch (j) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          j = 3;
      }
      var R = c;
      c = j;
      try {
        return C();
      } finally {
        c = R;
      }
    }),
    (n.unstable_scheduleCallback = function (j, C, R) {
      var A = n.unstable_now();
      switch (
        (typeof R == "object" && R !== null
          ? ((R = R.delay), (R = typeof R == "number" && 0 < R ? A + R : A))
          : (R = A),
        j)
      ) {
        case 1:
          var O = -1;
          break;
        case 2:
          O = 250;
          break;
        case 5:
          O = 1073741823;
          break;
        case 4:
          O = 1e4;
          break;
        default:
          O = 5e3;
      }
      return (
        (O = R + O),
        (j = {
          id: d++,
          callback: C,
          priorityLevel: j,
          startTime: R,
          expirationTime: O,
          sortIndex: -1,
        }),
        R > A
          ? ((j.sortIndex = R),
            e(u, j),
            t(s) === null &&
              j === t(u) &&
              (g ? (v(w), (w = -1)) : (g = !0), re(x, R - A)))
          : ((j.sortIndex = O), e(s, j), m || h || ((m = !0), ie(b))),
        j
      );
    }),
    (n.unstable_shouldYield = V),
    (n.unstable_wrapCallback = function (j) {
      var C = c;
      return function () {
        var R = c;
        c = C;
        try {
          return j.apply(this, arguments);
        } finally {
          c = R;
        }
      };
    });
})(M_);
(function (n) {
  n.exports = M_;
})(KS);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var E_ = Ce,
  Dn = Wf;
function be(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var A_ = new Set(),
  ja = {};
function us(n, e) {
  uo(n, e), uo(n + "Capture", e);
}
function uo(n, e) {
  for (ja[n] = e, n = 0; n < e.length; n++) A_.add(e[n]);
}
var zi = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  Gf = Object.prototype.hasOwnProperty,
  qS =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  sg = {},
  og = {};
function ZS(n) {
  return Gf.call(og, n)
    ? !0
    : Gf.call(sg, n)
    ? !1
    : qS.test(n)
    ? (og[n] = !0)
    : ((sg[n] = !0), !1);
}
function JS(n, e, t, i) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function QS(n, e, t, i) {
  if (e === null || typeof e > "u" || JS(n, e, t, i)) return !0;
  if (i) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function fn(n, e, t, i, r, o, p) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = o),
    (this.removeEmptyString = p);
}
var $t = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    $t[n] = new fn(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  $t[e] = new fn(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  $t[n] = new fn(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  $t[n] = new fn(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    $t[n] = new fn(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  $t[n] = new fn(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  $t[n] = new fn(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  $t[n] = new fn(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  $t[n] = new fn(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var up = /[\-:]([a-z])/g;
function hp(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(up, hp);
    $t[e] = new fn(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(up, hp);
    $t[e] = new fn(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(up, hp);
  $t[e] = new fn(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  $t[n] = new fn(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
$t.xlinkHref = new fn(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  $t[n] = new fn(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function fp(n, e, t, i) {
  var r = $t.hasOwnProperty(e) ? $t[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (QS(e, t, r, i) && (t = null),
    i || r === null
      ? ZS(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : r.mustUseProperty
      ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : "") : t)
      : ((e = r.attributeName),
        (i = r.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((r = r.type),
            (t = r === 3 || (r === 4 && t === !0) ? "" : "" + t),
            i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var Vi = E_.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Bl = Symbol.for("react.element"),
  Fs = Symbol.for("react.portal"),
  Ns = Symbol.for("react.fragment"),
  dp = Symbol.for("react.strict_mode"),
  $f = Symbol.for("react.profiler"),
  P_ = Symbol.for("react.provider"),
  O_ = Symbol.for("react.context"),
  pp = Symbol.for("react.forward_ref"),
  Xf = Symbol.for("react.suspense"),
  Yf = Symbol.for("react.suspense_list"),
  mp = Symbol.for("react.memo"),
  Ji = Symbol.for("react.lazy"),
  L_ = Symbol.for("react.offscreen"),
  ag = Symbol.iterator;
function qo(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (ag && n[ag]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var wt = Object.assign,
  yh;
function ba(n) {
  if (yh === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      yh = (e && e[1]) || "";
    }
  return (
    `
` +
    yh +
    n
  );
}
var _h = !1;
function xh(n, e) {
  if (!n || _h) return "";
  _h = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (u) {
          var i = u;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (u) {
          i = u;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (u) {
        i = u;
      }
      n();
    }
  } catch (u) {
    if (u && i && typeof u.stack == "string") {
      for (
        var r = u.stack.split(`
`),
          o = i.stack.split(`
`),
          p = r.length - 1,
          a = o.length - 1;
        1 <= p && 0 <= a && r[p] !== o[a];

      )
        a--;
      for (; 1 <= p && 0 <= a; p--, a--)
        if (r[p] !== o[a]) {
          if (p !== 1 || a !== 1)
            do
              if ((p--, a--, 0 > a || r[p] !== o[a])) {
                var s =
                  `
` + r[p].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    s.includes("<anonymous>") &&
                    (s = s.replace("<anonymous>", n.displayName)),
                  s
                );
              }
            while (1 <= p && 0 <= a);
          break;
        }
    }
  } finally {
    (_h = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? ba(n) : "";
}
function ew(n) {
  switch (n.tag) {
    case 5:
      return ba(n.type);
    case 16:
      return ba("Lazy");
    case 13:
      return ba("Suspense");
    case 19:
      return ba("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = xh(n.type, !1)), n;
    case 11:
      return (n = xh(n.type.render, !1)), n;
    case 1:
      return (n = xh(n.type, !0)), n;
    default:
      return "";
  }
}
function Kf(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case Ns:
      return "Fragment";
    case Fs:
      return "Portal";
    case $f:
      return "Profiler";
    case dp:
      return "StrictMode";
    case Xf:
      return "Suspense";
    case Yf:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case O_:
        return (n.displayName || "Context") + ".Consumer";
      case P_:
        return (n._context.displayName || "Context") + ".Provider";
      case pp:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case mp:
        return (
          (e = n.displayName || null), e !== null ? e : Kf(n.type) || "Memo"
        );
      case Ji:
        (e = n._payload), (n = n._init);
        try {
          return Kf(n(e));
        } catch {}
    }
  return null;
}
function tw(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Kf(e);
    case 8:
      return e === dp ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function vr(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function D_(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function nw(n) {
  var e = D_(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    i = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var r = t.get,
      o = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (p) {
          (i = "" + p), o.call(this, p);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (p) {
          i = "" + p;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function zl(n) {
  n._valueTracker || (n._valueTracker = nw(n));
}
function R_(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    i = "";
  return (
    n && (i = D_(n) ? (n.checked ? "true" : "false") : n.value),
    (n = i),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function Kc(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function qf(n, e) {
  var t = e.checked;
  return wt({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function lg(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (t = vr(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: i,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function I_(n, e) {
  (e = e.checked), e != null && fp(n, "checked", e, !1);
}
function Zf(n, e) {
  I_(n, e);
  var t = vr(e.value),
    i = e.type;
  if (t != null)
    i === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? Jf(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && Jf(n, e.type, vr(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function cg(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function Jf(n, e, t) {
  (e !== "number" || Kc(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var Sa = Array.isArray;
function Js(n, e, t, i) {
  if (((n = n.options), e)) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      (r = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== r && (n[t].selected = r),
        r && i && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + vr(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        (n[r].selected = !0), i && (n[r].defaultSelected = !0);
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function Qf(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(be(91));
  return wt({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function ug(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(be(92));
      if (Sa(t)) {
        if (1 < t.length) throw Error(be(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: vr(t) };
}
function k_(n, e) {
  var t = vr(e.value),
    i = vr(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i);
}
function hg(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function F_(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function ed(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? F_(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var Ul,
  N_ = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, i, r);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Ul = Ul || document.createElement("div"),
          Ul.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Ul.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function Ha(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var Ea = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  iw = ["Webkit", "ms", "Moz", "O"];
Object.keys(Ea).forEach(function (n) {
  iw.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (Ea[e] = Ea[n]);
  });
});
function B_(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (Ea.hasOwnProperty(n) && Ea[n])
    ? ("" + e).trim()
    : e + "px";
}
function z_(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0,
        r = B_(t, e[t], i);
      t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : (n[t] = r);
    }
}
var rw = wt(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function td(n, e) {
  if (e) {
    if (rw[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(be(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(be(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(be(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(be(62));
  }
}
function nd(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var id = null;
function gp(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var rd = null,
  Qs = null,
  eo = null;
function fg(n) {
  if ((n = _l(n))) {
    if (typeof rd != "function") throw Error(be(280));
    var e = n.stateNode;
    e && ((e = Du(e)), rd(n.stateNode, n.type, e));
  }
}
function U_(n) {
  Qs ? (eo ? eo.push(n) : (eo = [n])) : (Qs = n);
}
function j_() {
  if (Qs) {
    var n = Qs,
      e = eo;
    if (((eo = Qs = null), fg(n), e)) for (n = 0; n < e.length; n++) fg(e[n]);
  }
}
function H_(n, e) {
  return n(e);
}
function V_() {}
var bh = !1;
function W_(n, e, t) {
  if (bh) return n(e, t);
  bh = !0;
  try {
    return H_(n, e, t);
  } finally {
    (bh = !1), (Qs !== null || eo !== null) && (V_(), j_());
  }
}
function Va(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var i = Du(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((n = n.type),
        (i = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !i);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(be(231, e, typeof t));
  return t;
}
var sd = !1;
if (zi)
  try {
    var Zo = {};
    Object.defineProperty(Zo, "passive", {
      get: function () {
        sd = !0;
      },
    }),
      window.addEventListener("test", Zo, Zo),
      window.removeEventListener("test", Zo, Zo);
  } catch {
    sd = !1;
  }
function sw(n, e, t, i, r, o, p, a, s) {
  var u = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, u);
  } catch (d) {
    this.onError(d);
  }
}
var Aa = !1,
  qc = null,
  Zc = !1,
  od = null,
  ow = {
    onError: function (n) {
      (Aa = !0), (qc = n);
    },
  };
function aw(n, e, t, i, r, o, p, a, s) {
  (Aa = !1), (qc = null), sw.apply(ow, arguments);
}
function lw(n, e, t, i, r, o, p, a, s) {
  if ((aw.apply(this, arguments), Aa)) {
    if (Aa) {
      var u = qc;
      (Aa = !1), (qc = null);
    } else throw Error(be(198));
    Zc || ((Zc = !0), (od = u));
  }
}
function hs(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function G_(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function dg(n) {
  if (hs(n) !== n) throw Error(be(188));
}
function cw(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = hs(n)), e === null)) throw Error(be(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var o = r.alternate;
    if (o === null) {
      if (((i = r.return), i !== null)) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === o.child) {
      for (o = r.child; o; ) {
        if (o === t) return dg(r), n;
        if (o === i) return dg(r), e;
        o = o.sibling;
      }
      throw Error(be(188));
    }
    if (t.return !== i.return) (t = r), (i = o);
    else {
      for (var p = !1, a = r.child; a; ) {
        if (a === t) {
          (p = !0), (t = r), (i = o);
          break;
        }
        if (a === i) {
          (p = !0), (i = r), (t = o);
          break;
        }
        a = a.sibling;
      }
      if (!p) {
        for (a = o.child; a; ) {
          if (a === t) {
            (p = !0), (t = o), (i = r);
            break;
          }
          if (a === i) {
            (p = !0), (i = o), (t = r);
            break;
          }
          a = a.sibling;
        }
        if (!p) throw Error(be(189));
      }
    }
    if (t.alternate !== i) throw Error(be(190));
  }
  if (t.tag !== 3) throw Error(be(188));
  return t.stateNode.current === t ? n : e;
}
function $_(n) {
  return (n = cw(n)), n !== null ? X_(n) : null;
}
function X_(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = X_(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var Y_ = Dn.unstable_scheduleCallback,
  pg = Dn.unstable_cancelCallback,
  uw = Dn.unstable_shouldYield,
  hw = Dn.unstable_requestPaint,
  Mt = Dn.unstable_now,
  fw = Dn.unstable_getCurrentPriorityLevel,
  vp = Dn.unstable_ImmediatePriority,
  K_ = Dn.unstable_UserBlockingPriority,
  Jc = Dn.unstable_NormalPriority,
  dw = Dn.unstable_LowPriority,
  q_ = Dn.unstable_IdlePriority,
  Au = null,
  yi = null;
function pw(n) {
  if (yi && typeof yi.onCommitFiberRoot == "function")
    try {
      yi.onCommitFiberRoot(Au, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var ri = Math.clz32 ? Math.clz32 : vw,
  mw = Math.log,
  gw = Math.LN2;
function vw(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((mw(n) / gw) | 0)) | 0;
}
var jl = 64,
  Hl = 4194304;
function wa(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function Qc(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var i = 0,
    r = n.suspendedLanes,
    o = n.pingedLanes,
    p = t & 268435455;
  if (p !== 0) {
    var a = p & ~r;
    a !== 0 ? (i = wa(a)) : ((o &= p), o !== 0 && (i = wa(o)));
  } else (p = t & ~r), p !== 0 ? (i = wa(p)) : o !== 0 && (i = wa(o));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (o = e & -e), r >= o || (r === 16 && (o & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= i; 0 < e; )
      (t = 31 - ri(e)), (r = 1 << t), (i |= n[t]), (e &= ~r);
  return i;
}
function yw(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function _w(n, e) {
  for (
    var t = n.suspendedLanes,
      i = n.pingedLanes,
      r = n.expirationTimes,
      o = n.pendingLanes;
    0 < o;

  ) {
    var p = 31 - ri(o),
      a = 1 << p,
      s = r[p];
    s === -1
      ? (!(a & t) || a & i) && (r[p] = yw(a, e))
      : s <= e && (n.expiredLanes |= a),
      (o &= ~a);
  }
}
function ad(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function Z_() {
  var n = jl;
  return (jl <<= 1), !(jl & 4194240) && (jl = 64), n;
}
function Sh(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function vl(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - ri(e)),
    (n[e] = t);
}
function xw(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - ri(t),
      o = 1 << r;
    (e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~o);
  }
}
function yp(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var i = 31 - ri(t),
      r = 1 << i;
    (r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r);
  }
}
var lt = 0;
function J_(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var Q_,
  _p,
  ex,
  tx,
  nx,
  ld = !1,
  Vl = [],
  lr = null,
  cr = null,
  ur = null,
  Wa = new Map(),
  Ga = new Map(),
  nr = [],
  bw =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function mg(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      lr = null;
      break;
    case "dragenter":
    case "dragleave":
      cr = null;
      break;
    case "mouseover":
    case "mouseout":
      ur = null;
      break;
    case "pointerover":
    case "pointerout":
      Wa.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Ga.delete(e.pointerId);
  }
}
function Jo(n, e, t, i, r, o) {
  return n === null || n.nativeEvent !== o
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: o,
        targetContainers: [r],
      }),
      e !== null && ((e = _l(e)), e !== null && _p(e)),
      n)
    : ((n.eventSystemFlags |= i),
      (e = n.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      n);
}
function Sw(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return (lr = Jo(lr, n, e, t, i, r)), !0;
    case "dragenter":
      return (cr = Jo(cr, n, e, t, i, r)), !0;
    case "mouseover":
      return (ur = Jo(ur, n, e, t, i, r)), !0;
    case "pointerover":
      var o = r.pointerId;
      return Wa.set(o, Jo(Wa.get(o) || null, n, e, t, i, r)), !0;
    case "gotpointercapture":
      return (
        (o = r.pointerId), Ga.set(o, Jo(Ga.get(o) || null, n, e, t, i, r)), !0
      );
  }
  return !1;
}
function ix(n) {
  var e = jr(n.target);
  if (e !== null) {
    var t = hs(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = G_(t)), e !== null)) {
          (n.blockedOn = e),
            nx(n.priority, function () {
              ex(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function Lc(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = cd(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      (id = i), t.target.dispatchEvent(i), (id = null);
    } else return (e = _l(t)), e !== null && _p(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function gg(n, e, t) {
  Lc(n) && t.delete(e);
}
function ww() {
  (ld = !1),
    lr !== null && Lc(lr) && (lr = null),
    cr !== null && Lc(cr) && (cr = null),
    ur !== null && Lc(ur) && (ur = null),
    Wa.forEach(gg),
    Ga.forEach(gg);
}
function Qo(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    ld ||
      ((ld = !0),
      Dn.unstable_scheduleCallback(Dn.unstable_NormalPriority, ww)));
}
function $a(n) {
  function e(r) {
    return Qo(r, n);
  }
  if (0 < Vl.length) {
    Qo(Vl[0], n);
    for (var t = 1; t < Vl.length; t++) {
      var i = Vl[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (
    lr !== null && Qo(lr, n),
      cr !== null && Qo(cr, n),
      ur !== null && Qo(ur, n),
      Wa.forEach(e),
      Ga.forEach(e),
      t = 0;
    t < nr.length;
    t++
  )
    (i = nr[t]), i.blockedOn === n && (i.blockedOn = null);
  for (; 0 < nr.length && ((t = nr[0]), t.blockedOn === null); )
    ix(t), t.blockedOn === null && nr.shift();
}
var to = Vi.ReactCurrentBatchConfig,
  eu = !0;
function Tw(n, e, t, i) {
  var r = lt,
    o = to.transition;
  to.transition = null;
  try {
    (lt = 1), xp(n, e, t, i);
  } finally {
    (lt = r), (to.transition = o);
  }
}
function Cw(n, e, t, i) {
  var r = lt,
    o = to.transition;
  to.transition = null;
  try {
    (lt = 4), xp(n, e, t, i);
  } finally {
    (lt = r), (to.transition = o);
  }
}
function xp(n, e, t, i) {
  if (eu) {
    var r = cd(n, e, t, i);
    if (r === null) Dh(n, e, i, tu, t), mg(n, i);
    else if (Sw(r, n, e, t, i)) i.stopPropagation();
    else if ((mg(n, i), e & 4 && -1 < bw.indexOf(n))) {
      for (; r !== null; ) {
        var o = _l(r);
        if (
          (o !== null && Q_(o),
          (o = cd(n, e, t, i)),
          o === null && Dh(n, e, i, tu, t),
          o === r)
        )
          break;
        r = o;
      }
      r !== null && i.stopPropagation();
    } else Dh(n, e, i, null, t);
  }
}
var tu = null;
function cd(n, e, t, i) {
  if (((tu = null), (n = gp(i)), (n = jr(n)), n !== null))
    if (((e = hs(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = G_(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (tu = n), null;
}
function rx(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (fw()) {
        case vp:
          return 1;
        case K_:
          return 4;
        case Jc:
        case dw:
          return 16;
        case q_:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var rr = null,
  bp = null,
  Dc = null;
function sx() {
  if (Dc) return Dc;
  var n,
    e = bp,
    t = e.length,
    i,
    r = "value" in rr ? rr.value : rr.textContent,
    o = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++);
  var p = t - n;
  for (i = 1; i <= p && e[t - i] === r[o - i]; i++);
  return (Dc = r.slice(n, 1 < i ? 1 - i : void 0));
}
function Rc(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Wl() {
  return !0;
}
function vg() {
  return !1;
}
function kn(n) {
  function e(t, i, r, o, p) {
    (this._reactName = t),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = o),
      (this.target = p),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(o) : o[a]));
    return (
      (this.isDefaultPrevented = (
        o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1
      )
        ? Wl
        : vg),
      (this.isPropagationStopped = vg),
      this
    );
  }
  return (
    wt(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Wl));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Wl));
      },
      persist: function () {},
      isPersistent: Wl,
    }),
    e
  );
}
var Oo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  Sp = kn(Oo),
  yl = wt({}, Oo, { view: 0, detail: 0 }),
  Mw = kn(yl),
  wh,
  Th,
  ea,
  Pu = wt({}, yl, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: wp,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== ea &&
            (ea && n.type === "mousemove"
              ? ((wh = n.screenX - ea.screenX), (Th = n.screenY - ea.screenY))
              : (Th = wh = 0),
            (ea = n)),
          wh);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : Th;
    },
  }),
  yg = kn(Pu),
  Ew = wt({}, Pu, { dataTransfer: 0 }),
  Aw = kn(Ew),
  Pw = wt({}, yl, { relatedTarget: 0 }),
  Ch = kn(Pw),
  Ow = wt({}, Oo, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Lw = kn(Ow),
  Dw = wt({}, Oo, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  Rw = kn(Dw),
  Iw = wt({}, Oo, { data: 0 }),
  _g = kn(Iw),
  kw = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  Fw = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  Nw = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function Bw(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = Nw[n]) ? !!e[n] : !1;
}
function wp() {
  return Bw;
}
var zw = wt({}, yl, {
    key: function (n) {
      if (n.key) {
        var e = kw[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = Rc(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? Fw[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: wp,
    charCode: function (n) {
      return n.type === "keypress" ? Rc(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? Rc(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  Uw = kn(zw),
  jw = wt({}, Pu, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  xg = kn(jw),
  Hw = wt({}, yl, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: wp,
  }),
  Vw = kn(Hw),
  Ww = wt({}, Oo, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Gw = kn(Ww),
  $w = wt({}, Pu, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  Xw = kn($w),
  Yw = [9, 13, 27, 32],
  Tp = zi && "CompositionEvent" in window,
  Pa = null;
zi && "documentMode" in document && (Pa = document.documentMode);
var Kw = zi && "TextEvent" in window && !Pa,
  ox = zi && (!Tp || (Pa && 8 < Pa && 11 >= Pa)),
  bg = String.fromCharCode(32),
  Sg = !1;
function ax(n, e) {
  switch (n) {
    case "keyup":
      return Yw.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function lx(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var Bs = !1;
function qw(n, e) {
  switch (n) {
    case "compositionend":
      return lx(e);
    case "keypress":
      return e.which !== 32 ? null : ((Sg = !0), bg);
    case "textInput":
      return (n = e.data), n === bg && Sg ? null : n;
    default:
      return null;
  }
}
function Zw(n, e) {
  if (Bs)
    return n === "compositionend" || (!Tp && ax(n, e))
      ? ((n = sx()), (Dc = bp = rr = null), (Bs = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return ox && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var Jw = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function wg(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!Jw[n.type] : e === "textarea";
}
function cx(n, e, t, i) {
  U_(i),
    (e = nu(e, "onChange")),
    0 < e.length &&
      ((t = new Sp("onChange", "change", null, t, i)),
      n.push({ event: t, listeners: e }));
}
var Oa = null,
  Xa = null;
function Qw(n) {
  xx(n, 0);
}
function Ou(n) {
  var e = js(n);
  if (R_(e)) return n;
}
function eT(n, e) {
  if (n === "change") return e;
}
var ux = !1;
if (zi) {
  var Mh;
  if (zi) {
    var Eh = "oninput" in document;
    if (!Eh) {
      var Tg = document.createElement("div");
      Tg.setAttribute("oninput", "return;"),
        (Eh = typeof Tg.oninput == "function");
    }
    Mh = Eh;
  } else Mh = !1;
  ux = Mh && (!document.documentMode || 9 < document.documentMode);
}
function Cg() {
  Oa && (Oa.detachEvent("onpropertychange", hx), (Xa = Oa = null));
}
function hx(n) {
  if (n.propertyName === "value" && Ou(Xa)) {
    var e = [];
    cx(e, Xa, n, gp(n)), W_(Qw, e);
  }
}
function tT(n, e, t) {
  n === "focusin"
    ? (Cg(), (Oa = e), (Xa = t), Oa.attachEvent("onpropertychange", hx))
    : n === "focusout" && Cg();
}
function nT(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return Ou(Xa);
}
function iT(n, e) {
  if (n === "click") return Ou(e);
}
function rT(n, e) {
  if (n === "input" || n === "change") return Ou(e);
}
function sT(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var ai = typeof Object.is == "function" ? Object.is : sT;
function Ya(n, e) {
  if (ai(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    i = Object.keys(e);
  if (t.length !== i.length) return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!Gf.call(e, r) || !ai(n[r], e[r])) return !1;
  }
  return !0;
}
function Mg(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function Eg(n, e) {
  var t = Mg(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (((i = n + t.textContent.length), n <= e && i >= e))
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = Mg(t);
  }
}
function fx(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? fx(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function dx() {
  for (var n = window, e = Kc(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = Kc(n.document);
  }
  return e;
}
function Cp(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function oT(n) {
  var e = dx(),
    t = n.focusedElem,
    i = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    fx(t.ownerDocument.documentElement, t)
  ) {
    if (i !== null && Cp(t)) {
      if (
        ((e = i.start),
        (n = i.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var r = t.textContent.length,
          o = Math.min(i.start, r);
        (i = i.end === void 0 ? o : Math.min(i.end, r)),
          !n.extend && o > i && ((r = i), (i = o), (o = r)),
          (r = Eg(t, o));
        var p = Eg(t, i);
        r &&
          p &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== r.node ||
            n.anchorOffset !== r.offset ||
            n.focusNode !== p.node ||
            n.focusOffset !== p.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          n.removeAllRanges(),
          o > i
            ? (n.addRange(e), n.extend(p.node, p.offset))
            : (e.setEnd(p.node, p.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var aT = zi && "documentMode" in document && 11 >= document.documentMode,
  zs = null,
  ud = null,
  La = null,
  hd = !1;
function Ag(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  hd ||
    zs == null ||
    zs !== Kc(i) ||
    ((i = zs),
    "selectionStart" in i && Cp(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (La && Ya(La, i)) ||
      ((La = i),
      (i = nu(ud, "onSelect")),
      0 < i.length &&
        ((e = new Sp("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: i }),
        (e.target = zs))));
}
function Gl(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var Us = {
    animationend: Gl("Animation", "AnimationEnd"),
    animationiteration: Gl("Animation", "AnimationIteration"),
    animationstart: Gl("Animation", "AnimationStart"),
    transitionend: Gl("Transition", "TransitionEnd"),
  },
  Ah = {},
  px = {};
zi &&
  ((px = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Us.animationend.animation,
    delete Us.animationiteration.animation,
    delete Us.animationstart.animation),
  "TransitionEvent" in window || delete Us.transitionend.transition);
function Lu(n) {
  if (Ah[n]) return Ah[n];
  if (!Us[n]) return n;
  var e = Us[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in px) return (Ah[n] = e[t]);
  return n;
}
var mx = Lu("animationend"),
  gx = Lu("animationiteration"),
  vx = Lu("animationstart"),
  yx = Lu("transitionend"),
  _x = new Map(),
  Pg =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function br(n, e) {
  _x.set(n, e), us(e, [n]);
}
for (var Ph = 0; Ph < Pg.length; Ph++) {
  var Oh = Pg[Ph],
    lT = Oh.toLowerCase(),
    cT = Oh[0].toUpperCase() + Oh.slice(1);
  br(lT, "on" + cT);
}
br(mx, "onAnimationEnd");
br(gx, "onAnimationIteration");
br(vx, "onAnimationStart");
br("dblclick", "onDoubleClick");
br("focusin", "onFocus");
br("focusout", "onBlur");
br(yx, "onTransitionEnd");
uo("onMouseEnter", ["mouseout", "mouseover"]);
uo("onMouseLeave", ["mouseout", "mouseover"]);
uo("onPointerEnter", ["pointerout", "pointerover"]);
uo("onPointerLeave", ["pointerout", "pointerover"]);
us(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
us(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
us("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
us(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
us(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
us(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Ta =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  uT = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ta));
function Og(n, e, t) {
  var i = n.type || "unknown-event";
  (n.currentTarget = t), lw(i, e, void 0, n), (n.currentTarget = null);
}
function xx(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t],
      r = i.event;
    i = i.listeners;
    e: {
      var o = void 0;
      if (e)
        for (var p = i.length - 1; 0 <= p; p--) {
          var a = i[p],
            s = a.instance,
            u = a.currentTarget;
          if (((a = a.listener), s !== o && r.isPropagationStopped())) break e;
          Og(r, a, u), (o = s);
        }
      else
        for (p = 0; p < i.length; p++) {
          if (
            ((a = i[p]),
            (s = a.instance),
            (u = a.currentTarget),
            (a = a.listener),
            s !== o && r.isPropagationStopped())
          )
            break e;
          Og(r, a, u), (o = s);
        }
    }
  }
  if (Zc) throw ((n = od), (Zc = !1), (od = null), n);
}
function mt(n, e) {
  var t = e[gd];
  t === void 0 && (t = e[gd] = new Set());
  var i = n + "__bubble";
  t.has(i) || (bx(e, n, 2, !1), t.add(i));
}
function Lh(n, e, t) {
  var i = 0;
  e && (i |= 4), bx(t, n, i, e);
}
var $l = "_reactListening" + Math.random().toString(36).slice(2);
function Ka(n) {
  if (!n[$l]) {
    (n[$l] = !0),
      A_.forEach(function (t) {
        t !== "selectionchange" && (uT.has(t) || Lh(t, !1, n), Lh(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[$l] || ((e[$l] = !0), Lh("selectionchange", !1, e));
  }
}
function bx(n, e, t, i) {
  switch (rx(e)) {
    case 1:
      var r = Tw;
      break;
    case 4:
      r = Cw;
      break;
    default:
      r = xp;
  }
  (t = r.bind(null, e, t, n)),
    (r = void 0),
    !sd ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: r })
        : n.addEventListener(e, t, !0)
      : r !== void 0
      ? n.addEventListener(e, t, { passive: r })
      : n.addEventListener(e, t, !1);
}
function Dh(n, e, t, i, r) {
  var o = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var p = i.tag;
      if (p === 3 || p === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (p === 4)
          for (p = i.return; p !== null; ) {
            var s = p.tag;
            if (
              (s === 3 || s === 4) &&
              ((s = p.stateNode.containerInfo),
              s === r || (s.nodeType === 8 && s.parentNode === r))
            )
              return;
            p = p.return;
          }
        for (; a !== null; ) {
          if (((p = jr(a)), p === null)) return;
          if (((s = p.tag), s === 5 || s === 6)) {
            i = o = p;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  W_(function () {
    var u = o,
      d = gp(t),
      l = [];
    e: {
      var c = _x.get(n);
      if (c !== void 0) {
        var h = Sp,
          m = n;
        switch (n) {
          case "keypress":
            if (Rc(t) === 0) break e;
          case "keydown":
          case "keyup":
            h = Uw;
            break;
          case "focusin":
            (m = "focus"), (h = Ch);
            break;
          case "focusout":
            (m = "blur"), (h = Ch);
            break;
          case "beforeblur":
          case "afterblur":
            h = Ch;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            h = yg;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            h = Aw;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            h = Vw;
            break;
          case mx:
          case gx:
          case vx:
            h = Lw;
            break;
          case yx:
            h = Gw;
            break;
          case "scroll":
            h = Mw;
            break;
          case "wheel":
            h = Xw;
            break;
          case "copy":
          case "cut":
          case "paste":
            h = Rw;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            h = xg;
        }
        var g = (e & 4) !== 0,
          f = !g && n === "scroll",
          v = g ? (c !== null ? c + "Capture" : null) : c;
        g = [];
        for (var y = u, _; y !== null; ) {
          _ = y;
          var x = _.stateNode;
          if (
            (_.tag === 5 &&
              x !== null &&
              ((_ = x),
              v !== null && ((x = Va(y, v)), x != null && g.push(qa(y, x, _)))),
            f)
          )
            break;
          y = y.return;
        }
        0 < g.length &&
          ((c = new h(c, m, null, t, d)), l.push({ event: c, listeners: g }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((c = n === "mouseover" || n === "pointerover"),
          (h = n === "mouseout" || n === "pointerout"),
          c &&
            t !== id &&
            (m = t.relatedTarget || t.fromElement) &&
            (jr(m) || m[Ui]))
        )
          break e;
        if (
          (h || c) &&
          ((c =
            d.window === d
              ? d
              : (c = d.ownerDocument)
              ? c.defaultView || c.parentWindow
              : window),
          h
            ? ((m = t.relatedTarget || t.toElement),
              (h = u),
              (m = m ? jr(m) : null),
              m !== null &&
                ((f = hs(m)), m !== f || (m.tag !== 5 && m.tag !== 6)) &&
                (m = null))
            : ((h = null), (m = u)),
          h !== m)
        ) {
          if (
            ((g = yg),
            (x = "onMouseLeave"),
            (v = "onMouseEnter"),
            (y = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((g = xg),
              (x = "onPointerLeave"),
              (v = "onPointerEnter"),
              (y = "pointer")),
            (f = h == null ? c : js(h)),
            (_ = m == null ? c : js(m)),
            (c = new g(x, y + "leave", h, t, d)),
            (c.target = f),
            (c.relatedTarget = _),
            (x = null),
            jr(d) === u &&
              ((g = new g(v, y + "enter", m, t, d)),
              (g.target = _),
              (g.relatedTarget = f),
              (x = g)),
            (f = x),
            h && m)
          )
            t: {
              for (g = h, v = m, y = 0, _ = g; _; _ = vs(_)) y++;
              for (_ = 0, x = v; x; x = vs(x)) _++;
              for (; 0 < y - _; ) (g = vs(g)), y--;
              for (; 0 < _ - y; ) (v = vs(v)), _--;
              for (; y--; ) {
                if (g === v || (v !== null && g === v.alternate)) break t;
                (g = vs(g)), (v = vs(v));
              }
              g = null;
            }
          else g = null;
          h !== null && Lg(l, c, h, g, !1),
            m !== null && f !== null && Lg(l, f, m, g, !0);
        }
      }
      e: {
        if (
          ((c = u ? js(u) : window),
          (h = c.nodeName && c.nodeName.toLowerCase()),
          h === "select" || (h === "input" && c.type === "file"))
        )
          var b = eT;
        else if (wg(c))
          if (ux) b = rT;
          else {
            b = nT;
            var S = tT;
          }
        else
          (h = c.nodeName) &&
            h.toLowerCase() === "input" &&
            (c.type === "checkbox" || c.type === "radio") &&
            (b = iT);
        if (b && (b = b(n, u))) {
          cx(l, b, t, d);
          break e;
        }
        S && S(n, c, u),
          n === "focusout" &&
            (S = c._wrapperState) &&
            S.controlled &&
            c.type === "number" &&
            Jf(c, "number", c.value);
      }
      switch (((S = u ? js(u) : window), n)) {
        case "focusin":
          (wg(S) || S.contentEditable === "true") &&
            ((zs = S), (ud = u), (La = null));
          break;
        case "focusout":
          La = ud = zs = null;
          break;
        case "mousedown":
          hd = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (hd = !1), Ag(l, t, d);
          break;
        case "selectionchange":
          if (aT) break;
        case "keydown":
        case "keyup":
          Ag(l, t, d);
      }
      var T;
      if (Tp)
        e: {
          switch (n) {
            case "compositionstart":
              var w = "onCompositionStart";
              break e;
            case "compositionend":
              w = "onCompositionEnd";
              break e;
            case "compositionupdate":
              w = "onCompositionUpdate";
              break e;
          }
          w = void 0;
        }
      else
        Bs
          ? ax(n, t) && (w = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (w = "onCompositionStart");
      w &&
        (ox &&
          t.locale !== "ko" &&
          (Bs || w !== "onCompositionStart"
            ? w === "onCompositionEnd" && Bs && (T = sx())
            : ((rr = d),
              (bp = "value" in rr ? rr.value : rr.textContent),
              (Bs = !0))),
        (S = nu(u, w)),
        0 < S.length &&
          ((w = new _g(w, n, null, t, d)),
          l.push({ event: w, listeners: S }),
          T ? (w.data = T) : ((T = lx(t)), T !== null && (w.data = T)))),
        (T = Kw ? qw(n, t) : Zw(n, t)) &&
          ((u = nu(u, "onBeforeInput")),
          0 < u.length &&
            ((d = new _g("onBeforeInput", "beforeinput", null, t, d)),
            l.push({ event: d, listeners: u }),
            (d.data = T)));
    }
    xx(l, e);
  });
}
function qa(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function nu(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n,
      o = r.stateNode;
    r.tag === 5 &&
      o !== null &&
      ((r = o),
      (o = Va(n, t)),
      o != null && i.unshift(qa(n, o, r)),
      (o = Va(n, e)),
      o != null && i.push(qa(n, o, r))),
      (n = n.return);
  }
  return i;
}
function vs(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function Lg(n, e, t, i, r) {
  for (var o = e._reactName, p = []; t !== null && t !== i; ) {
    var a = t,
      s = a.alternate,
      u = a.stateNode;
    if (s !== null && s === i) break;
    a.tag === 5 &&
      u !== null &&
      ((a = u),
      r
        ? ((s = Va(t, o)), s != null && p.unshift(qa(t, s, a)))
        : r || ((s = Va(t, o)), s != null && p.push(qa(t, s, a)))),
      (t = t.return);
  }
  p.length !== 0 && n.push({ event: e, listeners: p });
}
var hT = /\r\n?/g,
  fT = /\u0000|\uFFFD/g;
function Dg(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      hT,
      `
`
    )
    .replace(fT, "");
}
function Xl(n, e, t) {
  if (((e = Dg(e)), Dg(n) !== e && t)) throw Error(be(425));
}
function iu() {}
var fd = null,
  dd = null;
function pd(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var md = typeof setTimeout == "function" ? setTimeout : void 0,
  dT = typeof clearTimeout == "function" ? clearTimeout : void 0,
  Rg = typeof Promise == "function" ? Promise : void 0,
  pT =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof Rg < "u"
      ? function (n) {
          return Rg.resolve(null).then(n).catch(mT);
        }
      : md;
function mT(n) {
  setTimeout(function () {
    throw n;
  });
}
function Rh(n, e) {
  var t = e,
    i = 0;
  do {
    var r = t.nextSibling;
    if ((n.removeChild(t), r && r.nodeType === 8))
      if (((t = r.data), t === "/$")) {
        if (i === 0) {
          n.removeChild(r), $a(e);
          return;
        }
        i--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || i++;
    t = r;
  } while (t);
  $a(e);
}
function hr(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function Ig(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var Lo = Math.random().toString(36).slice(2),
  vi = "__reactFiber$" + Lo,
  Za = "__reactProps$" + Lo,
  Ui = "__reactContainer$" + Lo,
  gd = "__reactEvents$" + Lo,
  gT = "__reactListeners$" + Lo,
  vT = "__reactHandles$" + Lo;
function jr(n) {
  var e = n[vi];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[Ui] || t[vi])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = Ig(n); n !== null; ) {
          if ((t = n[vi])) return t;
          n = Ig(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function _l(n) {
  return (
    (n = n[vi] || n[Ui]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function js(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(be(33));
}
function Du(n) {
  return n[Za] || null;
}
var vd = [],
  Hs = -1;
function Sr(n) {
  return { current: n };
}
function vt(n) {
  0 > Hs || ((n.current = vd[Hs]), (vd[Hs] = null), Hs--);
}
function pt(n, e) {
  Hs++, (vd[Hs] = n.current), (n.current = e);
}
var yr = {},
  Qt = Sr(yr),
  yn = Sr(!1),
  Qr = yr;
function ho(n, e) {
  var t = n.type.contextTypes;
  if (!t) return yr;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    o;
  for (o in t) r[o] = e[o];
  return (
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function _n(n) {
  return (n = n.childContextTypes), n != null;
}
function ru() {
  vt(yn), vt(Qt);
}
function kg(n, e, t) {
  if (Qt.current !== yr) throw Error(be(168));
  pt(Qt, e), pt(yn, t);
}
function Sx(n, e, t) {
  var i = n.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(be(108, tw(n) || "Unknown", r));
  return wt({}, t, i);
}
function su(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || yr),
    (Qr = Qt.current),
    pt(Qt, n),
    pt(yn, yn.current),
    !0
  );
}
function Fg(n, e, t) {
  var i = n.stateNode;
  if (!i) throw Error(be(169));
  t
    ? ((n = Sx(n, e, Qr)),
      (i.__reactInternalMemoizedMergedChildContext = n),
      vt(yn),
      vt(Qt),
      pt(Qt, n))
    : vt(yn),
    pt(yn, t);
}
var Di = null,
  Ru = !1,
  Ih = !1;
function wx(n) {
  Di === null ? (Di = [n]) : Di.push(n);
}
function yT(n) {
  (Ru = !0), wx(n);
}
function wr() {
  if (!Ih && Di !== null) {
    Ih = !0;
    var n = 0,
      e = lt;
    try {
      var t = Di;
      for (lt = 1; n < t.length; n++) {
        var i = t[n];
        do i = i(!0);
        while (i !== null);
      }
      (Di = null), (Ru = !1);
    } catch (r) {
      throw (Di !== null && (Di = Di.slice(n + 1)), Y_(vp, wr), r);
    } finally {
      (lt = e), (Ih = !1);
    }
  }
  return null;
}
var Vs = [],
  Ws = 0,
  ou = null,
  au = 0,
  jn = [],
  Hn = 0,
  es = null,
  Ii = 1,
  ki = "";
function Ir(n, e) {
  (Vs[Ws++] = au), (Vs[Ws++] = ou), (ou = n), (au = e);
}
function Tx(n, e, t) {
  (jn[Hn++] = Ii), (jn[Hn++] = ki), (jn[Hn++] = es), (es = n);
  var i = Ii;
  n = ki;
  var r = 32 - ri(i) - 1;
  (i &= ~(1 << r)), (t += 1);
  var o = 32 - ri(e) + r;
  if (30 < o) {
    var p = r - (r % 5);
    (o = (i & ((1 << p) - 1)).toString(32)),
      (i >>= p),
      (r -= p),
      (Ii = (1 << (32 - ri(e) + r)) | (t << r) | i),
      (ki = o + n);
  } else (Ii = (1 << o) | (t << r) | i), (ki = n);
}
function Mp(n) {
  n.return !== null && (Ir(n, 1), Tx(n, 1, 0));
}
function Ep(n) {
  for (; n === ou; )
    (ou = Vs[--Ws]), (Vs[Ws] = null), (au = Vs[--Ws]), (Vs[Ws] = null);
  for (; n === es; )
    (es = jn[--Hn]),
      (jn[Hn] = null),
      (ki = jn[--Hn]),
      (jn[Hn] = null),
      (Ii = jn[--Hn]),
      (jn[Hn] = null);
}
var On = null,
  En = null,
  _t = !1,
  ii = null;
function Cx(n, e) {
  var t = Gn(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function Ng(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (On = n), (En = hr(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (On = n), (En = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = es !== null ? { id: Ii, overflow: ki } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = Gn(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (On = n),
            (En = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function yd(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function _d(n) {
  if (_t) {
    var e = En;
    if (e) {
      var t = e;
      if (!Ng(n, e)) {
        if (yd(n)) throw Error(be(418));
        e = hr(t.nextSibling);
        var i = On;
        e && Ng(n, e)
          ? Cx(i, t)
          : ((n.flags = (n.flags & -4097) | 2), (_t = !1), (On = n));
      }
    } else {
      if (yd(n)) throw Error(be(418));
      (n.flags = (n.flags & -4097) | 2), (_t = !1), (On = n);
    }
  }
}
function Bg(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  On = n;
}
function Yl(n) {
  if (n !== On) return !1;
  if (!_t) return Bg(n), (_t = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !pd(n.type, n.memoizedProps))),
    e && (e = En))
  ) {
    if (yd(n)) throw (Mx(), Error(be(418)));
    for (; e; ) Cx(n, e), (e = hr(e.nextSibling));
  }
  if ((Bg(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(be(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              En = hr(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      En = null;
    }
  } else En = On ? hr(n.stateNode.nextSibling) : null;
  return !0;
}
function Mx() {
  for (var n = En; n; ) n = hr(n.nextSibling);
}
function fo() {
  (En = On = null), (_t = !1);
}
function Ap(n) {
  ii === null ? (ii = [n]) : ii.push(n);
}
var _T = Vi.ReactCurrentBatchConfig;
function ti(n, e) {
  if (n && n.defaultProps) {
    (e = wt({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
var lu = Sr(null),
  cu = null,
  Gs = null,
  Pp = null;
function Op() {
  Pp = Gs = cu = null;
}
function Lp(n) {
  var e = lu.current;
  vt(lu), (n._currentValue = e);
}
function xd(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function no(n, e) {
  (cu = n),
    (Pp = Gs = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (gn = !0), (n.firstContext = null));
}
function Yn(n) {
  var e = n._currentValue;
  if (Pp !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), Gs === null)) {
      if (cu === null) throw Error(be(308));
      (Gs = n), (cu.dependencies = { lanes: 0, firstContext: n });
    } else Gs = Gs.next = n;
  return e;
}
var Hr = null;
function Dp(n) {
  Hr === null ? (Hr = [n]) : Hr.push(n);
}
function Ex(n, e, t, i) {
  var r = e.interleaved;
  return (
    r === null ? ((t.next = t), Dp(e)) : ((t.next = r.next), (r.next = t)),
    (e.interleaved = t),
    ji(n, i)
  );
}
function ji(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var Qi = !1;
function Rp(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function Ax(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function Ni(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function fr(n, e, t) {
  var i = n.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), nt & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      ji(n, t)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), Dp(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    ji(n, t)
  );
}
function Ic(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), yp(n, t);
  }
}
function zg(n, e) {
  var t = n.updateQueue,
    i = n.alternate;
  if (i !== null && ((i = i.updateQueue), t === i)) {
    var r = null,
      o = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var p = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        o === null ? (r = o = p) : (o = o.next = p), (t = t.next);
      } while (t !== null);
      o === null ? (r = o = e) : (o = o.next = e);
    } else r = o = e;
    (t = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: o,
      shared: i.shared,
      effects: i.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function uu(n, e, t, i) {
  var r = n.updateQueue;
  Qi = !1;
  var o = r.firstBaseUpdate,
    p = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var s = a,
      u = s.next;
    (s.next = null), p === null ? (o = u) : (p.next = u), (p = s);
    var d = n.alternate;
    d !== null &&
      ((d = d.updateQueue),
      (a = d.lastBaseUpdate),
      a !== p &&
        (a === null ? (d.firstBaseUpdate = u) : (a.next = u),
        (d.lastBaseUpdate = s)));
  }
  if (o !== null) {
    var l = r.baseState;
    (p = 0), (d = u = s = null), (a = o);
    do {
      var c = a.lane,
        h = a.eventTime;
      if ((i & c) === c) {
        d !== null &&
          (d = d.next =
            {
              eventTime: h,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var m = n,
            g = a;
          switch (((c = e), (h = t), g.tag)) {
            case 1:
              if (((m = g.payload), typeof m == "function")) {
                l = m.call(h, l, c);
                break e;
              }
              l = m;
              break e;
            case 3:
              m.flags = (m.flags & -65537) | 128;
            case 0:
              if (
                ((m = g.payload),
                (c = typeof m == "function" ? m.call(h, l, c) : m),
                c == null)
              )
                break e;
              l = wt({}, l, c);
              break e;
            case 2:
              Qi = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (c = r.effects),
          c === null ? (r.effects = [a]) : c.push(a));
      } else
        (h = {
          eventTime: h,
          lane: c,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          d === null ? ((u = d = h), (s = l)) : (d = d.next = h),
          (p |= c);
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        (c = a),
          (a = c.next),
          (c.next = null),
          (r.lastBaseUpdate = c),
          (r.shared.pending = null);
      }
    } while (1);
    if (
      (d === null && (s = l),
      (r.baseState = s),
      (r.firstBaseUpdate = u),
      (r.lastBaseUpdate = d),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (p |= r.lane), (r = r.next);
      while (r !== e);
    } else o === null && (r.shared.lanes = 0);
    (ns |= p), (n.lanes = p), (n.memoizedState = l);
  }
}
function Ug(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var i = n[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = t), typeof r != "function"))
          throw Error(be(191, r));
        r.call(i);
      }
    }
}
var Px = new E_.Component().refs;
function bd(n, e, t, i) {
  (e = n.memoizedState),
    (t = t(i, e)),
    (t = t == null ? e : wt({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var Iu = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? hs(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var i = un(),
      r = pr(n),
      o = Ni(i, r);
    (o.payload = e),
      t != null && (o.callback = t),
      (e = fr(n, o, r)),
      e !== null && (si(e, n, r, i), Ic(e, n, r));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var i = un(),
      r = pr(n),
      o = Ni(i, r);
    (o.tag = 1),
      (o.payload = e),
      t != null && (o.callback = t),
      (e = fr(n, o, r)),
      e !== null && (si(e, n, r, i), Ic(e, n, r));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = un(),
      i = pr(n),
      r = Ni(t, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = fr(n, r, i)),
      e !== null && (si(e, n, i, t), Ic(e, n, i));
  },
};
function jg(n, e, t, i, r, o, p) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(i, o, p)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Ya(t, i) || !Ya(r, o)
      : !0
  );
}
function Ox(n, e, t) {
  var i = !1,
    r = yr,
    o = e.contextType;
  return (
    typeof o == "object" && o !== null
      ? (o = Yn(o))
      : ((r = _n(e) ? Qr : Qt.current),
        (i = e.contextTypes),
        (o = (i = i != null) ? ho(n, r) : yr)),
    (e = new e(t, o)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = Iu),
    (n.stateNode = e),
    (e._reactInternals = n),
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = r),
      (n.__reactInternalMemoizedMaskedChildContext = o)),
    e
  );
}
function Hg(n, e, t, i) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && Iu.enqueueReplaceState(e, e.state, null);
}
function Sd(n, e, t, i) {
  var r = n.stateNode;
  (r.props = t), (r.state = n.memoizedState), (r.refs = Px), Rp(n);
  var o = e.contextType;
  typeof o == "object" && o !== null
    ? (r.context = Yn(o))
    : ((o = _n(e) ? Qr : Qt.current), (r.context = ho(n, o))),
    (r.state = n.memoizedState),
    (o = e.getDerivedStateFromProps),
    typeof o == "function" && (bd(n, e, o, t), (r.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && Iu.enqueueReplaceState(r, r.state, null),
      uu(n, t, r, i),
      (r.state = n.memoizedState)),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308);
}
function ta(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(be(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(be(147, n));
      var r = i,
        o = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === o
        ? e.ref
        : ((e = function (p) {
            var a = r.refs;
            a === Px && (a = r.refs = {}),
              p === null ? delete a[o] : (a[o] = p);
          }),
          (e._stringRef = o),
          e);
    }
    if (typeof n != "string") throw Error(be(284));
    if (!t._owner) throw Error(be(290, n));
  }
  return n;
}
function Kl(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      be(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function Vg(n) {
  var e = n._init;
  return e(n._payload);
}
function Lx(n) {
  function e(v, y) {
    if (n) {
      var _ = v.deletions;
      _ === null ? ((v.deletions = [y]), (v.flags |= 16)) : _.push(y);
    }
  }
  function t(v, y) {
    if (!n) return null;
    for (; y !== null; ) e(v, y), (y = y.sibling);
    return null;
  }
  function i(v, y) {
    for (v = new Map(); y !== null; )
      y.key !== null ? v.set(y.key, y) : v.set(y.index, y), (y = y.sibling);
    return v;
  }
  function r(v, y) {
    return (v = mr(v, y)), (v.index = 0), (v.sibling = null), v;
  }
  function o(v, y, _) {
    return (
      (v.index = _),
      n
        ? ((_ = v.alternate),
          _ !== null
            ? ((_ = _.index), _ < y ? ((v.flags |= 2), y) : _)
            : ((v.flags |= 2), y))
        : ((v.flags |= 1048576), y)
    );
  }
  function p(v) {
    return n && v.alternate === null && (v.flags |= 2), v;
  }
  function a(v, y, _, x) {
    return y === null || y.tag !== 6
      ? ((y = jh(_, v.mode, x)), (y.return = v), y)
      : ((y = r(y, _)), (y.return = v), y);
  }
  function s(v, y, _, x) {
    var b = _.type;
    return b === Ns
      ? d(v, y, _.props.children, x, _.key)
      : y !== null &&
        (y.elementType === b ||
          (typeof b == "object" &&
            b !== null &&
            b.$$typeof === Ji &&
            Vg(b) === y.type))
      ? ((x = r(y, _.props)), (x.ref = ta(v, y, _)), (x.return = v), x)
      : ((x = Uc(_.type, _.key, _.props, null, v.mode, x)),
        (x.ref = ta(v, y, _)),
        (x.return = v),
        x);
  }
  function u(v, y, _, x) {
    return y === null ||
      y.tag !== 4 ||
      y.stateNode.containerInfo !== _.containerInfo ||
      y.stateNode.implementation !== _.implementation
      ? ((y = Hh(_, v.mode, x)), (y.return = v), y)
      : ((y = r(y, _.children || [])), (y.return = v), y);
  }
  function d(v, y, _, x, b) {
    return y === null || y.tag !== 7
      ? ((y = Xr(_, v.mode, x, b)), (y.return = v), y)
      : ((y = r(y, _)), (y.return = v), y);
  }
  function l(v, y, _) {
    if ((typeof y == "string" && y !== "") || typeof y == "number")
      return (y = jh("" + y, v.mode, _)), (y.return = v), y;
    if (typeof y == "object" && y !== null) {
      switch (y.$$typeof) {
        case Bl:
          return (
            (_ = Uc(y.type, y.key, y.props, null, v.mode, _)),
            (_.ref = ta(v, null, y)),
            (_.return = v),
            _
          );
        case Fs:
          return (y = Hh(y, v.mode, _)), (y.return = v), y;
        case Ji:
          var x = y._init;
          return l(v, x(y._payload), _);
      }
      if (Sa(y) || qo(y))
        return (y = Xr(y, v.mode, _, null)), (y.return = v), y;
      Kl(v, y);
    }
    return null;
  }
  function c(v, y, _, x) {
    var b = y !== null ? y.key : null;
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return b !== null ? null : a(v, y, "" + _, x);
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case Bl:
          return _.key === b ? s(v, y, _, x) : null;
        case Fs:
          return _.key === b ? u(v, y, _, x) : null;
        case Ji:
          return (b = _._init), c(v, y, b(_._payload), x);
      }
      if (Sa(_) || qo(_)) return b !== null ? null : d(v, y, _, x, null);
      Kl(v, _);
    }
    return null;
  }
  function h(v, y, _, x, b) {
    if ((typeof x == "string" && x !== "") || typeof x == "number")
      return (v = v.get(_) || null), a(y, v, "" + x, b);
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case Bl:
          return (v = v.get(x.key === null ? _ : x.key) || null), s(y, v, x, b);
        case Fs:
          return (v = v.get(x.key === null ? _ : x.key) || null), u(y, v, x, b);
        case Ji:
          var S = x._init;
          return h(v, y, _, S(x._payload), b);
      }
      if (Sa(x) || qo(x)) return (v = v.get(_) || null), d(y, v, x, b, null);
      Kl(y, x);
    }
    return null;
  }
  function m(v, y, _, x) {
    for (
      var b = null, S = null, T = y, w = (y = 0), P = null;
      T !== null && w < _.length;
      w++
    ) {
      T.index > w ? ((P = T), (T = null)) : (P = T.sibling);
      var F = c(v, T, _[w], x);
      if (F === null) {
        T === null && (T = P);
        break;
      }
      n && T && F.alternate === null && e(v, T),
        (y = o(F, y, w)),
        S === null ? (b = F) : (S.sibling = F),
        (S = F),
        (T = P);
    }
    if (w === _.length) return t(v, T), _t && Ir(v, w), b;
    if (T === null) {
      for (; w < _.length; w++)
        (T = l(v, _[w], x)),
          T !== null &&
            ((y = o(T, y, w)), S === null ? (b = T) : (S.sibling = T), (S = T));
      return _t && Ir(v, w), b;
    }
    for (T = i(v, T); w < _.length; w++)
      (P = h(T, v, w, _[w], x)),
        P !== null &&
          (n && P.alternate !== null && T.delete(P.key === null ? w : P.key),
          (y = o(P, y, w)),
          S === null ? (b = P) : (S.sibling = P),
          (S = P));
    return (
      n &&
        T.forEach(function (V) {
          return e(v, V);
        }),
      _t && Ir(v, w),
      b
    );
  }
  function g(v, y, _, x) {
    var b = qo(_);
    if (typeof b != "function") throw Error(be(150));
    if (((_ = b.call(_)), _ == null)) throw Error(be(151));
    for (
      var S = (b = null), T = y, w = (y = 0), P = null, F = _.next();
      T !== null && !F.done;
      w++, F = _.next()
    ) {
      T.index > w ? ((P = T), (T = null)) : (P = T.sibling);
      var V = c(v, T, F.value, x);
      if (V === null) {
        T === null && (T = P);
        break;
      }
      n && T && V.alternate === null && e(v, T),
        (y = o(V, y, w)),
        S === null ? (b = V) : (S.sibling = V),
        (S = V),
        (T = P);
    }
    if (F.done) return t(v, T), _t && Ir(v, w), b;
    if (T === null) {
      for (; !F.done; w++, F = _.next())
        (F = l(v, F.value, x)),
          F !== null &&
            ((y = o(F, y, w)), S === null ? (b = F) : (S.sibling = F), (S = F));
      return _t && Ir(v, w), b;
    }
    for (T = i(v, T); !F.done; w++, F = _.next())
      (F = h(T, v, w, F.value, x)),
        F !== null &&
          (n && F.alternate !== null && T.delete(F.key === null ? w : F.key),
          (y = o(F, y, w)),
          S === null ? (b = F) : (S.sibling = F),
          (S = F));
    return (
      n &&
        T.forEach(function (J) {
          return e(v, J);
        }),
      _t && Ir(v, w),
      b
    );
  }
  function f(v, y, _, x) {
    if (
      (typeof _ == "object" &&
        _ !== null &&
        _.type === Ns &&
        _.key === null &&
        (_ = _.props.children),
      typeof _ == "object" && _ !== null)
    ) {
      switch (_.$$typeof) {
        case Bl:
          e: {
            for (var b = _.key, S = y; S !== null; ) {
              if (S.key === b) {
                if (((b = _.type), b === Ns)) {
                  if (S.tag === 7) {
                    t(v, S.sibling),
                      (y = r(S, _.props.children)),
                      (y.return = v),
                      (v = y);
                    break e;
                  }
                } else if (
                  S.elementType === b ||
                  (typeof b == "object" &&
                    b !== null &&
                    b.$$typeof === Ji &&
                    Vg(b) === S.type)
                ) {
                  t(v, S.sibling),
                    (y = r(S, _.props)),
                    (y.ref = ta(v, S, _)),
                    (y.return = v),
                    (v = y);
                  break e;
                }
                t(v, S);
                break;
              } else e(v, S);
              S = S.sibling;
            }
            _.type === Ns
              ? ((y = Xr(_.props.children, v.mode, x, _.key)),
                (y.return = v),
                (v = y))
              : ((x = Uc(_.type, _.key, _.props, null, v.mode, x)),
                (x.ref = ta(v, y, _)),
                (x.return = v),
                (v = x));
          }
          return p(v);
        case Fs:
          e: {
            for (S = _.key; y !== null; ) {
              if (y.key === S)
                if (
                  y.tag === 4 &&
                  y.stateNode.containerInfo === _.containerInfo &&
                  y.stateNode.implementation === _.implementation
                ) {
                  t(v, y.sibling),
                    (y = r(y, _.children || [])),
                    (y.return = v),
                    (v = y);
                  break e;
                } else {
                  t(v, y);
                  break;
                }
              else e(v, y);
              y = y.sibling;
            }
            (y = Hh(_, v.mode, x)), (y.return = v), (v = y);
          }
          return p(v);
        case Ji:
          return (S = _._init), f(v, y, S(_._payload), x);
      }
      if (Sa(_)) return m(v, y, _, x);
      if (qo(_)) return g(v, y, _, x);
      Kl(v, _);
    }
    return (typeof _ == "string" && _ !== "") || typeof _ == "number"
      ? ((_ = "" + _),
        y !== null && y.tag === 6
          ? (t(v, y.sibling), (y = r(y, _)), (y.return = v), (v = y))
          : (t(v, y), (y = jh(_, v.mode, x)), (y.return = v), (v = y)),
        p(v))
      : t(v, y);
  }
  return f;
}
var po = Lx(!0),
  Dx = Lx(!1),
  xl = {},
  _i = Sr(xl),
  Ja = Sr(xl),
  Qa = Sr(xl);
function Vr(n) {
  if (n === xl) throw Error(be(174));
  return n;
}
function Ip(n, e) {
  switch ((pt(Qa, e), pt(Ja, n), pt(_i, xl), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : ed(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = ed(e, n));
  }
  vt(_i), pt(_i, e);
}
function mo() {
  vt(_i), vt(Ja), vt(Qa);
}
function Rx(n) {
  Vr(Qa.current);
  var e = Vr(_i.current),
    t = ed(e, n.type);
  e !== t && (pt(Ja, n), pt(_i, t));
}
function kp(n) {
  Ja.current === n && (vt(_i), vt(Ja));
}
var xt = Sr(0);
function hu(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var kh = [];
function Fp() {
  for (var n = 0; n < kh.length; n++)
    kh[n]._workInProgressVersionPrimary = null;
  kh.length = 0;
}
var kc = Vi.ReactCurrentDispatcher,
  Fh = Vi.ReactCurrentBatchConfig,
  ts = 0,
  bt = null,
  Dt = null,
  Bt = null,
  fu = !1,
  Da = !1,
  el = 0,
  xT = 0;
function Yt() {
  throw Error(be(321));
}
function Np(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!ai(n[t], e[t])) return !1;
  return !0;
}
function Bp(n, e, t, i, r, o) {
  if (
    ((ts = o),
    (bt = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (kc.current = n === null || n.memoizedState === null ? TT : CT),
    (n = t(i, r)),
    Da)
  ) {
    o = 0;
    do {
      if (((Da = !1), (el = 0), 25 <= o)) throw Error(be(301));
      (o += 1),
        (Bt = Dt = null),
        (e.updateQueue = null),
        (kc.current = MT),
        (n = t(i, r));
    } while (Da);
  }
  if (
    ((kc.current = du),
    (e = Dt !== null && Dt.next !== null),
    (ts = 0),
    (Bt = Dt = bt = null),
    (fu = !1),
    e)
  )
    throw Error(be(300));
  return n;
}
function zp() {
  var n = el !== 0;
  return (el = 0), n;
}
function di() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return Bt === null ? (bt.memoizedState = Bt = n) : (Bt = Bt.next = n), Bt;
}
function Kn() {
  if (Dt === null) {
    var n = bt.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Dt.next;
  var e = Bt === null ? bt.memoizedState : Bt.next;
  if (e !== null) (Bt = e), (Dt = n);
  else {
    if (n === null) throw Error(be(310));
    (Dt = n),
      (n = {
        memoizedState: Dt.memoizedState,
        baseState: Dt.baseState,
        baseQueue: Dt.baseQueue,
        queue: Dt.queue,
        next: null,
      }),
      Bt === null ? (bt.memoizedState = Bt = n) : (Bt = Bt.next = n);
  }
  return Bt;
}
function tl(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function Nh(n) {
  var e = Kn(),
    t = e.queue;
  if (t === null) throw Error(be(311));
  t.lastRenderedReducer = n;
  var i = Dt,
    r = i.baseQueue,
    o = t.pending;
  if (o !== null) {
    if (r !== null) {
      var p = r.next;
      (r.next = o.next), (o.next = p);
    }
    (i.baseQueue = r = o), (t.pending = null);
  }
  if (r !== null) {
    (o = r.next), (i = i.baseState);
    var a = (p = null),
      s = null,
      u = o;
    do {
      var d = u.lane;
      if ((ts & d) === d)
        s !== null &&
          (s = s.next =
            {
              lane: 0,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null,
            }),
          (i = u.hasEagerState ? u.eagerState : n(i, u.action));
      else {
        var l = {
          lane: d,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null,
        };
        s === null ? ((a = s = l), (p = i)) : (s = s.next = l),
          (bt.lanes |= d),
          (ns |= d);
      }
      u = u.next;
    } while (u !== null && u !== o);
    s === null ? (p = i) : (s.next = a),
      ai(i, e.memoizedState) || (gn = !0),
      (e.memoizedState = i),
      (e.baseState = p),
      (e.baseQueue = s),
      (t.lastRenderedState = i);
  }
  if (((n = t.interleaved), n !== null)) {
    r = n;
    do (o = r.lane), (bt.lanes |= o), (ns |= o), (r = r.next);
    while (r !== n);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function Bh(n) {
  var e = Kn(),
    t = e.queue;
  if (t === null) throw Error(be(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch,
    r = t.pending,
    o = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var p = (r = r.next);
    do (o = n(o, p.action)), (p = p.next);
    while (p !== r);
    ai(o, e.memoizedState) || (gn = !0),
      (e.memoizedState = o),
      e.baseQueue === null && (e.baseState = o),
      (t.lastRenderedState = o);
  }
  return [o, i];
}
function Ix() {}
function kx(n, e) {
  var t = bt,
    i = Kn(),
    r = e(),
    o = !ai(i.memoizedState, r);
  if (
    (o && ((i.memoizedState = r), (gn = !0)),
    (i = i.queue),
    Up(Bx.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || o || (Bt !== null && Bt.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      nl(9, Nx.bind(null, t, i, r, e), void 0, null),
      Ut === null)
    )
      throw Error(be(349));
    ts & 30 || Fx(t, e, r);
  }
  return r;
}
function Fx(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = bt.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (bt.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function Nx(n, e, t, i) {
  (e.value = t), (e.getSnapshot = i), zx(e) && Ux(n);
}
function Bx(n, e, t) {
  return t(function () {
    zx(e) && Ux(n);
  });
}
function zx(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !ai(n, t);
  } catch {
    return !0;
  }
}
function Ux(n) {
  var e = ji(n, 1);
  e !== null && si(e, n, 1, -1);
}
function Wg(n) {
  var e = di();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: tl,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = wT.bind(null, bt, n)),
    [e.memoizedState, n]
  );
}
function nl(n, e, t, i) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
    (e = bt.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (bt.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
    n
  );
}
function jx() {
  return Kn().memoizedState;
}
function Fc(n, e, t, i) {
  var r = di();
  (bt.flags |= n),
    (r.memoizedState = nl(1 | e, t, void 0, i === void 0 ? null : i));
}
function ku(n, e, t, i) {
  var r = Kn();
  i = i === void 0 ? null : i;
  var o = void 0;
  if (Dt !== null) {
    var p = Dt.memoizedState;
    if (((o = p.destroy), i !== null && Np(i, p.deps))) {
      r.memoizedState = nl(e, t, o, i);
      return;
    }
  }
  (bt.flags |= n), (r.memoizedState = nl(1 | e, t, o, i));
}
function Gg(n, e) {
  return Fc(8390656, 8, n, e);
}
function Up(n, e) {
  return ku(2048, 8, n, e);
}
function Hx(n, e) {
  return ku(4, 2, n, e);
}
function Vx(n, e) {
  return ku(4, 4, n, e);
}
function Wx(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function Gx(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), ku(4, 4, Wx.bind(null, e, n), t)
  );
}
function jp() {}
function $x(n, e) {
  var t = Kn();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && Np(e, i[1])
    ? i[0]
    : ((t.memoizedState = [n, e]), n);
}
function Xx(n, e) {
  var t = Kn();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && Np(e, i[1])
    ? i[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function Yx(n, e, t) {
  return ts & 21
    ? (ai(t, e) || ((t = Z_()), (bt.lanes |= t), (ns |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (gn = !0)), (n.memoizedState = t));
}
function bT(n, e) {
  var t = lt;
  (lt = t !== 0 && 4 > t ? t : 4), n(!0);
  var i = Fh.transition;
  Fh.transition = {};
  try {
    n(!1), e();
  } finally {
    (lt = t), (Fh.transition = i);
  }
}
function Kx() {
  return Kn().memoizedState;
}
function ST(n, e, t) {
  var i = pr(n);
  if (
    ((t = {
      lane: i,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    qx(n))
  )
    Zx(e, t);
  else if (((t = Ex(n, e, t, i)), t !== null)) {
    var r = un();
    si(t, n, i, r), Jx(t, e, i);
  }
}
function wT(n, e, t) {
  var i = pr(n),
    r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (qx(n)) Zx(e, r);
  else {
    var o = n.alternate;
    if (
      n.lanes === 0 &&
      (o === null || o.lanes === 0) &&
      ((o = e.lastRenderedReducer), o !== null)
    )
      try {
        var p = e.lastRenderedState,
          a = o(p, t);
        if (((r.hasEagerState = !0), (r.eagerState = a), ai(a, p))) {
          var s = e.interleaved;
          s === null
            ? ((r.next = r), Dp(e))
            : ((r.next = s.next), (s.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (t = Ex(n, e, r, i)),
      t !== null && ((r = un()), si(t, n, i, r), Jx(t, e, i));
  }
}
function qx(n) {
  var e = n.alternate;
  return n === bt || (e !== null && e === bt);
}
function Zx(n, e) {
  Da = fu = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function Jx(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), yp(n, t);
  }
}
var du = {
    readContext: Yn,
    useCallback: Yt,
    useContext: Yt,
    useEffect: Yt,
    useImperativeHandle: Yt,
    useInsertionEffect: Yt,
    useLayoutEffect: Yt,
    useMemo: Yt,
    useReducer: Yt,
    useRef: Yt,
    useState: Yt,
    useDebugValue: Yt,
    useDeferredValue: Yt,
    useTransition: Yt,
    useMutableSource: Yt,
    useSyncExternalStore: Yt,
    useId: Yt,
    unstable_isNewReconciler: !1,
  },
  TT = {
    readContext: Yn,
    useCallback: function (n, e) {
      return (di().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: Yn,
    useEffect: Gg,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        Fc(4194308, 4, Wx.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return Fc(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return Fc(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = di();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var i = di();
      return (
        (e = t !== void 0 ? t(e) : e),
        (i.memoizedState = i.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (i.queue = n),
        (n = n.dispatch = ST.bind(null, bt, n)),
        [i.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = di();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: Wg,
    useDebugValue: jp,
    useDeferredValue: function (n) {
      return (di().memoizedState = n);
    },
    useTransition: function () {
      var n = Wg(!1),
        e = n[0];
      return (n = bT.bind(null, n[1])), (di().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var i = bt,
        r = di();
      if (_t) {
        if (t === void 0) throw Error(be(407));
        t = t();
      } else {
        if (((t = e()), Ut === null)) throw Error(be(349));
        ts & 30 || Fx(i, e, t);
      }
      r.memoizedState = t;
      var o = { value: t, getSnapshot: e };
      return (
        (r.queue = o),
        Gg(Bx.bind(null, i, o, n), [n]),
        (i.flags |= 2048),
        nl(9, Nx.bind(null, i, o, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = di(),
        e = Ut.identifierPrefix;
      if (_t) {
        var t = ki,
          i = Ii;
        (t = (i & ~(1 << (32 - ri(i) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = el++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = xT++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  CT = {
    readContext: Yn,
    useCallback: $x,
    useContext: Yn,
    useEffect: Up,
    useImperativeHandle: Gx,
    useInsertionEffect: Hx,
    useLayoutEffect: Vx,
    useMemo: Xx,
    useReducer: Nh,
    useRef: jx,
    useState: function () {
      return Nh(tl);
    },
    useDebugValue: jp,
    useDeferredValue: function (n) {
      var e = Kn();
      return Yx(e, Dt.memoizedState, n);
    },
    useTransition: function () {
      var n = Nh(tl)[0],
        e = Kn().memoizedState;
      return [n, e];
    },
    useMutableSource: Ix,
    useSyncExternalStore: kx,
    useId: Kx,
    unstable_isNewReconciler: !1,
  },
  MT = {
    readContext: Yn,
    useCallback: $x,
    useContext: Yn,
    useEffect: Up,
    useImperativeHandle: Gx,
    useInsertionEffect: Hx,
    useLayoutEffect: Vx,
    useMemo: Xx,
    useReducer: Bh,
    useRef: jx,
    useState: function () {
      return Bh(tl);
    },
    useDebugValue: jp,
    useDeferredValue: function (n) {
      var e = Kn();
      return Dt === null ? (e.memoizedState = n) : Yx(e, Dt.memoizedState, n);
    },
    useTransition: function () {
      var n = Bh(tl)[0],
        e = Kn().memoizedState;
      return [n, e];
    },
    useMutableSource: Ix,
    useSyncExternalStore: kx,
    useId: Kx,
    unstable_isNewReconciler: !1,
  };
function go(n, e) {
  try {
    var t = "",
      i = e;
    do (t += ew(i)), (i = i.return);
    while (i);
    var r = t;
  } catch (o) {
    r =
      `
Error generating stack: ` +
      o.message +
      `
` +
      o.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function zh(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function wd(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var ET = typeof WeakMap == "function" ? WeakMap : Map;
function Qx(n, e, t) {
  (t = Ni(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var i = e.value;
  return (
    (t.callback = function () {
      mu || ((mu = !0), (Rd = i)), wd(n, e);
    }),
    t
  );
}
function eb(n, e, t) {
  (t = Ni(-1, t)), (t.tag = 3);
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (t.payload = function () {
      return i(r);
    }),
      (t.callback = function () {
        wd(n, e);
      });
  }
  var o = n.stateNode;
  return (
    o !== null &&
      typeof o.componentDidCatch == "function" &&
      (t.callback = function () {
        wd(n, e),
          typeof i != "function" &&
            (dr === null ? (dr = new Set([this])) : dr.add(this));
        var p = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: p !== null ? p : "",
        });
      }),
    t
  );
}
function $g(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new ET();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(t) || (r.add(t), (n = jT.bind(null, n, e, t)), e.then(n, n));
}
function Xg(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function Yg(n, e, t, i, r) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = r), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = Ni(-1, 1)), (e.tag = 2), fr(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var AT = Vi.ReactCurrentOwner,
  gn = !1;
function on(n, e, t, i) {
  e.child = n === null ? Dx(e, null, t, i) : po(e, n.child, t, i);
}
function Kg(n, e, t, i, r) {
  t = t.render;
  var o = e.ref;
  return (
    no(e, r),
    (i = Bp(n, e, t, i, o, r)),
    (t = zp()),
    n !== null && !gn
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Hi(n, e, r))
      : (_t && t && Mp(e), (e.flags |= 1), on(n, e, i, r), e.child)
  );
}
function qg(n, e, t, i, r) {
  if (n === null) {
    var o = t.type;
    return typeof o == "function" &&
      !Kp(o) &&
      o.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = o), tb(n, e, o, i, r))
      : ((n = Uc(t.type, null, i, e, e.mode, r)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((o = n.child), !(n.lanes & r))) {
    var p = o.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : Ya), t(p, i) && n.ref === e.ref)
    )
      return Hi(n, e, r);
  }
  return (
    (e.flags |= 1),
    (n = mr(o, i)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function tb(n, e, t, i, r) {
  if (n !== null) {
    var o = n.memoizedProps;
    if (Ya(o, i) && n.ref === e.ref)
      if (((gn = !1), (e.pendingProps = i = o), (n.lanes & r) !== 0))
        n.flags & 131072 && (gn = !0);
      else return (e.lanes = n.lanes), Hi(n, e, r);
  }
  return Td(n, e, t, i, r);
}
function nb(n, e, t) {
  var i = e.pendingProps,
    r = i.children,
    o = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        pt(Xs, Mn),
        (Mn |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = o !== null ? o.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          pt(Xs, Mn),
          (Mn |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = o !== null ? o.baseLanes : t),
        pt(Xs, Mn),
        (Mn |= i);
    }
  else
    o !== null ? ((i = o.baseLanes | t), (e.memoizedState = null)) : (i = t),
      pt(Xs, Mn),
      (Mn |= i);
  return on(n, e, r, t), e.child;
}
function ib(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Td(n, e, t, i, r) {
  var o = _n(t) ? Qr : Qt.current;
  return (
    (o = ho(e, o)),
    no(e, r),
    (t = Bp(n, e, t, i, o, r)),
    (i = zp()),
    n !== null && !gn
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Hi(n, e, r))
      : (_t && i && Mp(e), (e.flags |= 1), on(n, e, t, r), e.child)
  );
}
function Zg(n, e, t, i, r) {
  if (_n(t)) {
    var o = !0;
    su(e);
  } else o = !1;
  if ((no(e, r), e.stateNode === null))
    Nc(n, e), Ox(e, t, i), Sd(e, t, i, r), (i = !0);
  else if (n === null) {
    var p = e.stateNode,
      a = e.memoizedProps;
    p.props = a;
    var s = p.context,
      u = t.contextType;
    typeof u == "object" && u !== null
      ? (u = Yn(u))
      : ((u = _n(t) ? Qr : Qt.current), (u = ho(e, u)));
    var d = t.getDerivedStateFromProps,
      l =
        typeof d == "function" ||
        typeof p.getSnapshotBeforeUpdate == "function";
    l ||
      (typeof p.UNSAFE_componentWillReceiveProps != "function" &&
        typeof p.componentWillReceiveProps != "function") ||
      ((a !== i || s !== u) && Hg(e, p, i, u)),
      (Qi = !1);
    var c = e.memoizedState;
    (p.state = c),
      uu(e, i, p, r),
      (s = e.memoizedState),
      a !== i || c !== s || yn.current || Qi
        ? (typeof d == "function" && (bd(e, t, d, i), (s = e.memoizedState)),
          (a = Qi || jg(e, t, a, i, c, s, u))
            ? (l ||
                (typeof p.UNSAFE_componentWillMount != "function" &&
                  typeof p.componentWillMount != "function") ||
                (typeof p.componentWillMount == "function" &&
                  p.componentWillMount(),
                typeof p.UNSAFE_componentWillMount == "function" &&
                  p.UNSAFE_componentWillMount()),
              typeof p.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof p.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = s)),
          (p.props = i),
          (p.state = s),
          (p.context = u),
          (i = a))
        : (typeof p.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (p = e.stateNode),
      Ax(n, e),
      (a = e.memoizedProps),
      (u = e.type === e.elementType ? a : ti(e.type, a)),
      (p.props = u),
      (l = e.pendingProps),
      (c = p.context),
      (s = t.contextType),
      typeof s == "object" && s !== null
        ? (s = Yn(s))
        : ((s = _n(t) ? Qr : Qt.current), (s = ho(e, s)));
    var h = t.getDerivedStateFromProps;
    (d =
      typeof h == "function" ||
      typeof p.getSnapshotBeforeUpdate == "function") ||
      (typeof p.UNSAFE_componentWillReceiveProps != "function" &&
        typeof p.componentWillReceiveProps != "function") ||
      ((a !== l || c !== s) && Hg(e, p, i, s)),
      (Qi = !1),
      (c = e.memoizedState),
      (p.state = c),
      uu(e, i, p, r);
    var m = e.memoizedState;
    a !== l || c !== m || yn.current || Qi
      ? (typeof h == "function" && (bd(e, t, h, i), (m = e.memoizedState)),
        (u = Qi || jg(e, t, u, i, c, m, s) || !1)
          ? (d ||
              (typeof p.UNSAFE_componentWillUpdate != "function" &&
                typeof p.componentWillUpdate != "function") ||
              (typeof p.componentWillUpdate == "function" &&
                p.componentWillUpdate(i, m, s),
              typeof p.UNSAFE_componentWillUpdate == "function" &&
                p.UNSAFE_componentWillUpdate(i, m, s)),
            typeof p.componentDidUpdate == "function" && (e.flags |= 4),
            typeof p.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof p.componentDidUpdate != "function" ||
              (a === n.memoizedProps && c === n.memoizedState) ||
              (e.flags |= 4),
            typeof p.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && c === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = m)),
        (p.props = i),
        (p.state = m),
        (p.context = s),
        (i = u))
      : (typeof p.componentDidUpdate != "function" ||
          (a === n.memoizedProps && c === n.memoizedState) ||
          (e.flags |= 4),
        typeof p.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && c === n.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return Cd(n, e, t, i, o, r);
}
function Cd(n, e, t, i, r, o) {
  ib(n, e);
  var p = (e.flags & 128) !== 0;
  if (!i && !p) return r && Fg(e, t, !1), Hi(n, e, o);
  (i = e.stateNode), (AT.current = e);
  var a =
    p && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    n !== null && p
      ? ((e.child = po(e, n.child, null, o)), (e.child = po(e, null, a, o)))
      : on(n, e, a, o),
    (e.memoizedState = i.state),
    r && Fg(e, t, !0),
    e.child
  );
}
function rb(n) {
  var e = n.stateNode;
  e.pendingContext
    ? kg(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && kg(n, e.context, !1),
    Ip(n, e.containerInfo);
}
function Jg(n, e, t, i, r) {
  return fo(), Ap(r), (e.flags |= 256), on(n, e, t, i), e.child;
}
var Md = { dehydrated: null, treeContext: null, retryLane: 0 };
function Ed(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function sb(n, e, t) {
  var i = e.pendingProps,
    r = xt.current,
    o = !1,
    p = (e.flags & 128) !== 0,
    a;
  if (
    ((a = p) ||
      (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((o = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (r |= 1),
    pt(xt, r & 1),
    n === null)
  )
    return (
      _d(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((p = i.children),
          (n = i.fallback),
          o
            ? ((i = e.mode),
              (o = e.child),
              (p = { mode: "hidden", children: p }),
              !(i & 1) && o !== null
                ? ((o.childLanes = 0), (o.pendingProps = p))
                : (o = Bu(p, i, 0, null)),
              (n = Xr(n, i, t, null)),
              (o.return = e),
              (n.return = e),
              (o.sibling = n),
              (e.child = o),
              (e.child.memoizedState = Ed(t)),
              (e.memoizedState = Md),
              n)
            : Hp(e, p))
    );
  if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return PT(n, e, p, i, a, r, t);
  if (o) {
    (o = i.fallback), (p = e.mode), (r = n.child), (a = r.sibling);
    var s = { mode: "hidden", children: i.children };
    return (
      !(p & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = s),
          (e.deletions = null))
        : ((i = mr(r, s)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (o = mr(a, o)) : ((o = Xr(o, p, t, null)), (o.flags |= 2)),
      (o.return = e),
      (i.return = e),
      (i.sibling = o),
      (e.child = i),
      (i = o),
      (o = e.child),
      (p = n.child.memoizedState),
      (p =
        p === null
          ? Ed(t)
          : {
              baseLanes: p.baseLanes | t,
              cachePool: null,
              transitions: p.transitions,
            }),
      (o.memoizedState = p),
      (o.childLanes = n.childLanes & ~t),
      (e.memoizedState = Md),
      i
    );
  }
  return (
    (o = n.child),
    (n = o.sibling),
    (i = mr(o, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = t),
    (i.return = e),
    (i.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function Hp(n, e) {
  return (
    (e = Bu({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function ql(n, e, t, i) {
  return (
    i !== null && Ap(i),
    po(e, n.child, null, t),
    (n = Hp(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function PT(n, e, t, i, r, o, p) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (i = zh(Error(be(422)))), ql(n, e, p, i))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((o = i.fallback),
        (r = e.mode),
        (i = Bu({ mode: "visible", children: i.children }, r, 0, null)),
        (o = Xr(o, r, p, null)),
        (o.flags |= 2),
        (i.return = e),
        (o.return = e),
        (i.sibling = o),
        (e.child = i),
        e.mode & 1 && po(e, n.child, null, p),
        (e.child.memoizedState = Ed(p)),
        (e.memoizedState = Md),
        o);
  if (!(e.mode & 1)) return ql(n, e, p, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a), (o = Error(be(419))), (i = zh(o, i, void 0)), ql(n, e, p, i)
    );
  }
  if (((a = (p & n.childLanes) !== 0), gn || a)) {
    if (((i = Ut), i !== null)) {
      switch (p & -p) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | p) ? 0 : r),
        r !== 0 &&
          r !== o.retryLane &&
          ((o.retryLane = r), ji(n, r), si(i, n, r, -1));
    }
    return Yp(), (i = zh(Error(be(421)))), ql(n, e, p, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = HT.bind(null, n)),
      (r._reactRetry = e),
      null)
    : ((n = o.treeContext),
      (En = hr(r.nextSibling)),
      (On = e),
      (_t = !0),
      (ii = null),
      n !== null &&
        ((jn[Hn++] = Ii),
        (jn[Hn++] = ki),
        (jn[Hn++] = es),
        (Ii = n.id),
        (ki = n.overflow),
        (es = e)),
      (e = Hp(e, i.children)),
      (e.flags |= 4096),
      e);
}
function Qg(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  i !== null && (i.lanes |= e), xd(n.return, e, t);
}
function Uh(n, e, t, i, r) {
  var o = n.memoizedState;
  o === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r,
      })
    : ((o.isBackwards = e),
      (o.rendering = null),
      (o.renderingStartTime = 0),
      (o.last = i),
      (o.tail = t),
      (o.tailMode = r));
}
function ob(n, e, t) {
  var i = e.pendingProps,
    r = i.revealOrder,
    o = i.tail;
  if ((on(n, e, i.children, t), (i = xt.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && Qg(n, t, e);
        else if (n.tag === 19) Qg(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    i &= 1;
  }
  if ((pt(xt, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          (n = t.alternate),
            n !== null && hu(n) === null && (r = t),
            (t = t.sibling);
        (t = r),
          t === null
            ? ((r = e.child), (e.child = null))
            : ((r = t.sibling), (t.sibling = null)),
          Uh(e, !1, r, t, o);
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (((n = r.alternate), n !== null && hu(n) === null)) {
            e.child = r;
            break;
          }
          (n = r.sibling), (r.sibling = t), (t = r), (r = n);
        }
        Uh(e, !0, t, null, o);
        break;
      case "together":
        Uh(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function Nc(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Hi(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (ns |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(be(153));
  if (e.child !== null) {
    for (
      n = e.child, t = mr(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = mr(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function OT(n, e, t) {
  switch (e.tag) {
    case 3:
      rb(e), fo();
      break;
    case 5:
      Rx(e);
      break;
    case 1:
      _n(e.type) && su(e);
      break;
    case 4:
      Ip(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      pt(lu, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (pt(xt, xt.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? sb(n, e, t)
          : (pt(xt, xt.current & 1),
            (n = Hi(n, e, t)),
            n !== null ? n.sibling : null);
      pt(xt, xt.current & 1);
      break;
    case 19:
      if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (i) return ob(n, e, t);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        pt(xt, xt.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), nb(n, e, t);
  }
  return Hi(n, e, t);
}
var ab, Ad, lb, cb;
ab = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
Ad = function () {};
lb = function (n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    (n = e.stateNode), Vr(_i.current);
    var o = null;
    switch (t) {
      case "input":
        (r = qf(n, r)), (i = qf(n, i)), (o = []);
        break;
      case "select":
        (r = wt({}, r, { value: void 0 })),
          (i = wt({}, i, { value: void 0 })),
          (o = []);
        break;
      case "textarea":
        (r = Qf(n, r)), (i = Qf(n, i)), (o = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (n.onclick = iu);
    }
    td(t, i);
    var p;
    t = null;
    for (u in r)
      if (!i.hasOwnProperty(u) && r.hasOwnProperty(u) && r[u] != null)
        if (u === "style") {
          var a = r[u];
          for (p in a) a.hasOwnProperty(p) && (t || (t = {}), (t[p] = ""));
        } else
          u !== "dangerouslySetInnerHTML" &&
            u !== "children" &&
            u !== "suppressContentEditableWarning" &&
            u !== "suppressHydrationWarning" &&
            u !== "autoFocus" &&
            (ja.hasOwnProperty(u)
              ? o || (o = [])
              : (o = o || []).push(u, null));
    for (u in i) {
      var s = i[u];
      if (
        ((a = r != null ? r[u] : void 0),
        i.hasOwnProperty(u) && s !== a && (s != null || a != null))
      )
        if (u === "style")
          if (a) {
            for (p in a)
              !a.hasOwnProperty(p) ||
                (s && s.hasOwnProperty(p)) ||
                (t || (t = {}), (t[p] = ""));
            for (p in s)
              s.hasOwnProperty(p) &&
                a[p] !== s[p] &&
                (t || (t = {}), (t[p] = s[p]));
          } else t || (o || (o = []), o.push(u, t)), (t = s);
        else
          u === "dangerouslySetInnerHTML"
            ? ((s = s ? s.__html : void 0),
              (a = a ? a.__html : void 0),
              s != null && a !== s && (o = o || []).push(u, s))
            : u === "children"
            ? (typeof s != "string" && typeof s != "number") ||
              (o = o || []).push(u, "" + s)
            : u !== "suppressContentEditableWarning" &&
              u !== "suppressHydrationWarning" &&
              (ja.hasOwnProperty(u)
                ? (s != null && u === "onScroll" && mt("scroll", n),
                  o || a === s || (o = []))
                : (o = o || []).push(u, s));
    }
    t && (o = o || []).push("style", t);
    var u = o;
    (e.updateQueue = u) && (e.flags |= 4);
  }
};
cb = function (n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function na(n, e) {
  if (!_t)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          t.alternate !== null && (i = t), (t = t.sibling);
        i === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (i.sibling = null);
    }
}
function Kt(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = n),
        (r = r.sibling);
  else
    for (r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = n),
        (r = r.sibling);
  return (n.subtreeFlags |= i), (n.childLanes = t), e;
}
function LT(n, e, t) {
  var i = e.pendingProps;
  switch ((Ep(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Kt(e), null;
    case 1:
      return _n(e.type) && ru(), Kt(e), null;
    case 3:
      return (
        (i = e.stateNode),
        mo(),
        vt(yn),
        vt(Qt),
        Fp(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (n === null || n.child === null) &&
          (Yl(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), ii !== null && (Fd(ii), (ii = null)))),
        Ad(n, e),
        Kt(e),
        null
      );
    case 5:
      kp(e);
      var r = Vr(Qa.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        lb(n, e, t, i, r),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(be(166));
          return Kt(e), null;
        }
        if (((n = Vr(_i.current)), Yl(e))) {
          (i = e.stateNode), (t = e.type);
          var o = e.memoizedProps;
          switch (((i[vi] = e), (i[Za] = o), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              mt("cancel", i), mt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              mt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < Ta.length; r++) mt(Ta[r], i);
              break;
            case "source":
              mt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              mt("error", i), mt("load", i);
              break;
            case "details":
              mt("toggle", i);
              break;
            case "input":
              lg(i, o), mt("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!o.multiple }),
                mt("invalid", i);
              break;
            case "textarea":
              ug(i, o), mt("invalid", i);
          }
          td(t, o), (r = null);
          for (var p in o)
            if (o.hasOwnProperty(p)) {
              var a = o[p];
              p === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (o.suppressHydrationWarning !== !0 &&
                      Xl(i.textContent, a, n),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (o.suppressHydrationWarning !== !0 &&
                      Xl(i.textContent, a, n),
                    (r = ["children", "" + a]))
                : ja.hasOwnProperty(p) &&
                  a != null &&
                  p === "onScroll" &&
                  mt("scroll", i);
            }
          switch (t) {
            case "input":
              zl(i), cg(i, o, !0);
              break;
            case "textarea":
              zl(i), hg(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof o.onClick == "function" && (i.onclick = iu);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (p = r.nodeType === 9 ? r : r.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = F_(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = p.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof i.is == "string"
                ? (n = p.createElement(t, { is: i.is }))
                : ((n = p.createElement(t)),
                  t === "select" &&
                    ((p = n),
                    i.multiple
                      ? (p.multiple = !0)
                      : i.size && (p.size = i.size)))
              : (n = p.createElementNS(n, t)),
            (n[vi] = e),
            (n[Za] = i),
            ab(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((p = nd(t, i)), t)) {
              case "dialog":
                mt("cancel", n), mt("close", n), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                mt("load", n), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < Ta.length; r++) mt(Ta[r], n);
                r = i;
                break;
              case "source":
                mt("error", n), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                mt("error", n), mt("load", n), (r = i);
                break;
              case "details":
                mt("toggle", n), (r = i);
                break;
              case "input":
                lg(n, i), (r = qf(n, i)), mt("invalid", n);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = wt({}, i, { value: void 0 })),
                  mt("invalid", n);
                break;
              case "textarea":
                ug(n, i), (r = Qf(n, i)), mt("invalid", n);
                break;
              default:
                r = i;
            }
            td(t, r), (a = r);
            for (o in a)
              if (a.hasOwnProperty(o)) {
                var s = a[o];
                o === "style"
                  ? z_(n, s)
                  : o === "dangerouslySetInnerHTML"
                  ? ((s = s ? s.__html : void 0), s != null && N_(n, s))
                  : o === "children"
                  ? typeof s == "string"
                    ? (t !== "textarea" || s !== "") && Ha(n, s)
                    : typeof s == "number" && Ha(n, "" + s)
                  : o !== "suppressContentEditableWarning" &&
                    o !== "suppressHydrationWarning" &&
                    o !== "autoFocus" &&
                    (ja.hasOwnProperty(o)
                      ? s != null && o === "onScroll" && mt("scroll", n)
                      : s != null && fp(n, o, s, p));
              }
            switch (t) {
              case "input":
                zl(n), cg(n, i, !1);
                break;
              case "textarea":
                zl(n), hg(n);
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + vr(i.value));
                break;
              case "select":
                (n.multiple = !!i.multiple),
                  (o = i.value),
                  o != null
                    ? Js(n, !!i.multiple, o, !1)
                    : i.defaultValue != null &&
                      Js(n, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = iu);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return Kt(e), null;
    case 6:
      if (n && e.stateNode != null) cb(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(be(166));
        if (((t = Vr(Qa.current)), Vr(_i.current), Yl(e))) {
          if (
            ((i = e.stateNode),
            (t = e.memoizedProps),
            (i[vi] = e),
            (o = i.nodeValue !== t) && ((n = On), n !== null))
          )
            switch (n.tag) {
              case 3:
                Xl(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  Xl(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          o && (e.flags |= 4);
        } else
          (i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
            (i[vi] = e),
            (e.stateNode = i);
      }
      return Kt(e), null;
    case 13:
      if (
        (vt(xt),
        (i = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if (_t && En !== null && e.mode & 1 && !(e.flags & 128))
          Mx(), fo(), (e.flags |= 98560), (o = !1);
        else if (((o = Yl(e)), i !== null && i.dehydrated !== null)) {
          if (n === null) {
            if (!o) throw Error(be(318));
            if (
              ((o = e.memoizedState),
              (o = o !== null ? o.dehydrated : null),
              !o)
            )
              throw Error(be(317));
            o[vi] = e;
          } else
            fo(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          Kt(e), (o = !1);
        } else ii !== null && (Fd(ii), (ii = null)), (o = !0);
        if (!o) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((i = i !== null),
          i !== (n !== null && n.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || xt.current & 1 ? Rt === 0 && (Rt = 3) : Yp())),
          e.updateQueue !== null && (e.flags |= 4),
          Kt(e),
          null);
    case 4:
      return (
        mo(), Ad(n, e), n === null && Ka(e.stateNode.containerInfo), Kt(e), null
      );
    case 10:
      return Lp(e.type._context), Kt(e), null;
    case 17:
      return _n(e.type) && ru(), Kt(e), null;
    case 19:
      if ((vt(xt), (o = e.memoizedState), o === null)) return Kt(e), null;
      if (((i = (e.flags & 128) !== 0), (p = o.rendering), p === null))
        if (i) na(o, !1);
        else {
          if (Rt !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((p = hu(n)), p !== null)) {
                for (
                  e.flags |= 128,
                    na(o, !1),
                    i = p.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = t,
                    t = e.child;
                  t !== null;

                )
                  (o = t),
                    (n = i),
                    (o.flags &= 14680066),
                    (p = o.alternate),
                    p === null
                      ? ((o.childLanes = 0),
                        (o.lanes = n),
                        (o.child = null),
                        (o.subtreeFlags = 0),
                        (o.memoizedProps = null),
                        (o.memoizedState = null),
                        (o.updateQueue = null),
                        (o.dependencies = null),
                        (o.stateNode = null))
                      : ((o.childLanes = p.childLanes),
                        (o.lanes = p.lanes),
                        (o.child = p.child),
                        (o.subtreeFlags = 0),
                        (o.deletions = null),
                        (o.memoizedProps = p.memoizedProps),
                        (o.memoizedState = p.memoizedState),
                        (o.updateQueue = p.updateQueue),
                        (o.type = p.type),
                        (n = p.dependencies),
                        (o.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return pt(xt, (xt.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          o.tail !== null &&
            Mt() > vo &&
            ((e.flags |= 128), (i = !0), na(o, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((n = hu(p)), n !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              na(o, !0),
              o.tail === null && o.tailMode === "hidden" && !p.alternate && !_t)
            )
              return Kt(e), null;
          } else
            2 * Mt() - o.renderingStartTime > vo &&
              t !== 1073741824 &&
              ((e.flags |= 128), (i = !0), na(o, !1), (e.lanes = 4194304));
        o.isBackwards
          ? ((p.sibling = e.child), (e.child = p))
          : ((t = o.last),
            t !== null ? (t.sibling = p) : (e.child = p),
            (o.last = p));
      }
      return o.tail !== null
        ? ((e = o.tail),
          (o.rendering = e),
          (o.tail = e.sibling),
          (o.renderingStartTime = Mt()),
          (e.sibling = null),
          (t = xt.current),
          pt(xt, i ? (t & 1) | 2 : t & 1),
          e)
        : (Kt(e), null);
    case 22:
    case 23:
      return (
        Xp(),
        (i = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? Mn & 1073741824 && (Kt(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : Kt(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(be(156, e.tag));
}
function DT(n, e) {
  switch ((Ep(e), e.tag)) {
    case 1:
      return (
        _n(e.type) && ru(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        mo(),
        vt(yn),
        vt(Qt),
        Fp(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return kp(e), null;
    case 13:
      if (
        (vt(xt), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(be(340));
        fo();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return vt(xt), null;
    case 4:
      return mo(), null;
    case 10:
      return Lp(e.type._context), null;
    case 22:
    case 23:
      return Xp(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Zl = !1,
  Zt = !1,
  RT = typeof WeakSet == "function" ? WeakSet : Set,
  Oe = null;
function $s(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        Tt(n, e, i);
      }
    else t.current = null;
}
function Pd(n, e, t) {
  try {
    t();
  } catch (i) {
    Tt(n, e, i);
  }
}
var ev = !1;
function IT(n, e) {
  if (((fd = eu), (n = dx()), Cp(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset,
            o = i.focusNode;
          i = i.focusOffset;
          try {
            t.nodeType, o.nodeType;
          } catch {
            t = null;
            break e;
          }
          var p = 0,
            a = -1,
            s = -1,
            u = 0,
            d = 0,
            l = n,
            c = null;
          t: for (;;) {
            for (
              var h;
              l !== t || (r !== 0 && l.nodeType !== 3) || (a = p + r),
                l !== o || (i !== 0 && l.nodeType !== 3) || (s = p + i),
                l.nodeType === 3 && (p += l.nodeValue.length),
                (h = l.firstChild) !== null;

            )
              (c = l), (l = h);
            for (;;) {
              if (l === n) break t;
              if (
                (c === t && ++u === r && (a = p),
                c === o && ++d === i && (s = p),
                (h = l.nextSibling) !== null)
              )
                break;
              (l = c), (c = l.parentNode);
            }
            l = h;
          }
          t = a === -1 || s === -1 ? null : { start: a, end: s };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    dd = { focusedElem: n, selectionRange: t }, eu = !1, Oe = e;
    Oe !== null;

  )
    if (((e = Oe), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (Oe = n);
    else
      for (; Oe !== null; ) {
        e = Oe;
        try {
          var m = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (m !== null) {
                  var g = m.memoizedProps,
                    f = m.memoizedState,
                    v = e.stateNode,
                    y = v.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? g : ti(e.type, g),
                      f
                    );
                  v.__reactInternalSnapshotBeforeUpdate = y;
                }
                break;
              case 3:
                var _ = e.stateNode.containerInfo;
                _.nodeType === 1
                  ? (_.textContent = "")
                  : _.nodeType === 9 &&
                    _.documentElement &&
                    _.removeChild(_.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(be(163));
            }
        } catch (x) {
          Tt(e, e.return, x);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (Oe = n);
          break;
        }
        Oe = e.return;
      }
  return (m = ev), (ev = !1), m;
}
function Ra(n, e, t) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & n) === n) {
        var o = r.destroy;
        (r.destroy = void 0), o !== void 0 && Pd(e, t, o);
      }
      r = r.next;
    } while (r !== i);
  }
}
function Fu(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function Od(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function ub(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), ub(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[vi], delete e[Za], delete e[gd], delete e[gT], delete e[vT])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function hb(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function tv(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || hb(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function Ld(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = iu));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Ld(n, e, t), n = n.sibling; n !== null; ) Ld(n, e, t), (n = n.sibling);
}
function Dd(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Dd(n, e, t), n = n.sibling; n !== null; ) Dd(n, e, t), (n = n.sibling);
}
var Vt = null,
  ni = !1;
function Gi(n, e, t) {
  for (t = t.child; t !== null; ) fb(n, e, t), (t = t.sibling);
}
function fb(n, e, t) {
  if (yi && typeof yi.onCommitFiberUnmount == "function")
    try {
      yi.onCommitFiberUnmount(Au, t);
    } catch {}
  switch (t.tag) {
    case 5:
      Zt || $s(t, e);
    case 6:
      var i = Vt,
        r = ni;
      (Vt = null),
        Gi(n, e, t),
        (Vt = i),
        (ni = r),
        Vt !== null &&
          (ni
            ? ((n = Vt),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : Vt.removeChild(t.stateNode));
      break;
    case 18:
      Vt !== null &&
        (ni
          ? ((n = Vt),
            (t = t.stateNode),
            n.nodeType === 8
              ? Rh(n.parentNode, t)
              : n.nodeType === 1 && Rh(n, t),
            $a(n))
          : Rh(Vt, t.stateNode));
      break;
    case 4:
      (i = Vt),
        (r = ni),
        (Vt = t.stateNode.containerInfo),
        (ni = !0),
        Gi(n, e, t),
        (Vt = i),
        (ni = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Zt &&
        ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var o = r,
            p = o.destroy;
          (o = o.tag),
            p !== void 0 && (o & 2 || o & 4) && Pd(t, e, p),
            (r = r.next);
        } while (r !== i);
      }
      Gi(n, e, t);
      break;
    case 1:
      if (
        !Zt &&
        ($s(t, e),
        (i = t.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = t.memoizedProps),
            (i.state = t.memoizedState),
            i.componentWillUnmount();
        } catch (a) {
          Tt(t, e, a);
        }
      Gi(n, e, t);
      break;
    case 21:
      Gi(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((Zt = (i = Zt) || t.memoizedState !== null), Gi(n, e, t), (Zt = i))
        : Gi(n, e, t);
      break;
    default:
      Gi(n, e, t);
  }
}
function nv(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new RT()),
      e.forEach(function (i) {
        var r = VT.bind(null, n, i);
        t.has(i) || (t.add(i), i.then(r, r));
      });
  }
}
function Zn(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var o = n,
          p = e,
          a = p;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Vt = a.stateNode), (ni = !1);
              break e;
            case 3:
              (Vt = a.stateNode.containerInfo), (ni = !0);
              break e;
            case 4:
              (Vt = a.stateNode.containerInfo), (ni = !0);
              break e;
          }
          a = a.return;
        }
        if (Vt === null) throw Error(be(160));
        fb(o, p, r), (Vt = null), (ni = !1);
        var s = r.alternate;
        s !== null && (s.return = null), (r.return = null);
      } catch (u) {
        Tt(r, e, u);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) db(e, n), (e = e.sibling);
}
function db(n, e) {
  var t = n.alternate,
    i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Zn(e, n), ui(n), i & 4)) {
        try {
          Ra(3, n, n.return), Fu(3, n);
        } catch (g) {
          Tt(n, n.return, g);
        }
        try {
          Ra(5, n, n.return);
        } catch (g) {
          Tt(n, n.return, g);
        }
      }
      break;
    case 1:
      Zn(e, n), ui(n), i & 512 && t !== null && $s(t, t.return);
      break;
    case 5:
      if (
        (Zn(e, n),
        ui(n),
        i & 512 && t !== null && $s(t, t.return),
        n.flags & 32)
      ) {
        var r = n.stateNode;
        try {
          Ha(r, "");
        } catch (g) {
          Tt(n, n.return, g);
        }
      }
      if (i & 4 && ((r = n.stateNode), r != null)) {
        var o = n.memoizedProps,
          p = t !== null ? t.memoizedProps : o,
          a = n.type,
          s = n.updateQueue;
        if (((n.updateQueue = null), s !== null))
          try {
            a === "input" && o.type === "radio" && o.name != null && I_(r, o),
              nd(a, p);
            var u = nd(a, o);
            for (p = 0; p < s.length; p += 2) {
              var d = s[p],
                l = s[p + 1];
              d === "style"
                ? z_(r, l)
                : d === "dangerouslySetInnerHTML"
                ? N_(r, l)
                : d === "children"
                ? Ha(r, l)
                : fp(r, d, l, u);
            }
            switch (a) {
              case "input":
                Zf(r, o);
                break;
              case "textarea":
                k_(r, o);
                break;
              case "select":
                var c = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!o.multiple;
                var h = o.value;
                h != null
                  ? Js(r, !!o.multiple, h, !1)
                  : c !== !!o.multiple &&
                    (o.defaultValue != null
                      ? Js(r, !!o.multiple, o.defaultValue, !0)
                      : Js(r, !!o.multiple, o.multiple ? [] : "", !1));
            }
            r[Za] = o;
          } catch (g) {
            Tt(n, n.return, g);
          }
      }
      break;
    case 6:
      if ((Zn(e, n), ui(n), i & 4)) {
        if (n.stateNode === null) throw Error(be(162));
        (r = n.stateNode), (o = n.memoizedProps);
        try {
          r.nodeValue = o;
        } catch (g) {
          Tt(n, n.return, g);
        }
      }
      break;
    case 3:
      if (
        (Zn(e, n), ui(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          $a(e.containerInfo);
        } catch (g) {
          Tt(n, n.return, g);
        }
      break;
    case 4:
      Zn(e, n), ui(n);
      break;
    case 13:
      Zn(e, n),
        ui(n),
        (r = n.child),
        r.flags & 8192 &&
          ((o = r.memoizedState !== null),
          (r.stateNode.isHidden = o),
          !o ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (Gp = Mt())),
        i & 4 && nv(n);
      break;
    case 22:
      if (
        ((d = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((Zt = (u = Zt) || d), Zn(e, n), (Zt = u)) : Zn(e, n),
        ui(n),
        i & 8192)
      ) {
        if (
          ((u = n.memoizedState !== null),
          (n.stateNode.isHidden = u) && !d && n.mode & 1)
        )
          for (Oe = n, d = n.child; d !== null; ) {
            for (l = Oe = d; Oe !== null; ) {
              switch (((c = Oe), (h = c.child), c.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Ra(4, c, c.return);
                  break;
                case 1:
                  $s(c, c.return);
                  var m = c.stateNode;
                  if (typeof m.componentWillUnmount == "function") {
                    (i = c), (t = c.return);
                    try {
                      (e = i),
                        (m.props = e.memoizedProps),
                        (m.state = e.memoizedState),
                        m.componentWillUnmount();
                    } catch (g) {
                      Tt(i, t, g);
                    }
                  }
                  break;
                case 5:
                  $s(c, c.return);
                  break;
                case 22:
                  if (c.memoizedState !== null) {
                    rv(l);
                    continue;
                  }
              }
              h !== null ? ((h.return = c), (Oe = h)) : rv(l);
            }
            d = d.sibling;
          }
        e: for (d = null, l = n; ; ) {
          if (l.tag === 5) {
            if (d === null) {
              d = l;
              try {
                (r = l.stateNode),
                  u
                    ? ((o = r.style),
                      typeof o.setProperty == "function"
                        ? o.setProperty("display", "none", "important")
                        : (o.display = "none"))
                    : ((a = l.stateNode),
                      (s = l.memoizedProps.style),
                      (p =
                        s != null && s.hasOwnProperty("display")
                          ? s.display
                          : null),
                      (a.style.display = B_("display", p)));
              } catch (g) {
                Tt(n, n.return, g);
              }
            }
          } else if (l.tag === 6) {
            if (d === null)
              try {
                l.stateNode.nodeValue = u ? "" : l.memoizedProps;
              } catch (g) {
                Tt(n, n.return, g);
              }
          } else if (
            ((l.tag !== 22 && l.tag !== 23) ||
              l.memoizedState === null ||
              l === n) &&
            l.child !== null
          ) {
            (l.child.return = l), (l = l.child);
            continue;
          }
          if (l === n) break e;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === n) break e;
            d === l && (d = null), (l = l.return);
          }
          d === l && (d = null), (l.sibling.return = l.return), (l = l.sibling);
        }
      }
      break;
    case 19:
      Zn(e, n), ui(n), i & 4 && nv(n);
      break;
    case 21:
      break;
    default:
      Zn(e, n), ui(n);
  }
}
function ui(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (hb(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(be(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (Ha(r, ""), (i.flags &= -33));
          var o = tv(n);
          Dd(n, o, r);
          break;
        case 3:
        case 4:
          var p = i.stateNode.containerInfo,
            a = tv(n);
          Ld(n, a, p);
          break;
        default:
          throw Error(be(161));
      }
    } catch (s) {
      Tt(n, n.return, s);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function kT(n, e, t) {
  (Oe = n), pb(n);
}
function pb(n, e, t) {
  for (var i = (n.mode & 1) !== 0; Oe !== null; ) {
    var r = Oe,
      o = r.child;
    if (r.tag === 22 && i) {
      var p = r.memoizedState !== null || Zl;
      if (!p) {
        var a = r.alternate,
          s = (a !== null && a.memoizedState !== null) || Zt;
        a = Zl;
        var u = Zt;
        if (((Zl = p), (Zt = s) && !u))
          for (Oe = r; Oe !== null; )
            (p = Oe),
              (s = p.child),
              p.tag === 22 && p.memoizedState !== null
                ? sv(r)
                : s !== null
                ? ((s.return = p), (Oe = s))
                : sv(r);
        for (; o !== null; ) (Oe = o), pb(o), (o = o.sibling);
        (Oe = r), (Zl = a), (Zt = u);
      }
      iv(n);
    } else
      r.subtreeFlags & 8772 && o !== null ? ((o.return = r), (Oe = o)) : iv(n);
  }
}
function iv(n) {
  for (; Oe !== null; ) {
    var e = Oe;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Zt || Fu(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !Zt)
                if (t === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : ti(e.type, t.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    t.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var o = e.updateQueue;
              o !== null && Ug(e, o, i);
              break;
            case 3:
              var p = e.updateQueue;
              if (p !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                Ug(e, p, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var s = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    s.autoFocus && t.focus();
                    break;
                  case "img":
                    s.src && (t.src = s.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var u = e.alternate;
                if (u !== null) {
                  var d = u.memoizedState;
                  if (d !== null) {
                    var l = d.dehydrated;
                    l !== null && $a(l);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(be(163));
          }
        Zt || (e.flags & 512 && Od(e));
      } catch (c) {
        Tt(e, e.return, c);
      }
    }
    if (e === n) {
      Oe = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (Oe = t);
      break;
    }
    Oe = e.return;
  }
}
function rv(n) {
  for (; Oe !== null; ) {
    var e = Oe;
    if (e === n) {
      Oe = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (Oe = t);
      break;
    }
    Oe = e.return;
  }
}
function sv(n) {
  for (; Oe !== null; ) {
    var e = Oe;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            Fu(4, e);
          } catch (s) {
            Tt(e, t, s);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (s) {
              Tt(e, r, s);
            }
          }
          var o = e.return;
          try {
            Od(e);
          } catch (s) {
            Tt(e, o, s);
          }
          break;
        case 5:
          var p = e.return;
          try {
            Od(e);
          } catch (s) {
            Tt(e, p, s);
          }
      }
    } catch (s) {
      Tt(e, e.return, s);
    }
    if (e === n) {
      Oe = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (Oe = a);
      break;
    }
    Oe = e.return;
  }
}
var FT = Math.ceil,
  pu = Vi.ReactCurrentDispatcher,
  Vp = Vi.ReactCurrentOwner,
  $n = Vi.ReactCurrentBatchConfig,
  nt = 0,
  Ut = null,
  Ot = null,
  Wt = 0,
  Mn = 0,
  Xs = Sr(0),
  Rt = 0,
  il = null,
  ns = 0,
  Nu = 0,
  Wp = 0,
  Ia = null,
  pn = null,
  Gp = 0,
  vo = 1 / 0,
  Li = null,
  mu = !1,
  Rd = null,
  dr = null,
  Jl = !1,
  sr = null,
  gu = 0,
  ka = 0,
  Id = null,
  Bc = -1,
  zc = 0;
function un() {
  return nt & 6 ? Mt() : Bc !== -1 ? Bc : (Bc = Mt());
}
function pr(n) {
  return n.mode & 1
    ? nt & 2 && Wt !== 0
      ? Wt & -Wt
      : _T.transition !== null
      ? (zc === 0 && (zc = Z_()), zc)
      : ((n = lt),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : rx(n.type))),
        n)
    : 1;
}
function si(n, e, t, i) {
  if (50 < ka) throw ((ka = 0), (Id = null), Error(be(185)));
  vl(n, t, i),
    (!(nt & 2) || n !== Ut) &&
      (n === Ut && (!(nt & 2) && (Nu |= t), Rt === 4 && ir(n, Wt)),
      xn(n, i),
      t === 1 && nt === 0 && !(e.mode & 1) && ((vo = Mt() + 500), Ru && wr()));
}
function xn(n, e) {
  var t = n.callbackNode;
  _w(n, e);
  var i = Qc(n, n === Ut ? Wt : 0);
  if (i === 0)
    t !== null && pg(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = i & -i), n.callbackPriority !== e)) {
    if ((t != null && pg(t), e === 1))
      n.tag === 0 ? yT(ov.bind(null, n)) : wx(ov.bind(null, n)),
        pT(function () {
          !(nt & 6) && wr();
        }),
        (t = null);
    else {
      switch (J_(i)) {
        case 1:
          t = vp;
          break;
        case 4:
          t = K_;
          break;
        case 16:
          t = Jc;
          break;
        case 536870912:
          t = q_;
          break;
        default:
          t = Jc;
      }
      t = Sb(t, mb.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function mb(n, e) {
  if (((Bc = -1), (zc = 0), nt & 6)) throw Error(be(327));
  var t = n.callbackNode;
  if (io() && n.callbackNode !== t) return null;
  var i = Qc(n, n === Ut ? Wt : 0);
  if (i === 0) return null;
  if (i & 30 || i & n.expiredLanes || e) e = vu(n, i);
  else {
    e = i;
    var r = nt;
    nt |= 2;
    var o = vb();
    (Ut !== n || Wt !== e) && ((Li = null), (vo = Mt() + 500), $r(n, e));
    do
      try {
        zT();
        break;
      } catch (a) {
        gb(n, a);
      }
    while (1);
    Op(),
      (pu.current = o),
      (nt = r),
      Ot !== null ? (e = 0) : ((Ut = null), (Wt = 0), (e = Rt));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = ad(n)), r !== 0 && ((i = r), (e = kd(n, r)))), e === 1)
    )
      throw ((t = il), $r(n, 0), ir(n, i), xn(n, Mt()), t);
    if (e === 6) ir(n, i);
    else {
      if (
        ((r = n.current.alternate),
        !(i & 30) &&
          !NT(r) &&
          ((e = vu(n, i)),
          e === 2 && ((o = ad(n)), o !== 0 && ((i = o), (e = kd(n, o)))),
          e === 1))
      )
        throw ((t = il), $r(n, 0), ir(n, i), xn(n, Mt()), t);
      switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(be(345));
        case 2:
          kr(n, pn, Li);
          break;
        case 3:
          if (
            (ir(n, i), (i & 130023424) === i && ((e = Gp + 500 - Mt()), 10 < e))
          ) {
            if (Qc(n, 0) !== 0) break;
            if (((r = n.suspendedLanes), (r & i) !== i)) {
              un(), (n.pingedLanes |= n.suspendedLanes & r);
              break;
            }
            n.timeoutHandle = md(kr.bind(null, n, pn, Li), e);
            break;
          }
          kr(n, pn, Li);
          break;
        case 4:
          if ((ir(n, i), (i & 4194240) === i)) break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var p = 31 - ri(i);
            (o = 1 << p), (p = e[p]), p > r && (r = p), (i &= ~o);
          }
          if (
            ((i = r),
            (i = Mt() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * FT(i / 1960)) - i),
            10 < i)
          ) {
            n.timeoutHandle = md(kr.bind(null, n, pn, Li), i);
            break;
          }
          kr(n, pn, Li);
          break;
        case 5:
          kr(n, pn, Li);
          break;
        default:
          throw Error(be(329));
      }
    }
  }
  return xn(n, Mt()), n.callbackNode === t ? mb.bind(null, n) : null;
}
function kd(n, e) {
  var t = Ia;
  return (
    n.current.memoizedState.isDehydrated && ($r(n, e).flags |= 256),
    (n = vu(n, e)),
    n !== 2 && ((e = pn), (pn = t), e !== null && Fd(e)),
    n
  );
}
function Fd(n) {
  pn === null ? (pn = n) : pn.push.apply(pn, n);
}
function NT(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            o = r.getSnapshot;
          r = r.value;
          try {
            if (!ai(o(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function ir(n, e) {
  for (
    e &= ~Wp,
      e &= ~Nu,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - ri(e),
      i = 1 << t;
    (n[t] = -1), (e &= ~i);
  }
}
function ov(n) {
  if (nt & 6) throw Error(be(327));
  io();
  var e = Qc(n, 0);
  if (!(e & 1)) return xn(n, Mt()), null;
  var t = vu(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = ad(n);
    i !== 0 && ((e = i), (t = kd(n, i)));
  }
  if (t === 1) throw ((t = il), $r(n, 0), ir(n, e), xn(n, Mt()), t);
  if (t === 6) throw Error(be(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    kr(n, pn, Li),
    xn(n, Mt()),
    null
  );
}
function $p(n, e) {
  var t = nt;
  nt |= 1;
  try {
    return n(e);
  } finally {
    (nt = t), nt === 0 && ((vo = Mt() + 500), Ru && wr());
  }
}
function is(n) {
  sr !== null && sr.tag === 0 && !(nt & 6) && io();
  var e = nt;
  nt |= 1;
  var t = $n.transition,
    i = lt;
  try {
    if ((($n.transition = null), (lt = 1), n)) return n();
  } finally {
    (lt = i), ($n.transition = t), (nt = e), !(nt & 6) && wr();
  }
}
function Xp() {
  (Mn = Xs.current), vt(Xs);
}
function $r(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), dT(t)), Ot !== null))
    for (t = Ot.return; t !== null; ) {
      var i = t;
      switch ((Ep(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && ru();
          break;
        case 3:
          mo(), vt(yn), vt(Qt), Fp();
          break;
        case 5:
          kp(i);
          break;
        case 4:
          mo();
          break;
        case 13:
          vt(xt);
          break;
        case 19:
          vt(xt);
          break;
        case 10:
          Lp(i.type._context);
          break;
        case 22:
        case 23:
          Xp();
      }
      t = t.return;
    }
  if (
    ((Ut = n),
    (Ot = n = mr(n.current, null)),
    (Wt = Mn = e),
    (Rt = 0),
    (il = null),
    (Wp = Nu = ns = 0),
    (pn = Ia = null),
    Hr !== null)
  ) {
    for (e = 0; e < Hr.length; e++)
      if (((t = Hr[e]), (i = t.interleaved), i !== null)) {
        t.interleaved = null;
        var r = i.next,
          o = t.pending;
        if (o !== null) {
          var p = o.next;
          (o.next = r), (i.next = p);
        }
        t.pending = i;
      }
    Hr = null;
  }
  return n;
}
function gb(n, e) {
  do {
    var t = Ot;
    try {
      if ((Op(), (kc.current = du), fu)) {
        for (var i = bt.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        fu = !1;
      }
      if (
        ((ts = 0),
        (Bt = Dt = bt = null),
        (Da = !1),
        (el = 0),
        (Vp.current = null),
        t === null || t.return === null)
      ) {
        (Rt = 1), (il = e), (Ot = null);
        break;
      }
      e: {
        var o = n,
          p = t.return,
          a = t,
          s = e;
        if (
          ((e = Wt),
          (a.flags |= 32768),
          s !== null && typeof s == "object" && typeof s.then == "function")
        ) {
          var u = s,
            d = a,
            l = d.tag;
          if (!(d.mode & 1) && (l === 0 || l === 11 || l === 15)) {
            var c = d.alternate;
            c
              ? ((d.updateQueue = c.updateQueue),
                (d.memoizedState = c.memoizedState),
                (d.lanes = c.lanes))
              : ((d.updateQueue = null), (d.memoizedState = null));
          }
          var h = Xg(p);
          if (h !== null) {
            (h.flags &= -257),
              Yg(h, p, a, o, e),
              h.mode & 1 && $g(o, u, e),
              (e = h),
              (s = u);
            var m = e.updateQueue;
            if (m === null) {
              var g = new Set();
              g.add(s), (e.updateQueue = g);
            } else m.add(s);
            break e;
          } else {
            if (!(e & 1)) {
              $g(o, u, e), Yp();
              break e;
            }
            s = Error(be(426));
          }
        } else if (_t && a.mode & 1) {
          var f = Xg(p);
          if (f !== null) {
            !(f.flags & 65536) && (f.flags |= 256),
              Yg(f, p, a, o, e),
              Ap(go(s, a));
            break e;
          }
        }
        (o = s = go(s, a)),
          Rt !== 4 && (Rt = 2),
          Ia === null ? (Ia = [o]) : Ia.push(o),
          (o = p);
        do {
          switch (o.tag) {
            case 3:
              (o.flags |= 65536), (e &= -e), (o.lanes |= e);
              var v = Qx(o, s, e);
              zg(o, v);
              break e;
            case 1:
              a = s;
              var y = o.type,
                _ = o.stateNode;
              if (
                !(o.flags & 128) &&
                (typeof y.getDerivedStateFromError == "function" ||
                  (_ !== null &&
                    typeof _.componentDidCatch == "function" &&
                    (dr === null || !dr.has(_))))
              ) {
                (o.flags |= 65536), (e &= -e), (o.lanes |= e);
                var x = eb(o, a, e);
                zg(o, x);
                break e;
              }
          }
          o = o.return;
        } while (o !== null);
      }
      _b(t);
    } catch (b) {
      (e = b), Ot === t && t !== null && (Ot = t = t.return);
      continue;
    }
    break;
  } while (1);
}
function vb() {
  var n = pu.current;
  return (pu.current = du), n === null ? du : n;
}
function Yp() {
  (Rt === 0 || Rt === 3 || Rt === 2) && (Rt = 4),
    Ut === null || (!(ns & 268435455) && !(Nu & 268435455)) || ir(Ut, Wt);
}
function vu(n, e) {
  var t = nt;
  nt |= 2;
  var i = vb();
  (Ut !== n || Wt !== e) && ((Li = null), $r(n, e));
  do
    try {
      BT();
      break;
    } catch (r) {
      gb(n, r);
    }
  while (1);
  if ((Op(), (nt = t), (pu.current = i), Ot !== null)) throw Error(be(261));
  return (Ut = null), (Wt = 0), Rt;
}
function BT() {
  for (; Ot !== null; ) yb(Ot);
}
function zT() {
  for (; Ot !== null && !uw(); ) yb(Ot);
}
function yb(n) {
  var e = bb(n.alternate, n, Mn);
  (n.memoizedProps = n.pendingProps),
    e === null ? _b(n) : (Ot = e),
    (Vp.current = null);
}
function _b(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = DT(t, e)), t !== null)) {
        (t.flags &= 32767), (Ot = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (Rt = 6), (Ot = null);
        return;
      }
    } else if (((t = LT(t, e, Mn)), t !== null)) {
      Ot = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Ot = e;
      return;
    }
    Ot = e = n;
  } while (e !== null);
  Rt === 0 && (Rt = 5);
}
function kr(n, e, t) {
  var i = lt,
    r = $n.transition;
  try {
    ($n.transition = null), (lt = 1), UT(n, e, t, i);
  } finally {
    ($n.transition = r), (lt = i);
  }
  return null;
}
function UT(n, e, t, i) {
  do io();
  while (sr !== null);
  if (nt & 6) throw Error(be(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(be(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var o = t.lanes | t.childLanes;
  if (
    (xw(n, o),
    n === Ut && ((Ot = Ut = null), (Wt = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      Jl ||
      ((Jl = !0),
      Sb(Jc, function () {
        return io(), null;
      })),
    (o = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || o)
  ) {
    (o = $n.transition), ($n.transition = null);
    var p = lt;
    lt = 1;
    var a = nt;
    (nt |= 4),
      (Vp.current = null),
      IT(n, t),
      db(t, n),
      oT(dd),
      (eu = !!fd),
      (dd = fd = null),
      (n.current = t),
      kT(t),
      hw(),
      (nt = a),
      (lt = p),
      ($n.transition = o);
  } else n.current = t;
  if (
    (Jl && ((Jl = !1), (sr = n), (gu = r)),
    (o = n.pendingLanes),
    o === 0 && (dr = null),
    pw(t.stateNode),
    xn(n, Mt()),
    e !== null)
  )
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      (r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest });
  if (mu) throw ((mu = !1), (n = Rd), (Rd = null), n);
  return (
    gu & 1 && n.tag !== 0 && io(),
    (o = n.pendingLanes),
    o & 1 ? (n === Id ? ka++ : ((ka = 0), (Id = n))) : (ka = 0),
    wr(),
    null
  );
}
function io() {
  if (sr !== null) {
    var n = J_(gu),
      e = $n.transition,
      t = lt;
    try {
      if ((($n.transition = null), (lt = 16 > n ? 16 : n), sr === null))
        var i = !1;
      else {
        if (((n = sr), (sr = null), (gu = 0), nt & 6)) throw Error(be(331));
        var r = nt;
        for (nt |= 4, Oe = n.current; Oe !== null; ) {
          var o = Oe,
            p = o.child;
          if (Oe.flags & 16) {
            var a = o.deletions;
            if (a !== null) {
              for (var s = 0; s < a.length; s++) {
                var u = a[s];
                for (Oe = u; Oe !== null; ) {
                  var d = Oe;
                  switch (d.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ra(8, d, o);
                  }
                  var l = d.child;
                  if (l !== null) (l.return = d), (Oe = l);
                  else
                    for (; Oe !== null; ) {
                      d = Oe;
                      var c = d.sibling,
                        h = d.return;
                      if ((ub(d), d === u)) {
                        Oe = null;
                        break;
                      }
                      if (c !== null) {
                        (c.return = h), (Oe = c);
                        break;
                      }
                      Oe = h;
                    }
                }
              }
              var m = o.alternate;
              if (m !== null) {
                var g = m.child;
                if (g !== null) {
                  m.child = null;
                  do {
                    var f = g.sibling;
                    (g.sibling = null), (g = f);
                  } while (g !== null);
                }
              }
              Oe = o;
            }
          }
          if (o.subtreeFlags & 2064 && p !== null) (p.return = o), (Oe = p);
          else
            e: for (; Oe !== null; ) {
              if (((o = Oe), o.flags & 2048))
                switch (o.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Ra(9, o, o.return);
                }
              var v = o.sibling;
              if (v !== null) {
                (v.return = o.return), (Oe = v);
                break e;
              }
              Oe = o.return;
            }
        }
        var y = n.current;
        for (Oe = y; Oe !== null; ) {
          p = Oe;
          var _ = p.child;
          if (p.subtreeFlags & 2064 && _ !== null) (_.return = p), (Oe = _);
          else
            e: for (p = y; Oe !== null; ) {
              if (((a = Oe), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Fu(9, a);
                  }
                } catch (b) {
                  Tt(a, a.return, b);
                }
              if (a === p) {
                Oe = null;
                break e;
              }
              var x = a.sibling;
              if (x !== null) {
                (x.return = a.return), (Oe = x);
                break e;
              }
              Oe = a.return;
            }
        }
        if (
          ((nt = r), wr(), yi && typeof yi.onPostCommitFiberRoot == "function")
        )
          try {
            yi.onPostCommitFiberRoot(Au, n);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (lt = t), ($n.transition = e);
    }
  }
  return !1;
}
function av(n, e, t) {
  (e = go(t, e)),
    (e = Qx(n, e, 1)),
    (n = fr(n, e, 1)),
    (e = un()),
    n !== null && (vl(n, 1, e), xn(n, e));
}
function Tt(n, e, t) {
  if (n.tag === 3) av(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        av(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (dr === null || !dr.has(i)))
        ) {
          (n = go(t, n)),
            (n = eb(e, n, 1)),
            (e = fr(e, n, 1)),
            (n = un()),
            e !== null && (vl(e, 1, n), xn(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function jT(n, e, t) {
  var i = n.pingCache;
  i !== null && i.delete(e),
    (e = un()),
    (n.pingedLanes |= n.suspendedLanes & t),
    Ut === n &&
      (Wt & t) === t &&
      (Rt === 4 || (Rt === 3 && (Wt & 130023424) === Wt && 500 > Mt() - Gp)
        ? $r(n, 0)
        : (Wp |= t)),
    xn(n, e);
}
function xb(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Hl), (Hl <<= 1), !(Hl & 130023424) && (Hl = 4194304))
      : (e = 1));
  var t = un();
  (n = ji(n, e)), n !== null && (vl(n, e, t), xn(n, t));
}
function HT(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), xb(n, t);
}
function VT(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode,
        r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(be(314));
  }
  i !== null && i.delete(e), xb(n, t);
}
var bb;
bb = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || yn.current) gn = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (gn = !1), OT(n, e, t);
      gn = !!(n.flags & 131072);
    }
  else (gn = !1), _t && e.flags & 1048576 && Tx(e, au, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      Nc(n, e), (n = e.pendingProps);
      var r = ho(e, Qt.current);
      no(e, t), (r = Bp(null, e, i, n, r, t));
      var o = zp();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            _n(i) ? ((o = !0), su(e)) : (o = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            Rp(e),
            (r.updater = Iu),
            (e.stateNode = r),
            (r._reactInternals = e),
            Sd(e, i, n, t),
            (e = Cd(null, e, i, !0, o, t)))
          : ((e.tag = 0), _t && o && Mp(e), on(null, e, r, t), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (Nc(n, e),
          (n = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = GT(i)),
          (n = ti(i, n)),
          r)
        ) {
          case 0:
            e = Td(null, e, i, n, t);
            break e;
          case 1:
            e = Zg(null, e, i, n, t);
            break e;
          case 11:
            e = Kg(null, e, i, n, t);
            break e;
          case 14:
            e = qg(null, e, i, ti(i.type, n), t);
            break e;
        }
        throw Error(be(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : ti(i, r)),
        Td(n, e, i, r, t)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : ti(i, r)),
        Zg(n, e, i, r, t)
      );
    case 3:
      e: {
        if ((rb(e), n === null)) throw Error(be(387));
        (i = e.pendingProps),
          (o = e.memoizedState),
          (r = o.element),
          Ax(n, e),
          uu(e, i, null, t);
        var p = e.memoizedState;
        if (((i = p.element), o.isDehydrated))
          if (
            ((o = {
              element: i,
              isDehydrated: !1,
              cache: p.cache,
              pendingSuspenseBoundaries: p.pendingSuspenseBoundaries,
              transitions: p.transitions,
            }),
            (e.updateQueue.baseState = o),
            (e.memoizedState = o),
            e.flags & 256)
          ) {
            (r = go(Error(be(423)), e)), (e = Jg(n, e, i, t, r));
            break e;
          } else if (i !== r) {
            (r = go(Error(be(424)), e)), (e = Jg(n, e, i, t, r));
            break e;
          } else
            for (
              En = hr(e.stateNode.containerInfo.firstChild),
                On = e,
                _t = !0,
                ii = null,
                t = Dx(e, null, i, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((fo(), i === r)) {
            e = Hi(n, e, t);
            break e;
          }
          on(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        Rx(e),
        n === null && _d(e),
        (i = e.type),
        (r = e.pendingProps),
        (o = n !== null ? n.memoizedProps : null),
        (p = r.children),
        pd(i, r) ? (p = null) : o !== null && pd(i, o) && (e.flags |= 32),
        ib(n, e),
        on(n, e, p, t),
        e.child
      );
    case 6:
      return n === null && _d(e), null;
    case 13:
      return sb(n, e, t);
    case 4:
      return (
        Ip(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        n === null ? (e.child = po(e, null, i, t)) : on(n, e, i, t),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : ti(i, r)),
        Kg(n, e, i, r, t)
      );
    case 7:
      return on(n, e, e.pendingProps, t), e.child;
    case 8:
      return on(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return on(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (o = e.memoizedProps),
          (p = r.value),
          pt(lu, i._currentValue),
          (i._currentValue = p),
          o !== null)
        )
          if (ai(o.value, p)) {
            if (o.children === r.children && !yn.current) {
              e = Hi(n, e, t);
              break e;
            }
          } else
            for (o = e.child, o !== null && (o.return = e); o !== null; ) {
              var a = o.dependencies;
              if (a !== null) {
                p = o.child;
                for (var s = a.firstContext; s !== null; ) {
                  if (s.context === i) {
                    if (o.tag === 1) {
                      (s = Ni(-1, t & -t)), (s.tag = 2);
                      var u = o.updateQueue;
                      if (u !== null) {
                        u = u.shared;
                        var d = u.pending;
                        d === null
                          ? (s.next = s)
                          : ((s.next = d.next), (d.next = s)),
                          (u.pending = s);
                      }
                    }
                    (o.lanes |= t),
                      (s = o.alternate),
                      s !== null && (s.lanes |= t),
                      xd(o.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  s = s.next;
                }
              } else if (o.tag === 10) p = o.type === e.type ? null : o.child;
              else if (o.tag === 18) {
                if (((p = o.return), p === null)) throw Error(be(341));
                (p.lanes |= t),
                  (a = p.alternate),
                  a !== null && (a.lanes |= t),
                  xd(p, t, e),
                  (p = o.sibling);
              } else p = o.child;
              if (p !== null) p.return = o;
              else
                for (p = o; p !== null; ) {
                  if (p === e) {
                    p = null;
                    break;
                  }
                  if (((o = p.sibling), o !== null)) {
                    (o.return = p.return), (p = o);
                    break;
                  }
                  p = p.return;
                }
              o = p;
            }
        on(n, e, r.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        no(e, t),
        (r = Yn(r)),
        (i = i(r)),
        (e.flags |= 1),
        on(n, e, i, t),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = ti(i, e.pendingProps)),
        (r = ti(i.type, r)),
        qg(n, e, i, r, t)
      );
    case 15:
      return tb(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : ti(i, r)),
        Nc(n, e),
        (e.tag = 1),
        _n(i) ? ((n = !0), su(e)) : (n = !1),
        no(e, t),
        Ox(e, i, r),
        Sd(e, i, r, t),
        Cd(null, e, i, !0, n, t)
      );
    case 19:
      return ob(n, e, t);
    case 22:
      return nb(n, e, t);
  }
  throw Error(be(156, e.tag));
};
function Sb(n, e) {
  return Y_(n, e);
}
function WT(n, e, t, i) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Gn(n, e, t, i) {
  return new WT(n, e, t, i);
}
function Kp(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function GT(n) {
  if (typeof n == "function") return Kp(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === pp)) return 11;
    if (n === mp) return 14;
  }
  return 2;
}
function mr(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = Gn(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function Uc(n, e, t, i, r, o) {
  var p = 2;
  if (((i = n), typeof n == "function")) Kp(n) && (p = 1);
  else if (typeof n == "string") p = 5;
  else
    e: switch (n) {
      case Ns:
        return Xr(t.children, r, o, e);
      case dp:
        (p = 8), (r |= 8);
        break;
      case $f:
        return (
          (n = Gn(12, t, e, r | 2)), (n.elementType = $f), (n.lanes = o), n
        );
      case Xf:
        return (n = Gn(13, t, e, r)), (n.elementType = Xf), (n.lanes = o), n;
      case Yf:
        return (n = Gn(19, t, e, r)), (n.elementType = Yf), (n.lanes = o), n;
      case L_:
        return Bu(t, r, o, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case P_:
              p = 10;
              break e;
            case O_:
              p = 9;
              break e;
            case pp:
              p = 11;
              break e;
            case mp:
              p = 14;
              break e;
            case Ji:
              (p = 16), (i = null);
              break e;
          }
        throw Error(be(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = Gn(p, t, e, r)), (e.elementType = n), (e.type = i), (e.lanes = o), e
  );
}
function Xr(n, e, t, i) {
  return (n = Gn(7, n, i, e)), (n.lanes = t), n;
}
function Bu(n, e, t, i) {
  return (
    (n = Gn(22, n, i, e)),
    (n.elementType = L_),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function jh(n, e, t) {
  return (n = Gn(6, n, null, e)), (n.lanes = t), n;
}
function Hh(n, e, t) {
  return (
    (e = Gn(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function $T(n, e, t, i, r) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Sh(0)),
    (this.expirationTimes = Sh(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Sh(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function qp(n, e, t, i, r, o, p, a, s) {
  return (
    (n = new $T(n, e, t, a, s)),
    e === 1 ? ((e = 1), o === !0 && (e |= 8)) : (e = 0),
    (o = Gn(3, null, null, e)),
    (n.current = o),
    (o.stateNode = n),
    (o.memoizedState = {
      element: i,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    Rp(o),
    n
  );
}
function XT(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Fs,
    key: i == null ? null : "" + i,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function wb(n) {
  if (!n) return yr;
  n = n._reactInternals;
  e: {
    if (hs(n) !== n || n.tag !== 1) throw Error(be(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (_n(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(be(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (_n(t)) return Sx(n, t, e);
  }
  return e;
}
function Tb(n, e, t, i, r, o, p, a, s) {
  return (
    (n = qp(t, i, !0, n, r, o, p, a, s)),
    (n.context = wb(null)),
    (t = n.current),
    (i = un()),
    (r = pr(t)),
    (o = Ni(i, r)),
    (o.callback = e ?? null),
    fr(t, o, r),
    (n.current.lanes = r),
    vl(n, r, i),
    xn(n, i),
    n
  );
}
function zu(n, e, t, i) {
  var r = e.current,
    o = un(),
    p = pr(r);
  return (
    (t = wb(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = Ni(o, p)),
    (e.payload = { element: n }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (n = fr(r, e, p)),
    n !== null && (si(n, r, p, o), Ic(n, r, p)),
    p
  );
}
function yu(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function lv(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function Zp(n, e) {
  lv(n, e), (n = n.alternate) && lv(n, e);
}
function YT() {
  return null;
}
var Cb =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function Jp(n) {
  this._internalRoot = n;
}
Uu.prototype.render = Jp.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(be(409));
  zu(n, e, null, null);
};
Uu.prototype.unmount = Jp.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    is(function () {
      zu(null, n, null, null);
    }),
      (e[Ui] = null);
  }
};
function Uu(n) {
  this._internalRoot = n;
}
Uu.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = tx();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < nr.length && e !== 0 && e < nr[t].priority; t++);
    nr.splice(t, 0, n), t === 0 && ix(n);
  }
};
function Qp(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function ju(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function cv() {}
function KT(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var o = i;
      i = function () {
        var u = yu(p);
        o.call(u);
      };
    }
    var p = Tb(e, i, n, 0, null, !1, !1, "", cv);
    return (
      (n._reactRootContainer = p),
      (n[Ui] = p.current),
      Ka(n.nodeType === 8 ? n.parentNode : n),
      is(),
      p
    );
  }
  for (; (r = n.lastChild); ) n.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var u = yu(s);
      a.call(u);
    };
  }
  var s = qp(n, 0, !1, null, null, !1, !1, "", cv);
  return (
    (n._reactRootContainer = s),
    (n[Ui] = s.current),
    Ka(n.nodeType === 8 ? n.parentNode : n),
    is(function () {
      zu(e, s, t, i);
    }),
    s
  );
}
function Hu(n, e, t, i, r) {
  var o = t._reactRootContainer;
  if (o) {
    var p = o;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var s = yu(p);
        a.call(s);
      };
    }
    zu(e, p, n, r);
  } else p = KT(t, e, n, r, i);
  return yu(p);
}
Q_ = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = wa(e.pendingLanes);
        t !== 0 &&
          (yp(e, t | 1), xn(e, Mt()), !(nt & 6) && ((vo = Mt() + 500), wr()));
      }
      break;
    case 13:
      is(function () {
        var i = ji(n, 1);
        if (i !== null) {
          var r = un();
          si(i, n, 1, r);
        }
      }),
        Zp(n, 1);
  }
};
_p = function (n) {
  if (n.tag === 13) {
    var e = ji(n, 134217728);
    if (e !== null) {
      var t = un();
      si(e, n, 134217728, t);
    }
    Zp(n, 134217728);
  }
};
ex = function (n) {
  if (n.tag === 13) {
    var e = pr(n),
      t = ji(n, e);
    if (t !== null) {
      var i = un();
      si(t, n, e, i);
    }
    Zp(n, e);
  }
};
tx = function () {
  return lt;
};
nx = function (n, e) {
  var t = lt;
  try {
    return (lt = n), e();
  } finally {
    lt = t;
  }
};
rd = function (n, e, t) {
  switch (e) {
    case "input":
      if ((Zf(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = Du(i);
            if (!r) throw Error(be(90));
            R_(i), Zf(i, r);
          }
        }
      }
      break;
    case "textarea":
      k_(n, t);
      break;
    case "select":
      (e = t.value), e != null && Js(n, !!t.multiple, e, !1);
  }
};
H_ = $p;
V_ = is;
var qT = { usingClientEntryPoint: !1, Events: [_l, js, Du, U_, j_, $p] },
  ia = {
    findFiberByHostInstance: jr,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  ZT = {
    bundleType: ia.bundleType,
    version: ia.version,
    rendererPackageName: ia.rendererPackageName,
    rendererConfig: ia.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Vi.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = $_(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: ia.findFiberByHostInstance || YT,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Ql = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Ql.isDisabled && Ql.supportsFiber)
    try {
      (Au = Ql.inject(ZT)), (yi = Ql);
    } catch {}
}
In.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = qT;
In.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Qp(e)) throw Error(be(200));
  return XT(n, e, null, t);
};
In.createRoot = function (n, e) {
  if (!Qp(n)) throw Error(be(299));
  var t = !1,
    i = "",
    r = Cb;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = qp(n, 1, !1, null, null, t, !1, i, r)),
    (n[Ui] = e.current),
    Ka(n.nodeType === 8 ? n.parentNode : n),
    new Jp(e)
  );
};
In.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(be(188))
      : ((n = Object.keys(n).join(",")), Error(be(268, n)));
  return (n = $_(e)), (n = n === null ? null : n.stateNode), n;
};
In.flushSync = function (n) {
  return is(n);
};
In.hydrate = function (n, e, t) {
  if (!ju(e)) throw Error(be(200));
  return Hu(null, n, e, !0, t);
};
In.hydrateRoot = function (n, e, t) {
  if (!Qp(n)) throw Error(be(405));
  var i = (t != null && t.hydratedSources) || null,
    r = !1,
    o = "",
    p = Cb;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (o = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (p = t.onRecoverableError)),
    (e = Tb(e, null, n, 1, t ?? null, r, !1, o, p)),
    (n[Ui] = e.current),
    Ka(n),
    i)
  )
    for (n = 0; n < i.length; n++)
      (t = i[n]),
        (r = t._getVersion),
        (r = r(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, r])
          : e.mutableSourceEagerHydrationData.push(t, r);
  return new Uu(e);
};
In.render = function (n, e, t) {
  if (!ju(e)) throw Error(be(200));
  return Hu(null, n, e, !1, t);
};
In.unmountComponentAtNode = function (n) {
  if (!ju(n)) throw Error(be(40));
  return n._reactRootContainer
    ? (is(function () {
        Hu(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[Ui] = null);
        });
      }),
      !0)
    : !1;
};
In.unstable_batchedUpdates = $p;
In.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
  if (!ju(t)) throw Error(be(200));
  if (n == null || n._reactInternals === void 0) throw Error(be(38));
  return Hu(n, e, t, !1, i);
};
In.version = "18.2.0-next-9e3b772b8-20220608";
(function (n) {
  function e() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  e(), (n.exports = In);
})(YS);
const Yr = sp(co);
var uv = co;
(Vf.createRoot = uv.createRoot), (Vf.hydrateRoot = uv.hydrateRoot);
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const em = "148",
  ys = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  _s = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  JT = 0,
  hv = 1,
  QT = 2,
  Mb = 1,
  eC = 2,
  Ca = 3,
  _r = 0,
  Xn = 1,
  Vu = 2,
  ec = 3,
  gr = 0,
  ro = 1,
  fv = 2,
  dv = 3,
  pv = 4,
  tC = 5,
  ks = 100,
  nC = 101,
  iC = 102,
  mv = 103,
  gv = 104,
  rC = 200,
  sC = 201,
  oC = 202,
  aC = 203,
  Eb = 204,
  Ab = 205,
  lC = 206,
  cC = 207,
  uC = 208,
  hC = 209,
  fC = 210,
  dC = 0,
  pC = 1,
  mC = 2,
  Nd = 3,
  gC = 4,
  vC = 5,
  yC = 6,
  _C = 7,
  tm = 0,
  xC = 1,
  bC = 2,
  Bi = 0,
  SC = 1,
  wC = 2,
  TC = 3,
  CC = 4,
  MC = 5,
  Pb = 300,
  yo = 301,
  _o = 302,
  Bd = 303,
  zd = 304,
  Wu = 306,
  xo = 1e3,
  Vn = 1001,
  _u = 1002,
  zt = 1003,
  Ud = 1004,
  jc = 1005,
  mn = 1006,
  Ob = 1007,
  rs = 1008,
  ss = 1009,
  EC = 1010,
  AC = 1011,
  Lb = 1012,
  PC = 1013,
  Wr = 1014,
  or = 1015,
  rl = 1016,
  OC = 1017,
  LC = 1018,
  so = 1020,
  DC = 1021,
  RC = 1022,
  Wn = 1023,
  IC = 1024,
  kC = 1025,
  Kr = 1026,
  bo = 1027,
  FC = 1028,
  NC = 1029,
  BC = 1030,
  zC = 1031,
  UC = 1033,
  Vh = 33776,
  Wh = 33777,
  Gh = 33778,
  $h = 33779,
  vv = 35840,
  yv = 35841,
  _v = 35842,
  xv = 35843,
  jC = 36196,
  bv = 37492,
  Sv = 37496,
  wv = 37808,
  Tv = 37809,
  Cv = 37810,
  Mv = 37811,
  Ev = 37812,
  Av = 37813,
  Pv = 37814,
  Ov = 37815,
  Lv = 37816,
  Dv = 37817,
  Rv = 37818,
  Iv = 37819,
  kv = 37820,
  Fv = 37821,
  Nv = 36492,
  sl = 2300,
  So = 2301,
  Xh = 2302,
  Bv = 2400,
  zv = 2401,
  Uv = 2402,
  HC = 2500,
  VC = 1,
  Db = 2,
  os = 3e3,
  ot = 3001,
  WC = 3200,
  GC = 3201,
  nm = 0,
  $C = 1,
  pi = "srgb",
  ol = "srgb-linear",
  Yh = 7680,
  XC = 519,
  jd = 35044,
  jv = "300 es",
  Hd = 1035;
class fs {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const o = r.indexOf(t);
      o !== -1 && r.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let o = 0, p = r.length; o < p; o++) r[o].call(this, e);
      e.target = null;
    }
  }
}
const qt = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let Hv = 1234567;
const Fa = Math.PI / 180,
  al = 180 / Math.PI;
function oi() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    qt[n & 255] +
    qt[(n >> 8) & 255] +
    qt[(n >> 16) & 255] +
    qt[(n >> 24) & 255] +
    "-" +
    qt[e & 255] +
    qt[(e >> 8) & 255] +
    "-" +
    qt[((e >> 16) & 15) | 64] +
    qt[(e >> 24) & 255] +
    "-" +
    qt[(t & 63) | 128] +
    qt[(t >> 8) & 255] +
    "-" +
    qt[(t >> 16) & 255] +
    qt[(t >> 24) & 255] +
    qt[i & 255] +
    qt[(i >> 8) & 255] +
    qt[(i >> 16) & 255] +
    qt[(i >> 24) & 255]
  ).toLowerCase();
}
function Jt(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function im(n, e) {
  return ((n % e) + e) % e;
}
function YC(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function KC(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function Na(n, e, t) {
  return (1 - t) * n + t * e;
}
function qC(n, e, t, i) {
  return Na(n, e, 1 - Math.exp(-t * i));
}
function ZC(n, e = 1) {
  return e - Math.abs(im(n, e * 2) - e);
}
function JC(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function QC(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function eM(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function tM(n, e) {
  return n + Math.random() * (e - n);
}
function nM(n) {
  return n * (0.5 - Math.random());
}
function iM(n) {
  n !== void 0 && (Hv = n);
  let e = (Hv += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function rM(n) {
  return n * Fa;
}
function sM(n) {
  return n * al;
}
function Vd(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function Rb(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function xu(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function oM(n, e, t, i, r) {
  const o = Math.cos,
    p = Math.sin,
    a = o(t / 2),
    s = p(t / 2),
    u = o((e + i) / 2),
    d = p((e + i) / 2),
    l = o((e - i) / 2),
    c = p((e - i) / 2),
    h = o((i - e) / 2),
    m = p((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * d, s * l, s * c, a * u);
      break;
    case "YZY":
      n.set(s * c, a * d, s * l, a * u);
      break;
    case "ZXZ":
      n.set(s * l, s * c, a * d, a * u);
      break;
    case "XZX":
      n.set(a * d, s * m, s * h, a * u);
      break;
    case "YXY":
      n.set(s * h, a * d, s * m, a * u);
      break;
    case "ZYZ":
      n.set(s * m, s * h, a * d, a * u);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function Fi(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ct(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var aM = Object.freeze({
  __proto__: null,
  DEG2RAD: Fa,
  RAD2DEG: al,
  generateUUID: oi,
  clamp: Jt,
  euclideanModulo: im,
  mapLinear: YC,
  inverseLerp: KC,
  lerp: Na,
  damp: qC,
  pingpong: ZC,
  smoothstep: JC,
  smootherstep: QC,
  randInt: eM,
  randFloat: tM,
  randFloatSpread: nM,
  seededRandom: iM,
  degToRad: rM,
  radToDeg: sM,
  isPowerOfTwo: Vd,
  ceilPowerOfTwo: Rb,
  floorPowerOfTwo: xu,
  setQuaternionFromProperEuler: oM,
  normalize: ct,
  denormalize: Fi,
});
class ze {
  constructor(e = 0, t = 0) {
    (ze.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      o = this.x - e.x,
      p = this.y - e.y;
    return (this.x = o * i - p * r + e.x), (this.y = o * r + p * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class An {
  constructor() {
    (An.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
  }
  set(e, t, i, r, o, p, a, s, u) {
    const d = this.elements;
    return (
      (d[0] = e),
      (d[1] = r),
      (d[2] = a),
      (d[3] = t),
      (d[4] = o),
      (d[5] = s),
      (d[6] = i),
      (d[7] = p),
      (d[8] = u),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      o = this.elements,
      p = i[0],
      a = i[3],
      s = i[6],
      u = i[1],
      d = i[4],
      l = i[7],
      c = i[2],
      h = i[5],
      m = i[8],
      g = r[0],
      f = r[3],
      v = r[6],
      y = r[1],
      _ = r[4],
      x = r[7],
      b = r[2],
      S = r[5],
      T = r[8];
    return (
      (o[0] = p * g + a * y + s * b),
      (o[3] = p * f + a * _ + s * S),
      (o[6] = p * v + a * x + s * T),
      (o[1] = u * g + d * y + l * b),
      (o[4] = u * f + d * _ + l * S),
      (o[7] = u * v + d * x + l * T),
      (o[2] = c * g + h * y + m * b),
      (o[5] = c * f + h * _ + m * S),
      (o[8] = c * v + h * x + m * T),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      o = e[3],
      p = e[4],
      a = e[5],
      s = e[6],
      u = e[7],
      d = e[8];
    return (
      t * p * d - t * a * u - i * o * d + i * a * s + r * o * u - r * p * s
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      o = e[3],
      p = e[4],
      a = e[5],
      s = e[6],
      u = e[7],
      d = e[8],
      l = d * p - a * u,
      c = a * s - d * o,
      h = u * o - p * s,
      m = t * l + i * c + r * h;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / m;
    return (
      (e[0] = l * g),
      (e[1] = (r * u - d * i) * g),
      (e[2] = (a * i - r * p) * g),
      (e[3] = c * g),
      (e[4] = (d * t - r * s) * g),
      (e[5] = (r * o - a * t) * g),
      (e[6] = h * g),
      (e[7] = (i * s - u * t) * g),
      (e[8] = (p * t - i * o) * g),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, o, p, a) {
    const s = Math.cos(o),
      u = Math.sin(o);
    return (
      this.set(
        i * s,
        i * u,
        -i * (s * p + u * a) + p + e,
        -r * u,
        r * s,
        -r * (-u * p + s * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Kh.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Kh.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Kh.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Kh = new An();
function Ib(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
function ll(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function qr(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Hc(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const qh = { [pi]: { [ol]: qr }, [ol]: { [pi]: Hc } },
  nn = {
    legacyMode: !0,
    get workingColorSpace() {
      return ol;
    },
    set workingColorSpace(n) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (n, e, t) {
      if (this.legacyMode || e === t || !e || !t) return n;
      if (qh[e] && qh[e][t] !== void 0) {
        const i = qh[e][t];
        return (n.r = i(n.r)), (n.g = i(n.g)), (n.b = i(n.b)), n;
      }
      throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this.workingColorSpace);
    },
  },
  kb = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Lt = { r: 0, g: 0, b: 0 },
  Jn = { h: 0, s: 0, l: 0 },
  tc = { h: 0, s: 0, l: 0 };
function Zh(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
function nc(n, e) {
  return (e.r = n.r), (e.g = n.g), (e.b = n.b), e;
}
class je {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    );
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
        ? this.setHex(e)
        : typeof e == "string" && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = pi) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      nn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = nn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      nn.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = nn.workingColorSpace) {
    if (((e = im(e, 1)), (t = Jt(t, 0, 1)), (i = Jt(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const o = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        p = 2 * i - o;
      (this.r = Zh(p, o, e + 1 / 3)),
        (this.g = Zh(p, o, e)),
        (this.b = Zh(p, o, e - 1 / 3));
    }
    return nn.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = pi) {
    function i(o) {
      o !== void 0 &&
        parseFloat(o) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
      let o;
      const p = r[1],
        a = r[2];
      switch (p) {
        case "rgb":
        case "rgba":
          if (
            (o =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(o[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(o[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(o[3], 10)) / 255),
              nn.toWorkingColorSpace(this, t),
              i(o[4]),
              this
            );
          if (
            (o =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(o[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(o[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(o[3], 10)) / 100),
              nn.toWorkingColorSpace(this, t),
              i(o[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (o =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          ) {
            const s = parseFloat(o[1]) / 360,
              u = parseFloat(o[2]) / 100,
              d = parseFloat(o[3]) / 100;
            return i(o[4]), this.setHSL(s, u, d, t);
          }
          break;
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const o = r[1],
        p = o.length;
      if (p === 3)
        return (
          (this.r = parseInt(o.charAt(0) + o.charAt(0), 16) / 255),
          (this.g = parseInt(o.charAt(1) + o.charAt(1), 16) / 255),
          (this.b = parseInt(o.charAt(2) + o.charAt(2), 16) / 255),
          nn.toWorkingColorSpace(this, t),
          this
        );
      if (p === 6)
        return (
          (this.r = parseInt(o.charAt(0) + o.charAt(1), 16) / 255),
          (this.g = parseInt(o.charAt(2) + o.charAt(3), 16) / 255),
          (this.b = parseInt(o.charAt(4) + o.charAt(5), 16) / 255),
          nn.toWorkingColorSpace(this, t),
          this
        );
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = pi) {
    const i = kb[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = qr(e.r)), (this.g = qr(e.g)), (this.b = qr(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Hc(e.r)), (this.g = Hc(e.g)), (this.b = Hc(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = pi) {
    return (
      nn.fromWorkingColorSpace(nc(this, Lt), e),
      (Jt(Lt.r * 255, 0, 255) << 16) ^
        (Jt(Lt.g * 255, 0, 255) << 8) ^
        (Jt(Lt.b * 255, 0, 255) << 0)
    );
  }
  getHexString(e = pi) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = nn.workingColorSpace) {
    nn.fromWorkingColorSpace(nc(this, Lt), t);
    const i = Lt.r,
      r = Lt.g,
      o = Lt.b,
      p = Math.max(i, r, o),
      a = Math.min(i, r, o);
    let s, u;
    const d = (a + p) / 2;
    if (a === p) (s = 0), (u = 0);
    else {
      const l = p - a;
      switch (((u = d <= 0.5 ? l / (p + a) : l / (2 - p - a)), p)) {
        case i:
          s = (r - o) / l + (r < o ? 6 : 0);
          break;
        case r:
          s = (o - i) / l + 2;
          break;
        case o:
          s = (i - r) / l + 4;
          break;
      }
      s /= 6;
    }
    return (e.h = s), (e.s = u), (e.l = d), e;
  }
  getRGB(e, t = nn.workingColorSpace) {
    return (
      nn.fromWorkingColorSpace(nc(this, Lt), t),
      (e.r = Lt.r),
      (e.g = Lt.g),
      (e.b = Lt.b),
      e
    );
  }
  getStyle(e = pi) {
    return (
      nn.fromWorkingColorSpace(nc(this, Lt), e),
      e !== pi
        ? `color(${e} ${Lt.r} ${Lt.g} ${Lt.b})`
        : `rgb(${(Lt.r * 255) | 0},${(Lt.g * 255) | 0},${(Lt.b * 255) | 0})`
    );
  }
  offsetHSL(e, t, i) {
    return (
      this.getHSL(Jn),
      (Jn.h += e),
      (Jn.s += t),
      (Jn.l += i),
      this.setHSL(Jn.h, Jn.s, Jn.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Jn), e.getHSL(tc);
    const i = Na(Jn.h, tc.h, t),
      r = Na(Jn.s, tc.s, t),
      o = Na(Jn.l, tc.l, t);
    return this.setHSL(i, r, o), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
je.NAMES = kb;
let xs;
class Fb {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      xs === void 0 && (xs = ll("canvas")),
        (xs.width = e.width),
        (xs.height = e.height);
      const i = xs.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = xs);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = ll("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        o = r.data;
      for (let p = 0; p < o.length; p++) o[p] = qr(o[p] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(qr(t[i] / 255) * 255))
          : (t[i] = qr(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
class Nb {
  constructor(e = null) {
    (this.isSource = !0),
      (this.uuid = oi()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let o;
      if (Array.isArray(r)) {
        o = [];
        for (let p = 0, a = r.length; p < a; p++)
          r[p].isDataTexture ? o.push(Jh(r[p].image)) : o.push(Jh(r[p]));
      } else o = Jh(r);
      i.url = o;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function Jh(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? Fb.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let lM = 0;
class jt extends fs {
  constructor(
    e = jt.DEFAULT_IMAGE,
    t = jt.DEFAULT_MAPPING,
    i = Vn,
    r = Vn,
    o = mn,
    p = rs,
    a = Wn,
    s = ss,
    u = jt.DEFAULT_ANISOTROPY,
    d = os
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: lM++ }),
      (this.uuid = oi()),
      (this.name = ""),
      (this.source = new Nb(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = o),
      (this.minFilter = p),
      (this.anisotropy = u),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = s),
      (this.offset = new ze(0, 0)),
      (this.repeat = new ze(1, 1)),
      (this.center = new ze(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new An()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = d),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.encoding = e.encoding),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Pb) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case xo:
          e.x = e.x - Math.floor(e.x);
          break;
        case Vn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case _u:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case xo:
          e.y = e.y - Math.floor(e.y);
          break;
        case Vn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case _u:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
}
jt.DEFAULT_IMAGE = null;
jt.DEFAULT_MAPPING = Pb;
jt.DEFAULT_ANISOTROPY = 1;
class ht {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (ht.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      o = this.w,
      p = e.elements;
    return (
      (this.x = p[0] * t + p[4] * i + p[8] * r + p[12] * o),
      (this.y = p[1] * t + p[5] * i + p[9] * r + p[13] * o),
      (this.z = p[2] * t + p[6] * i + p[10] * r + p[14] * o),
      (this.w = p[3] * t + p[7] * i + p[11] * r + p[15] * o),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, o;
    const s = e.elements,
      u = s[0],
      d = s[4],
      l = s[8],
      c = s[1],
      h = s[5],
      m = s[9],
      g = s[2],
      f = s[6],
      v = s[10];
    if (
      Math.abs(d - c) < 0.01 &&
      Math.abs(l - g) < 0.01 &&
      Math.abs(m - f) < 0.01
    ) {
      if (
        Math.abs(d + c) < 0.1 &&
        Math.abs(l + g) < 0.1 &&
        Math.abs(m + f) < 0.1 &&
        Math.abs(u + h + v - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const _ = (u + 1) / 2,
        x = (h + 1) / 2,
        b = (v + 1) / 2,
        S = (d + c) / 4,
        T = (l + g) / 4,
        w = (m + f) / 4;
      return (
        _ > x && _ > b
          ? _ < 0.01
            ? ((i = 0), (r = 0.707106781), (o = 0.707106781))
            : ((i = Math.sqrt(_)), (r = S / i), (o = T / i))
          : x > b
          ? x < 0.01
            ? ((i = 0.707106781), (r = 0), (o = 0.707106781))
            : ((r = Math.sqrt(x)), (i = S / r), (o = w / r))
          : b < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (o = 0))
          : ((o = Math.sqrt(b)), (i = T / o), (r = w / o)),
        this.set(i, r, o, t),
        this
      );
    }
    let y = Math.sqrt(
      (f - m) * (f - m) + (l - g) * (l - g) + (c - d) * (c - d)
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (f - m) / y),
      (this.y = (l - g) / y),
      (this.z = (c - d) / y),
      (this.w = Math.acos((u + h + v - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class as extends fs {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new ht(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new ht(0, 0, e, t));
    const r = { width: e, height: t, depth: 1 };
    (this.texture = new jt(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
      (this.texture.internalFormat =
        i.internalFormat !== void 0 ? i.internalFormat : null),
      (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : mn),
      (this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
      (this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
      (this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null),
      (this.samples = i.samples !== void 0 ? i.samples : 0);
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Nb(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Bb extends jt {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = zt),
      (this.minFilter = zt),
      (this.wrapR = Vn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class cM extends jt {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = zt),
      (this.minFilter = zt),
      (this.wrapR = Vn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class xi {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, t, i, r, o, p, a) {
    let s = i[r + 0],
      u = i[r + 1],
      d = i[r + 2],
      l = i[r + 3];
    const c = o[p + 0],
      h = o[p + 1],
      m = o[p + 2],
      g = o[p + 3];
    if (a === 0) {
      (e[t + 0] = s), (e[t + 1] = u), (e[t + 2] = d), (e[t + 3] = l);
      return;
    }
    if (a === 1) {
      (e[t + 0] = c), (e[t + 1] = h), (e[t + 2] = m), (e[t + 3] = g);
      return;
    }
    if (l !== g || s !== c || u !== h || d !== m) {
      let f = 1 - a;
      const v = s * c + u * h + d * m + l * g,
        y = v >= 0 ? 1 : -1,
        _ = 1 - v * v;
      if (_ > Number.EPSILON) {
        const b = Math.sqrt(_),
          S = Math.atan2(b, v * y);
        (f = Math.sin(f * S) / b), (a = Math.sin(a * S) / b);
      }
      const x = a * y;
      if (
        ((s = s * f + c * x),
        (u = u * f + h * x),
        (d = d * f + m * x),
        (l = l * f + g * x),
        f === 1 - a)
      ) {
        const b = 1 / Math.sqrt(s * s + u * u + d * d + l * l);
        (s *= b), (u *= b), (d *= b), (l *= b);
      }
    }
    (e[t] = s), (e[t + 1] = u), (e[t + 2] = d), (e[t + 3] = l);
  }
  static multiplyQuaternionsFlat(e, t, i, r, o, p) {
    const a = i[r],
      s = i[r + 1],
      u = i[r + 2],
      d = i[r + 3],
      l = o[p],
      c = o[p + 1],
      h = o[p + 2],
      m = o[p + 3];
    return (
      (e[t] = a * m + d * l + s * h - u * c),
      (e[t + 1] = s * m + d * c + u * l - a * h),
      (e[t + 2] = u * m + d * h + a * c - s * l),
      (e[t + 3] = d * m - a * l - s * c - u * h),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const i = e._x,
      r = e._y,
      o = e._z,
      p = e._order,
      a = Math.cos,
      s = Math.sin,
      u = a(i / 2),
      d = a(r / 2),
      l = a(o / 2),
      c = s(i / 2),
      h = s(r / 2),
      m = s(o / 2);
    switch (p) {
      case "XYZ":
        (this._x = c * d * l + u * h * m),
          (this._y = u * h * l - c * d * m),
          (this._z = u * d * m + c * h * l),
          (this._w = u * d * l - c * h * m);
        break;
      case "YXZ":
        (this._x = c * d * l + u * h * m),
          (this._y = u * h * l - c * d * m),
          (this._z = u * d * m - c * h * l),
          (this._w = u * d * l + c * h * m);
        break;
      case "ZXY":
        (this._x = c * d * l - u * h * m),
          (this._y = u * h * l + c * d * m),
          (this._z = u * d * m + c * h * l),
          (this._w = u * d * l - c * h * m);
        break;
      case "ZYX":
        (this._x = c * d * l - u * h * m),
          (this._y = u * h * l + c * d * m),
          (this._z = u * d * m - c * h * l),
          (this._w = u * d * l + c * h * m);
        break;
      case "YZX":
        (this._x = c * d * l + u * h * m),
          (this._y = u * h * l + c * d * m),
          (this._z = u * d * m - c * h * l),
          (this._w = u * d * l - c * h * m);
        break;
      case "XZY":
        (this._x = c * d * l - u * h * m),
          (this._y = u * h * l - c * d * m),
          (this._z = u * d * m + c * h * l),
          (this._w = u * d * l + c * h * m);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + p
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      o = t[8],
      p = t[1],
      a = t[5],
      s = t[9],
      u = t[2],
      d = t[6],
      l = t[10],
      c = i + a + l;
    if (c > 0) {
      const h = 0.5 / Math.sqrt(c + 1);
      (this._w = 0.25 / h),
        (this._x = (d - s) * h),
        (this._y = (o - u) * h),
        (this._z = (p - r) * h);
    } else if (i > a && i > l) {
      const h = 2 * Math.sqrt(1 + i - a - l);
      (this._w = (d - s) / h),
        (this._x = 0.25 * h),
        (this._y = (r + p) / h),
        (this._z = (o + u) / h);
    } else if (a > l) {
      const h = 2 * Math.sqrt(1 + a - i - l);
      (this._w = (o - u) / h),
        (this._x = (r + p) / h),
        (this._y = 0.25 * h),
        (this._z = (s + d) / h);
    } else {
      const h = 2 * Math.sqrt(1 + l - i - a);
      (this._w = (p - r) / h),
        (this._x = (o + u) / h),
        (this._y = (s + d) / h),
        (this._z = 0.25 * h);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Jt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      o = e._z,
      p = e._w,
      a = t._x,
      s = t._y,
      u = t._z,
      d = t._w;
    return (
      (this._x = i * d + p * a + r * u - o * s),
      (this._y = r * d + p * s + o * a - i * u),
      (this._z = o * d + p * u + i * s - r * a),
      (this._w = p * d - i * a - r * s - o * u),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      o = this._z,
      p = this._w;
    let a = p * e._w + i * e._x + r * e._y + o * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = p), (this._x = i), (this._y = r), (this._z = o), this;
    const s = 1 - a * a;
    if (s <= Number.EPSILON) {
      const h = 1 - t;
      return (
        (this._w = h * p + t * this._w),
        (this._x = h * i + t * this._x),
        (this._y = h * r + t * this._y),
        (this._z = h * o + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const u = Math.sqrt(s),
      d = Math.atan2(u, a),
      l = Math.sin((1 - t) * d) / u,
      c = Math.sin(t * d) / u;
    return (
      (this._w = p * l + this._w * c),
      (this._x = i * l + this._x * c),
      (this._y = r * l + this._y * c),
      (this._z = o * l + this._z * c),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      o = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(o),
      i * Math.cos(o),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Q {
  constructor(e = 0, t = 0, i = 0) {
    (Q.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Vv.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Vv.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[3] * i + o[6] * r),
      (this.y = o[1] * t + o[4] * i + o[7] * r),
      (this.z = o[2] * t + o[5] * i + o[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      o = e.elements,
      p = 1 / (o[3] * t + o[7] * i + o[11] * r + o[15]);
    return (
      (this.x = (o[0] * t + o[4] * i + o[8] * r + o[12]) * p),
      (this.y = (o[1] * t + o[5] * i + o[9] * r + o[13]) * p),
      (this.z = (o[2] * t + o[6] * i + o[10] * r + o[14]) * p),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      o = e.x,
      p = e.y,
      a = e.z,
      s = e.w,
      u = s * t + p * r - a * i,
      d = s * i + a * t - o * r,
      l = s * r + o * i - p * t,
      c = -o * t - p * i - a * r;
    return (
      (this.x = u * s + c * -o + d * -a - l * -p),
      (this.y = d * s + c * -p + l * -o - u * -a),
      (this.z = l * s + c * -a + u * -p - d * -o),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r),
      (this.y = o[1] * t + o[5] * i + o[9] * r),
      (this.z = o[2] * t + o[6] * i + o[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      o = e.z,
      p = t.x,
      a = t.y,
      s = t.z;
    return (
      (this.x = r * s - o * a),
      (this.y = o * p - i * s),
      (this.z = i * a - r * p),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return Qh.copy(this).projectOnVector(e), this.sub(Qh);
  }
  reflect(e) {
    return this.sub(Qh.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Jt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Qh = new Q(),
  Vv = new xi();
class Do {
  constructor(
    e = new Q(1 / 0, 1 / 0, 1 / 0),
    t = new Q(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0,
      i = 1 / 0,
      r = 1 / 0,
      o = -1 / 0,
      p = -1 / 0,
      a = -1 / 0;
    for (let s = 0, u = e.length; s < u; s += 3) {
      const d = e[s],
        l = e[s + 1],
        c = e[s + 2];
      d < t && (t = d),
        l < i && (i = l),
        c < r && (r = c),
        d > o && (o = d),
        l > p && (p = l),
        c > a && (a = c);
    }
    return this.min.set(t, i, r), this.max.set(o, p, a), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0,
      i = 1 / 0,
      r = 1 / 0,
      o = -1 / 0,
      p = -1 / 0,
      a = -1 / 0;
    for (let s = 0, u = e.count; s < u; s++) {
      const d = e.getX(s),
        l = e.getY(s),
        c = e.getZ(s);
      d < t && (t = d),
        l < i && (i = l),
        c < r && (r = c),
        d > o && (o = d),
        l > p && (p = l),
        c > a && (a = c);
    }
    return this.min.set(t, i, r), this.max.set(o, p, a), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Pr.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0)
      if (t && i.attributes != null && i.attributes.position !== void 0) {
        const o = i.attributes.position;
        for (let p = 0, a = o.count; p < a; p++)
          Pr.fromBufferAttribute(o, p).applyMatrix4(e.matrixWorld),
            this.expandByPoint(Pr);
      } else
        i.boundingBox === null && i.computeBoundingBox(),
          ef.copy(i.boundingBox),
          ef.applyMatrix4(e.matrixWorld),
          this.union(ef);
    const r = e.children;
    for (let o = 0, p = r.length; o < p; o++) this.expandByObject(r[o], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Pr),
      Pr.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(ra),
      ic.subVectors(this.max, ra),
      bs.subVectors(e.a, ra),
      Ss.subVectors(e.b, ra),
      ws.subVectors(e.c, ra),
      $i.subVectors(Ss, bs),
      Xi.subVectors(ws, Ss),
      Or.subVectors(bs, ws);
    let t = [
      0,
      -$i.z,
      $i.y,
      0,
      -Xi.z,
      Xi.y,
      0,
      -Or.z,
      Or.y,
      $i.z,
      0,
      -$i.x,
      Xi.z,
      0,
      -Xi.x,
      Or.z,
      0,
      -Or.x,
      -$i.y,
      $i.x,
      0,
      -Xi.y,
      Xi.x,
      0,
      -Or.y,
      Or.x,
      0,
    ];
    return !tf(t, bs, Ss, ws, ic) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !tf(t, bs, Ss, ws, ic))
      ? !1
      : (rc.crossVectors($i, Xi),
        (t = [rc.x, rc.y, rc.z]),
        tf(t, bs, Ss, ws, ic));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return Pr.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return (
      this.getCenter(e.center), (e.radius = this.getSize(Pr).length() * 0.5), e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ci[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ci[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ci[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ci[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ci[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ci[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ci[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ci[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ci),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ci = [
    new Q(),
    new Q(),
    new Q(),
    new Q(),
    new Q(),
    new Q(),
    new Q(),
    new Q(),
  ],
  Pr = new Q(),
  ef = new Do(),
  bs = new Q(),
  Ss = new Q(),
  ws = new Q(),
  $i = new Q(),
  Xi = new Q(),
  Or = new Q(),
  ra = new Q(),
  ic = new Q(),
  rc = new Q(),
  Lr = new Q();
function tf(n, e, t, i, r) {
  for (let o = 0, p = n.length - 3; o <= p; o += 3) {
    Lr.fromArray(n, o);
    const a =
        r.x * Math.abs(Lr.x) + r.y * Math.abs(Lr.y) + r.z * Math.abs(Lr.z),
      s = e.dot(Lr),
      u = t.dot(Lr),
      d = i.dot(Lr);
    if (Math.max(-Math.max(s, u, d), Math.min(s, u, d)) > a) return !1;
  }
  return !0;
}
const uM = new Do(),
  sa = new Q(),
  nf = new Q();
class Ro {
  constructor(e = new Q(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : uM.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let o = 0, p = e.length; o < p; o++)
      r = Math.max(r, i.distanceToSquared(e[o]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    sa.subVectors(e, this.center);
    const t = sa.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector(sa, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (nf.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(sa.copy(e.center).add(nf)),
            this.expandByPoint(sa.copy(e.center).sub(nf))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Mi = new Q(),
  rf = new Q(),
  sc = new Q(),
  Yi = new Q(),
  sf = new Q(),
  oc = new Q(),
  of = new Q();
class rm {
  constructor(e = new Q(), t = new Q(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Mi)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.direction).multiplyScalar(i).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Mi.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Mi.copy(this.direction).multiplyScalar(t).add(this.origin),
        Mi.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    rf.copy(e).add(t).multiplyScalar(0.5),
      sc.copy(t).sub(e).normalize(),
      Yi.copy(this.origin).sub(rf);
    const o = e.distanceTo(t) * 0.5,
      p = -this.direction.dot(sc),
      a = Yi.dot(this.direction),
      s = -Yi.dot(sc),
      u = Yi.lengthSq(),
      d = Math.abs(1 - p * p);
    let l, c, h, m;
    if (d > 0)
      if (((l = p * s - a), (c = p * a - s), (m = o * d), l >= 0))
        if (c >= -m)
          if (c <= m) {
            const g = 1 / d;
            (l *= g),
              (c *= g),
              (h = l * (l + p * c + 2 * a) + c * (p * l + c + 2 * s) + u);
          } else
            (c = o),
              (l = Math.max(0, -(p * c + a))),
              (h = -l * l + c * (c + 2 * s) + u);
        else
          (c = -o),
            (l = Math.max(0, -(p * c + a))),
            (h = -l * l + c * (c + 2 * s) + u);
      else
        c <= -m
          ? ((l = Math.max(0, -(-p * o + a))),
            (c = l > 0 ? -o : Math.min(Math.max(-o, -s), o)),
            (h = -l * l + c * (c + 2 * s) + u))
          : c <= m
          ? ((l = 0),
            (c = Math.min(Math.max(-o, -s), o)),
            (h = c * (c + 2 * s) + u))
          : ((l = Math.max(0, -(p * o + a))),
            (c = l > 0 ? o : Math.min(Math.max(-o, -s), o)),
            (h = -l * l + c * (c + 2 * s) + u));
    else
      (c = p > 0 ? -o : o),
        (l = Math.max(0, -(p * c + a))),
        (h = -l * l + c * (c + 2 * s) + u);
    return (
      i && i.copy(this.direction).multiplyScalar(l).add(this.origin),
      r && r.copy(sc).multiplyScalar(c).add(rf),
      h
    );
  }
  intersectSphere(e, t) {
    Mi.subVectors(e.center, this.origin);
    const i = Mi.dot(this.direction),
      r = Mi.dot(Mi) - i * i,
      o = e.radius * e.radius;
    if (r > o) return null;
    const p = Math.sqrt(o - r),
      a = i - p,
      s = i + p;
    return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, o, p, a, s;
    const u = 1 / this.direction.x,
      d = 1 / this.direction.y,
      l = 1 / this.direction.z,
      c = this.origin;
    return (
      u >= 0
        ? ((i = (e.min.x - c.x) * u), (r = (e.max.x - c.x) * u))
        : ((i = (e.max.x - c.x) * u), (r = (e.min.x - c.x) * u)),
      d >= 0
        ? ((o = (e.min.y - c.y) * d), (p = (e.max.y - c.y) * d))
        : ((o = (e.max.y - c.y) * d), (p = (e.min.y - c.y) * d)),
      i > p ||
      o > r ||
      ((o > i || isNaN(i)) && (i = o),
      (p < r || isNaN(r)) && (r = p),
      l >= 0
        ? ((a = (e.min.z - c.z) * l), (s = (e.max.z - c.z) * l))
        : ((a = (e.max.z - c.z) * l), (s = (e.min.z - c.z) * l)),
      i > s || a > r) ||
      ((a > i || i !== i) && (i = a), (s < r || r !== r) && (r = s), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Mi) !== null;
  }
  intersectTriangle(e, t, i, r, o) {
    sf.subVectors(t, e), oc.subVectors(i, e), of.crossVectors(sf, oc);
    let p = this.direction.dot(of),
      a;
    if (p > 0) {
      if (r) return null;
      a = 1;
    } else if (p < 0) (a = -1), (p = -p);
    else return null;
    Yi.subVectors(this.origin, e);
    const s = a * this.direction.dot(oc.crossVectors(Yi, oc));
    if (s < 0) return null;
    const u = a * this.direction.dot(sf.cross(Yi));
    if (u < 0 || s + u > p) return null;
    const d = -a * Yi.dot(of);
    return d < 0 ? null : this.at(d / p, o);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Xe {
  constructor() {
    (Xe.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  set(e, t, i, r, o, p, a, s, u, d, l, c, h, m, g, f) {
    const v = this.elements;
    return (
      (v[0] = e),
      (v[4] = t),
      (v[8] = i),
      (v[12] = r),
      (v[1] = o),
      (v[5] = p),
      (v[9] = a),
      (v[13] = s),
      (v[2] = u),
      (v[6] = d),
      (v[10] = l),
      (v[14] = c),
      (v[3] = h),
      (v[7] = m),
      (v[11] = g),
      (v[15] = f),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Xe().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / Ts.setFromMatrixColumn(e, 0).length(),
      o = 1 / Ts.setFromMatrixColumn(e, 1).length(),
      p = 1 / Ts.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * o),
      (t[5] = i[5] * o),
      (t[6] = i[6] * o),
      (t[7] = 0),
      (t[8] = i[8] * p),
      (t[9] = i[9] * p),
      (t[10] = i[10] * p),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      o = e.z,
      p = Math.cos(i),
      a = Math.sin(i),
      s = Math.cos(r),
      u = Math.sin(r),
      d = Math.cos(o),
      l = Math.sin(o);
    if (e.order === "XYZ") {
      const c = p * d,
        h = p * l,
        m = a * d,
        g = a * l;
      (t[0] = s * d),
        (t[4] = -s * l),
        (t[8] = u),
        (t[1] = h + m * u),
        (t[5] = c - g * u),
        (t[9] = -a * s),
        (t[2] = g - c * u),
        (t[6] = m + h * u),
        (t[10] = p * s);
    } else if (e.order === "YXZ") {
      const c = s * d,
        h = s * l,
        m = u * d,
        g = u * l;
      (t[0] = c + g * a),
        (t[4] = m * a - h),
        (t[8] = p * u),
        (t[1] = p * l),
        (t[5] = p * d),
        (t[9] = -a),
        (t[2] = h * a - m),
        (t[6] = g + c * a),
        (t[10] = p * s);
    } else if (e.order === "ZXY") {
      const c = s * d,
        h = s * l,
        m = u * d,
        g = u * l;
      (t[0] = c - g * a),
        (t[4] = -p * l),
        (t[8] = m + h * a),
        (t[1] = h + m * a),
        (t[5] = p * d),
        (t[9] = g - c * a),
        (t[2] = -p * u),
        (t[6] = a),
        (t[10] = p * s);
    } else if (e.order === "ZYX") {
      const c = p * d,
        h = p * l,
        m = a * d,
        g = a * l;
      (t[0] = s * d),
        (t[4] = m * u - h),
        (t[8] = c * u + g),
        (t[1] = s * l),
        (t[5] = g * u + c),
        (t[9] = h * u - m),
        (t[2] = -u),
        (t[6] = a * s),
        (t[10] = p * s);
    } else if (e.order === "YZX") {
      const c = p * s,
        h = p * u,
        m = a * s,
        g = a * u;
      (t[0] = s * d),
        (t[4] = g - c * l),
        (t[8] = m * l + h),
        (t[1] = l),
        (t[5] = p * d),
        (t[9] = -a * d),
        (t[2] = -u * d),
        (t[6] = h * l + m),
        (t[10] = c - g * l);
    } else if (e.order === "XZY") {
      const c = p * s,
        h = p * u,
        m = a * s,
        g = a * u;
      (t[0] = s * d),
        (t[4] = -l),
        (t[8] = u * d),
        (t[1] = c * l + g),
        (t[5] = p * d),
        (t[9] = h * l - m),
        (t[2] = m * l - h),
        (t[6] = a * d),
        (t[10] = g * l + c);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(hM, e, fM);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      Tn.subVectors(e, t),
      Tn.lengthSq() === 0 && (Tn.z = 1),
      Tn.normalize(),
      Ki.crossVectors(i, Tn),
      Ki.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (Tn.x += 1e-4) : (Tn.z += 1e-4),
        Tn.normalize(),
        Ki.crossVectors(i, Tn)),
      Ki.normalize(),
      ac.crossVectors(Tn, Ki),
      (r[0] = Ki.x),
      (r[4] = ac.x),
      (r[8] = Tn.x),
      (r[1] = Ki.y),
      (r[5] = ac.y),
      (r[9] = Tn.y),
      (r[2] = Ki.z),
      (r[6] = ac.z),
      (r[10] = Tn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      o = this.elements,
      p = i[0],
      a = i[4],
      s = i[8],
      u = i[12],
      d = i[1],
      l = i[5],
      c = i[9],
      h = i[13],
      m = i[2],
      g = i[6],
      f = i[10],
      v = i[14],
      y = i[3],
      _ = i[7],
      x = i[11],
      b = i[15],
      S = r[0],
      T = r[4],
      w = r[8],
      P = r[12],
      F = r[1],
      V = r[5],
      J = r[9],
      z = r[13],
      B = r[2],
      G = r[6],
      ie = r[10],
      re = r[14],
      j = r[3],
      C = r[7],
      R = r[11],
      A = r[15];
    return (
      (o[0] = p * S + a * F + s * B + u * j),
      (o[4] = p * T + a * V + s * G + u * C),
      (o[8] = p * w + a * J + s * ie + u * R),
      (o[12] = p * P + a * z + s * re + u * A),
      (o[1] = d * S + l * F + c * B + h * j),
      (o[5] = d * T + l * V + c * G + h * C),
      (o[9] = d * w + l * J + c * ie + h * R),
      (o[13] = d * P + l * z + c * re + h * A),
      (o[2] = m * S + g * F + f * B + v * j),
      (o[6] = m * T + g * V + f * G + v * C),
      (o[10] = m * w + g * J + f * ie + v * R),
      (o[14] = m * P + g * z + f * re + v * A),
      (o[3] = y * S + _ * F + x * B + b * j),
      (o[7] = y * T + _ * V + x * G + b * C),
      (o[11] = y * w + _ * J + x * ie + b * R),
      (o[15] = y * P + _ * z + x * re + b * A),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      o = e[12],
      p = e[1],
      a = e[5],
      s = e[9],
      u = e[13],
      d = e[2],
      l = e[6],
      c = e[10],
      h = e[14],
      m = e[3],
      g = e[7],
      f = e[11],
      v = e[15];
    return (
      m *
        (+o * s * l -
          r * u * l -
          o * a * c +
          i * u * c +
          r * a * h -
          i * s * h) +
      g *
        (+t * s * h -
          t * u * c +
          o * p * c -
          r * p * h +
          r * u * d -
          o * s * d) +
      f *
        (+t * u * l -
          t * a * h -
          o * p * l +
          i * p * h +
          o * a * d -
          i * u * d) +
      v *
        (-r * a * d - t * s * l + t * a * c + r * p * l - i * p * c + i * s * d)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      o = e[3],
      p = e[4],
      a = e[5],
      s = e[6],
      u = e[7],
      d = e[8],
      l = e[9],
      c = e[10],
      h = e[11],
      m = e[12],
      g = e[13],
      f = e[14],
      v = e[15],
      y = l * f * u - g * c * u + g * s * h - a * f * h - l * s * v + a * c * v,
      _ = m * c * u - d * f * u - m * s * h + p * f * h + d * s * v - p * c * v,
      x = d * g * u - m * l * u + m * a * h - p * g * h - d * a * v + p * l * v,
      b = m * l * s - d * g * s - m * a * c + p * g * c + d * a * f - p * l * f,
      S = t * y + i * _ + r * x + o * b;
    if (S === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / S;
    return (
      (e[0] = y * T),
      (e[1] =
        (g * c * o -
          l * f * o -
          g * r * h +
          i * f * h +
          l * r * v -
          i * c * v) *
        T),
      (e[2] =
        (a * f * o -
          g * s * o +
          g * r * u -
          i * f * u -
          a * r * v +
          i * s * v) *
        T),
      (e[3] =
        (l * s * o -
          a * c * o -
          l * r * u +
          i * c * u +
          a * r * h -
          i * s * h) *
        T),
      (e[4] = _ * T),
      (e[5] =
        (d * f * o -
          m * c * o +
          m * r * h -
          t * f * h -
          d * r * v +
          t * c * v) *
        T),
      (e[6] =
        (m * s * o -
          p * f * o -
          m * r * u +
          t * f * u +
          p * r * v -
          t * s * v) *
        T),
      (e[7] =
        (p * c * o -
          d * s * o +
          d * r * u -
          t * c * u -
          p * r * h +
          t * s * h) *
        T),
      (e[8] = x * T),
      (e[9] =
        (m * l * o -
          d * g * o -
          m * i * h +
          t * g * h +
          d * i * v -
          t * l * v) *
        T),
      (e[10] =
        (p * g * o -
          m * a * o +
          m * i * u -
          t * g * u -
          p * i * v +
          t * a * v) *
        T),
      (e[11] =
        (d * a * o -
          p * l * o -
          d * i * u +
          t * l * u +
          p * i * h -
          t * a * h) *
        T),
      (e[12] = b * T),
      (e[13] =
        (d * g * r -
          m * l * r +
          m * i * c -
          t * g * c -
          d * i * f +
          t * l * f) *
        T),
      (e[14] =
        (m * a * r -
          p * g * r -
          m * i * s +
          t * g * s +
          p * i * f -
          t * a * f) *
        T),
      (e[15] =
        (p * l * r -
          d * a * r +
          d * i * s -
          t * l * s -
          p * i * c +
          t * a * c) *
        T),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      o = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= o),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= o),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= o),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= o),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      o = 1 - i,
      p = e.x,
      a = e.y,
      s = e.z,
      u = o * p,
      d = o * a;
    return (
      this.set(
        u * p + i,
        u * a - r * s,
        u * s + r * a,
        0,
        u * a + r * s,
        d * a + i,
        d * s - r * p,
        0,
        u * s - r * a,
        d * s + r * p,
        o * s * s + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, o, p) {
    return this.set(1, i, o, 0, e, 1, p, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements,
      o = t._x,
      p = t._y,
      a = t._z,
      s = t._w,
      u = o + o,
      d = p + p,
      l = a + a,
      c = o * u,
      h = o * d,
      m = o * l,
      g = p * d,
      f = p * l,
      v = a * l,
      y = s * u,
      _ = s * d,
      x = s * l,
      b = i.x,
      S = i.y,
      T = i.z;
    return (
      (r[0] = (1 - (g + v)) * b),
      (r[1] = (h + x) * b),
      (r[2] = (m - _) * b),
      (r[3] = 0),
      (r[4] = (h - x) * S),
      (r[5] = (1 - (c + v)) * S),
      (r[6] = (f + y) * S),
      (r[7] = 0),
      (r[8] = (m + _) * T),
      (r[9] = (f - y) * T),
      (r[10] = (1 - (c + g)) * T),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let o = Ts.set(r[0], r[1], r[2]).length();
    const p = Ts.set(r[4], r[5], r[6]).length(),
      a = Ts.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (o = -o),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Qn.copy(this);
    const u = 1 / o,
      d = 1 / p,
      l = 1 / a;
    return (
      (Qn.elements[0] *= u),
      (Qn.elements[1] *= u),
      (Qn.elements[2] *= u),
      (Qn.elements[4] *= d),
      (Qn.elements[5] *= d),
      (Qn.elements[6] *= d),
      (Qn.elements[8] *= l),
      (Qn.elements[9] *= l),
      (Qn.elements[10] *= l),
      t.setFromRotationMatrix(Qn),
      (i.x = o),
      (i.y = p),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, o, p) {
    const a = this.elements,
      s = (2 * o) / (t - e),
      u = (2 * o) / (i - r),
      d = (t + e) / (t - e),
      l = (i + r) / (i - r),
      c = -(p + o) / (p - o),
      h = (-2 * p * o) / (p - o);
    return (
      (a[0] = s),
      (a[4] = 0),
      (a[8] = d),
      (a[12] = 0),
      (a[1] = 0),
      (a[5] = u),
      (a[9] = l),
      (a[13] = 0),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = c),
      (a[14] = h),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = -1),
      (a[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, o, p) {
    const a = this.elements,
      s = 1 / (t - e),
      u = 1 / (i - r),
      d = 1 / (p - o),
      l = (t + e) * s,
      c = (i + r) * u,
      h = (p + o) * d;
    return (
      (a[0] = 2 * s),
      (a[4] = 0),
      (a[8] = 0),
      (a[12] = -l),
      (a[1] = 0),
      (a[5] = 2 * u),
      (a[9] = 0),
      (a[13] = -c),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = -2 * d),
      (a[14] = -h),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = 0),
      (a[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const Ts = new Q(),
  Qn = new Xe(),
  hM = new Q(0, 0, 0),
  fM = new Q(1, 1, 1),
  Ki = new Q(),
  ac = new Q(),
  Tn = new Q(),
  Wv = new Xe(),
  Gv = new xi();
class bl {
  constructor(e = 0, t = 0, i = 0, r = bl.DefaultOrder) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      o = r[0],
      p = r[4],
      a = r[8],
      s = r[1],
      u = r[5],
      d = r[9],
      l = r[2],
      c = r[6],
      h = r[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Jt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-d, h)), (this._z = Math.atan2(-p, o)))
            : ((this._x = Math.atan2(c, u)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Jt(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(a, h)), (this._z = Math.atan2(s, u)))
            : ((this._y = Math.atan2(-l, o)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Jt(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._y = Math.atan2(-l, h)), (this._z = Math.atan2(-p, u)))
            : ((this._y = 0), (this._z = Math.atan2(s, o)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Jt(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(c, h)), (this._z = Math.atan2(s, o)))
            : ((this._x = 0), (this._z = Math.atan2(-p, u)));
        break;
      case "YZX":
        (this._z = Math.asin(Jt(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(-d, u)), (this._y = Math.atan2(-l, o)))
            : ((this._x = 0), (this._y = Math.atan2(a, h)));
        break;
      case "XZY":
        (this._z = Math.asin(-Jt(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._x = Math.atan2(c, u)), (this._y = Math.atan2(a, o)))
            : ((this._x = Math.atan2(-d, h)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      Wv.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Wv, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Gv.setFromEuler(this), this.setFromQuaternion(Gv, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error(
      "THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead"
    );
  }
}
bl.DefaultOrder = "XYZ";
bl.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class zb {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let dM = 0;
const $v = new Q(),
  Cs = new xi(),
  Ei = new Xe(),
  lc = new Q(),
  oa = new Q(),
  pM = new Q(),
  mM = new xi(),
  Xv = new Q(1, 0, 0),
  Yv = new Q(0, 1, 0),
  Kv = new Q(0, 0, 1),
  gM = { type: "added" },
  qv = { type: "removed" };
class St extends fs {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: dM++ }),
      (this.uuid = oi()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = St.DefaultUp.clone());
    const e = new Q(),
      t = new bl(),
      i = new xi(),
      r = new Q(1, 1, 1);
    function o() {
      i.setFromEuler(t, !1);
    }
    function p() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(o),
      i._onChange(p),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new Xe() },
        normalMatrix: { value: new An() },
      }),
      (this.matrix = new Xe()),
      (this.matrixWorld = new Xe()),
      (this.matrixAutoUpdate = St.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = St.DefaultMatrixWorldAutoUpdate),
      (this.layers = new zb()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Cs.setFromAxisAngle(e, t), this.quaternion.multiply(Cs), this;
  }
  rotateOnWorldAxis(e, t) {
    return Cs.setFromAxisAngle(e, t), this.quaternion.premultiply(Cs), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Xv, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Yv, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Kv, e);
  }
  translateOnAxis(e, t) {
    return (
      $v.copy(e).applyQuaternion(this.quaternion),
      this.position.add($v.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Xv, e);
  }
  translateY(e) {
    return this.translateOnAxis(Yv, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Kv, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Ei.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? lc.copy(e) : lc.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      oa.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Ei.lookAt(oa, lc, this.up)
        : Ei.lookAt(lc, oa, this.up),
      this.quaternion.setFromRotationMatrix(Ei),
      r &&
        (Ei.extractRotation(r.matrixWorld),
        Cs.setFromRotationMatrix(Ei),
        this.quaternion.premultiply(Cs.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(gM))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(qv)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(qv);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Ei.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Ei.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Ei),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const p = this.children[i].getObjectByProperty(e, t);
      if (p !== void 0) return p;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let r = 0, o = this.children.length; r < o; r++) {
      const p = this.children[r].getObjectsByProperty(e, t);
      p.length > 0 && (i = i.concat(p));
    }
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(oa, e, pM), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(oa, mM, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      (o.matrixWorldAutoUpdate === !0 || e === !0) && o.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const r = this.children;
      for (let o = 0, p = r.length; o < p; o++) {
        const a = r[o];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON()));
    function o(a, s) {
      return a[s.uuid] === void 0 && (a[s.uuid] = s.toJSON(e)), s.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = o(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const s = a.shapes;
        if (Array.isArray(s))
          for (let u = 0, d = s.length; u < d; u++) {
            const l = s[u];
            o(e.shapes, l);
          }
        else o(e.shapes, s);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (o(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let s = 0, u = this.material.length; s < u; s++)
          a.push(o(e.materials, this.material[s]));
        r.material = a;
      } else r.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const s = this.animations[a];
        r.animations.push(o(e.animations, s));
      }
    }
    if (t) {
      const a = p(e.geometries),
        s = p(e.materials),
        u = p(e.textures),
        d = p(e.images),
        l = p(e.shapes),
        c = p(e.skeletons),
        h = p(e.animations),
        m = p(e.nodes);
      a.length > 0 && (i.geometries = a),
        s.length > 0 && (i.materials = s),
        u.length > 0 && (i.textures = u),
        d.length > 0 && (i.images = d),
        l.length > 0 && (i.shapes = l),
        c.length > 0 && (i.skeletons = c),
        h.length > 0 && (i.animations = h),
        m.length > 0 && (i.nodes = m);
    }
    return (i.object = r), i;
    function p(a) {
      const s = [];
      for (const u in a) {
        const d = a[u];
        delete d.metadata, s.push(d);
      }
      return s;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
St.DefaultUp = new Q(0, 1, 0);
St.DefaultMatrixAutoUpdate = !0;
St.DefaultMatrixWorldAutoUpdate = !0;
const ei = new Q(),
  Ai = new Q(),
  af = new Q(),
  Pi = new Q(),
  Ms = new Q(),
  Es = new Q(),
  Zv = new Q(),
  lf = new Q(),
  cf = new Q(),
  uf = new Q();
class Ri {
  constructor(e = new Q(), t = new Q(), i = new Q()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), ei.subVectors(e, t), r.cross(ei);
    const o = r.lengthSq();
    return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, o) {
    ei.subVectors(r, t), Ai.subVectors(i, t), af.subVectors(e, t);
    const p = ei.dot(ei),
      a = ei.dot(Ai),
      s = ei.dot(af),
      u = Ai.dot(Ai),
      d = Ai.dot(af),
      l = p * u - a * a;
    if (l === 0) return o.set(-2, -1, -1);
    const c = 1 / l,
      h = (u * s - a * d) * c,
      m = (p * d - a * s) * c;
    return o.set(1 - h - m, m, h);
  }
  static containsPoint(e, t, i, r) {
    return (
      this.getBarycoord(e, t, i, r, Pi),
      Pi.x >= 0 && Pi.y >= 0 && Pi.x + Pi.y <= 1
    );
  }
  static getUV(e, t, i, r, o, p, a, s) {
    return (
      this.getBarycoord(e, t, i, r, Pi),
      s.set(0, 0),
      s.addScaledVector(o, Pi.x),
      s.addScaledVector(p, Pi.y),
      s.addScaledVector(a, Pi.z),
      s
    );
  }
  static isFrontFacing(e, t, i, r) {
    return ei.subVectors(i, t), Ai.subVectors(e, t), ei.cross(Ai).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      ei.subVectors(this.c, this.b),
      Ai.subVectors(this.a, this.b),
      ei.cross(Ai).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ri.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ri.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, r, o) {
    return Ri.getUV(e, this.a, this.b, this.c, t, i, r, o);
  }
  containsPoint(e) {
    return Ri.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ri.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      o = this.c;
    let p, a;
    Ms.subVectors(r, i), Es.subVectors(o, i), lf.subVectors(e, i);
    const s = Ms.dot(lf),
      u = Es.dot(lf);
    if (s <= 0 && u <= 0) return t.copy(i);
    cf.subVectors(e, r);
    const d = Ms.dot(cf),
      l = Es.dot(cf);
    if (d >= 0 && l <= d) return t.copy(r);
    const c = s * l - d * u;
    if (c <= 0 && s >= 0 && d <= 0)
      return (p = s / (s - d)), t.copy(i).addScaledVector(Ms, p);
    uf.subVectors(e, o);
    const h = Ms.dot(uf),
      m = Es.dot(uf);
    if (m >= 0 && h <= m) return t.copy(o);
    const g = h * u - s * m;
    if (g <= 0 && u >= 0 && m <= 0)
      return (a = u / (u - m)), t.copy(i).addScaledVector(Es, a);
    const f = d * m - h * l;
    if (f <= 0 && l - d >= 0 && h - m >= 0)
      return (
        Zv.subVectors(o, r),
        (a = (l - d) / (l - d + (h - m))),
        t.copy(r).addScaledVector(Zv, a)
      );
    const v = 1 / (f + g + c);
    return (
      (p = g * v),
      (a = c * v),
      t.copy(i).addScaledVector(Ms, p).addScaledVector(Es, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let vM = 0;
class Ln extends fs {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: vM++ }),
      (this.uuid = oi()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = ro),
      (this.side = _r),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = Eb),
      (this.blendDst = Ab),
      (this.blendEquation = ks),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Nd),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = XC),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Yh),
      (this.stencilZFail = Yh),
      (this.stencilZPass = Yh),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            "THREE." +
              this.type +
              ": '" +
              t +
              "' is not a property of this material."
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== ro && (i.blending = this.blending),
      this.side !== _r && (i.side = this.side),
      this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = this.transparent),
      (i.depthFunc = this.depthFunc),
      (i.depthTest = this.depthTest),
      (i.depthWrite = this.depthWrite),
      (i.colorWrite = this.colorWrite),
      (i.stencilWrite = this.stencilWrite),
      (i.stencilWriteMask = this.stencilWriteMask),
      (i.stencilFunc = this.stencilFunc),
      (i.stencilRef = this.stencilRef),
      (i.stencilFuncMask = this.stencilFuncMask),
      (i.stencilFail = this.stencilFail),
      (i.stencilZFail = this.stencilZFail),
      (i.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (i.premultipliedAlpha = this.premultipliedAlpha),
      this.wireframe === !0 && (i.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = this.flatShading),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(o) {
      const p = [];
      for (const a in o) {
        const s = o[a];
        delete s.metadata, p.push(s);
      }
      return p;
    }
    if (t) {
      const o = r(e.textures),
        p = r(e.images);
      o.length > 0 && (i.textures = o), p.length > 0 && (i.images = p);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let o = 0; o !== r; ++o) i[o] = t[o].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Gr extends Ln {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new je(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = tm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Pt = new Q(),
  cc = new ze();
class Gt {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = jd),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let r = 0, o = this.itemSize; r < o; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        cc.fromBufferAttribute(this, t),
          cc.applyMatrix3(e),
          this.setXY(t, cc.x, cc.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Pt.fromBufferAttribute(this, t),
          Pt.applyMatrix3(e),
          this.setXYZ(t, Pt.x, Pt.y, Pt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Pt.fromBufferAttribute(this, t),
        Pt.applyMatrix4(e),
        this.setXYZ(t, Pt.x, Pt.y, Pt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Pt.fromBufferAttribute(this, t),
        Pt.applyNormalMatrix(e),
        this.setXYZ(t, Pt.x, Pt.y, Pt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Pt.fromBufferAttribute(this, t),
        Pt.transformDirection(e),
        this.setXYZ(t, Pt.x, Pt.y, Pt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Fi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = ct(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Fi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = ct(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Fi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = ct(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Fi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = ct(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = ct(t, this.array)), (i = ct(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = ct(t, this.array)),
        (i = ct(i, this.array)),
        (r = ct(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = ct(t, this.array)),
        (i = ct(i, this.array)),
        (r = ct(r, this.array)),
        (o = ct(o, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = o),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== jd && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
  copyColorsArray() {
    console.error(
      "THREE.BufferAttribute: copyColorsArray() was removed in r144."
    );
  }
  copyVector2sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
    );
  }
  copyVector3sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
    );
  }
  copyVector4sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
    );
  }
}
class Ub extends Gt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class jb extends Gt {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class an extends Gt {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let yM = 0;
const Bn = new Xe(),
  hf = new St(),
  As = new Q(),
  Cn = new Do(),
  aa = new Do(),
  Nt = new Q();
class Rn extends fs {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: yM++ }),
      (this.uuid = oi()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (Ib(e) ? jb : Ub)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const o = new An().getNormalMatrix(e);
      i.applyNormalMatrix(o), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Bn.makeRotationFromQuaternion(e), this.applyMatrix4(Bn), this;
  }
  rotateX(e) {
    return Bn.makeRotationX(e), this.applyMatrix4(Bn), this;
  }
  rotateY(e) {
    return Bn.makeRotationY(e), this.applyMatrix4(Bn), this;
  }
  rotateZ(e) {
    return Bn.makeRotationZ(e), this.applyMatrix4(Bn), this;
  }
  translate(e, t, i) {
    return Bn.makeTranslation(e, t, i), this.applyMatrix4(Bn), this;
  }
  scale(e, t, i) {
    return Bn.makeScale(e, t, i), this.applyMatrix4(Bn), this;
  }
  lookAt(e) {
    return hf.lookAt(e), hf.updateMatrix(), this.applyMatrix4(hf.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(As).negate(),
      this.translate(As.x, As.y, As.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      t.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new an(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Do());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new Q(-1 / 0, -1 / 0, -1 / 0),
          new Q(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const o = t[i];
          Cn.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Nt.addVectors(this.boundingBox.min, Cn.min),
                this.boundingBox.expandByPoint(Nt),
                Nt.addVectors(this.boundingBox.max, Cn.max),
                this.boundingBox.expandByPoint(Nt))
              : (this.boundingBox.expandByPoint(Cn.min),
                this.boundingBox.expandByPoint(Cn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ro());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new Q(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Cn.setFromBufferAttribute(e), t))
        for (let o = 0, p = t.length; o < p; o++) {
          const a = t[o];
          aa.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Nt.addVectors(Cn.min, aa.min),
                Cn.expandByPoint(Nt),
                Nt.addVectors(Cn.max, aa.max),
                Cn.expandByPoint(Nt))
              : (Cn.expandByPoint(aa.min), Cn.expandByPoint(aa.max));
        }
      Cn.getCenter(i);
      let r = 0;
      for (let o = 0, p = e.count; o < p; o++)
        Nt.fromBufferAttribute(e, o),
          (r = Math.max(r, i.distanceToSquared(Nt)));
      if (t)
        for (let o = 0, p = t.length; o < p; o++) {
          const a = t[o],
            s = this.morphTargetsRelative;
          for (let u = 0, d = a.count; u < d; u++)
            Nt.fromBufferAttribute(a, u),
              s && (As.fromBufferAttribute(e, u), Nt.add(As)),
              (r = Math.max(r, i.distanceToSquared(Nt)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = e.array,
      r = t.position.array,
      o = t.normal.array,
      p = t.uv.array,
      a = r.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Gt(new Float32Array(4 * a), 4));
    const s = this.getAttribute("tangent").array,
      u = [],
      d = [];
    for (let F = 0; F < a; F++) (u[F] = new Q()), (d[F] = new Q());
    const l = new Q(),
      c = new Q(),
      h = new Q(),
      m = new ze(),
      g = new ze(),
      f = new ze(),
      v = new Q(),
      y = new Q();
    function _(F, V, J) {
      l.fromArray(r, F * 3),
        c.fromArray(r, V * 3),
        h.fromArray(r, J * 3),
        m.fromArray(p, F * 2),
        g.fromArray(p, V * 2),
        f.fromArray(p, J * 2),
        c.sub(l),
        h.sub(l),
        g.sub(m),
        f.sub(m);
      const z = 1 / (g.x * f.y - f.x * g.y);
      isFinite(z) &&
        (v
          .copy(c)
          .multiplyScalar(f.y)
          .addScaledVector(h, -g.y)
          .multiplyScalar(z),
        y
          .copy(h)
          .multiplyScalar(g.x)
          .addScaledVector(c, -f.x)
          .multiplyScalar(z),
        u[F].add(v),
        u[V].add(v),
        u[J].add(v),
        d[F].add(y),
        d[V].add(y),
        d[J].add(y));
    }
    let x = this.groups;
    x.length === 0 && (x = [{ start: 0, count: i.length }]);
    for (let F = 0, V = x.length; F < V; ++F) {
      const J = x[F],
        z = J.start,
        B = J.count;
      for (let G = z, ie = z + B; G < ie; G += 3)
        _(i[G + 0], i[G + 1], i[G + 2]);
    }
    const b = new Q(),
      S = new Q(),
      T = new Q(),
      w = new Q();
    function P(F) {
      T.fromArray(o, F * 3), w.copy(T);
      const V = u[F];
      b.copy(V),
        b.sub(T.multiplyScalar(T.dot(V))).normalize(),
        S.crossVectors(w, V);
      const z = S.dot(d[F]) < 0 ? -1 : 1;
      (s[F * 4] = b.x),
        (s[F * 4 + 1] = b.y),
        (s[F * 4 + 2] = b.z),
        (s[F * 4 + 3] = z);
    }
    for (let F = 0, V = x.length; F < V; ++F) {
      const J = x[F],
        z = J.start,
        B = J.count;
      for (let G = z, ie = z + B; G < ie; G += 3)
        P(i[G + 0]), P(i[G + 1]), P(i[G + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new Gt(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let c = 0, h = i.count; c < h; c++) i.setXYZ(c, 0, 0, 0);
      const r = new Q(),
        o = new Q(),
        p = new Q(),
        a = new Q(),
        s = new Q(),
        u = new Q(),
        d = new Q(),
        l = new Q();
      if (e)
        for (let c = 0, h = e.count; c < h; c += 3) {
          const m = e.getX(c + 0),
            g = e.getX(c + 1),
            f = e.getX(c + 2);
          r.fromBufferAttribute(t, m),
            o.fromBufferAttribute(t, g),
            p.fromBufferAttribute(t, f),
            d.subVectors(p, o),
            l.subVectors(r, o),
            d.cross(l),
            a.fromBufferAttribute(i, m),
            s.fromBufferAttribute(i, g),
            u.fromBufferAttribute(i, f),
            a.add(d),
            s.add(d),
            u.add(d),
            i.setXYZ(m, a.x, a.y, a.z),
            i.setXYZ(g, s.x, s.y, s.z),
            i.setXYZ(f, u.x, u.y, u.z);
        }
      else
        for (let c = 0, h = t.count; c < h; c += 3)
          r.fromBufferAttribute(t, c + 0),
            o.fromBufferAttribute(t, c + 1),
            p.fromBufferAttribute(t, c + 2),
            d.subVectors(p, o),
            l.subVectors(r, o),
            d.cross(l),
            i.setXYZ(c + 0, d.x, d.y, d.z),
            i.setXYZ(c + 1, d.x, d.y, d.z),
            i.setXYZ(c + 2, d.x, d.y, d.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  merge() {
    return (
      console.error(
        "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."
      ),
      this
    );
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      Nt.fromBufferAttribute(e, t),
        Nt.normalize(),
        e.setXYZ(t, Nt.x, Nt.y, Nt.z);
  }
  toNonIndexed() {
    function e(a, s) {
      const u = a.array,
        d = a.itemSize,
        l = a.normalized,
        c = new u.constructor(s.length * d);
      let h = 0,
        m = 0;
      for (let g = 0, f = s.length; g < f; g++) {
        a.isInterleavedBufferAttribute
          ? (h = s[g] * a.data.stride + a.offset)
          : (h = s[g] * d);
        for (let v = 0; v < d; v++) c[m++] = u[h++];
      }
      return new Gt(c, d, l);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new Rn(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const s = r[a],
        u = e(s, i);
      t.setAttribute(a, u);
    }
    const o = this.morphAttributes;
    for (const a in o) {
      const s = [],
        u = o[a];
      for (let d = 0, l = u.length; d < l; d++) {
        const c = u[d],
          h = e(c, i);
        s.push(h);
      }
      t.morphAttributes[a] = s;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const p = this.groups;
    for (let a = 0, s = p.length; a < s; a++) {
      const u = p[a];
      t.addGroup(u.start, u.count, u.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const s = this.parameters;
      for (const u in s) s[u] !== void 0 && (e[u] = s[u]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const s in i) {
      const u = i[s];
      e.data.attributes[s] = u.toJSON(e.data);
    }
    const r = {};
    let o = !1;
    for (const s in this.morphAttributes) {
      const u = this.morphAttributes[s],
        d = [];
      for (let l = 0, c = u.length; l < c; l++) {
        const h = u[l];
        d.push(h.toJSON(e.data));
      }
      d.length > 0 && ((r[s] = d), (o = !0));
    }
    o &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const p = this.groups;
    p.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(p)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const u in r) {
      const d = r[u];
      this.setAttribute(u, d.clone(t));
    }
    const o = e.morphAttributes;
    for (const u in o) {
      const d = [],
        l = o[u];
      for (let c = 0, h = l.length; c < h; c++) d.push(l[c].clone(t));
      this.morphAttributes[u] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const p = e.groups;
    for (let u = 0, d = p.length; u < d; u++) {
      const l = p[u];
      this.addGroup(l.start, l.count, l.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const s = e.boundingSphere;
    return (
      s !== null && (this.boundingSphere = s.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      e.parameters !== void 0 &&
        (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Jv = new Xe(),
  Ps = new rm(),
  ff = new Ro(),
  la = new Q(),
  ca = new Q(),
  ua = new Q(),
  df = new Q(),
  uc = new Q(),
  hc = new ze(),
  fc = new ze(),
  dc = new ze(),
  pf = new Q(),
  pc = new Q();
class vn extends St {
  constructor(e = new Rn(), t = new Gr()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, p = r.length; o < p; o++) {
          const a = r[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      o = i.morphAttributes.position,
      p = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (o && a) {
      uc.set(0, 0, 0);
      for (let s = 0, u = o.length; s < u; s++) {
        const d = a[s],
          l = o[s];
        d !== 0 &&
          (df.fromBufferAttribute(l, e),
          p ? uc.addScaledVector(df, d) : uc.addScaledVector(df.sub(t), d));
      }
      t.add(uc);
    }
    return this.isSkinnedMesh && this.boneTransform(e, t), t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      o = this.matrixWorld;
    if (
      r === void 0 ||
      (i.boundingSphere === null && i.computeBoundingSphere(),
      ff.copy(i.boundingSphere),
      ff.applyMatrix4(o),
      e.ray.intersectsSphere(ff) === !1) ||
      (Jv.copy(o).invert(),
      Ps.copy(e.ray).applyMatrix4(Jv),
      i.boundingBox !== null && Ps.intersectsBox(i.boundingBox) === !1)
    )
      return;
    let p;
    const a = i.index,
      s = i.attributes.position,
      u = i.attributes.uv,
      d = i.attributes.uv2,
      l = i.groups,
      c = i.drawRange;
    if (a !== null)
      if (Array.isArray(r))
        for (let h = 0, m = l.length; h < m; h++) {
          const g = l[h],
            f = r[g.materialIndex],
            v = Math.max(g.start, c.start),
            y = Math.min(
              a.count,
              Math.min(g.start + g.count, c.start + c.count)
            );
          for (let _ = v, x = y; _ < x; _ += 3) {
            const b = a.getX(_),
              S = a.getX(_ + 1),
              T = a.getX(_ + 2);
            (p = mc(this, f, e, Ps, u, d, b, S, T)),
              p &&
                ((p.faceIndex = Math.floor(_ / 3)),
                (p.face.materialIndex = g.materialIndex),
                t.push(p));
          }
        }
      else {
        const h = Math.max(0, c.start),
          m = Math.min(a.count, c.start + c.count);
        for (let g = h, f = m; g < f; g += 3) {
          const v = a.getX(g),
            y = a.getX(g + 1),
            _ = a.getX(g + 2);
          (p = mc(this, r, e, Ps, u, d, v, y, _)),
            p && ((p.faceIndex = Math.floor(g / 3)), t.push(p));
        }
      }
    else if (s !== void 0)
      if (Array.isArray(r))
        for (let h = 0, m = l.length; h < m; h++) {
          const g = l[h],
            f = r[g.materialIndex],
            v = Math.max(g.start, c.start),
            y = Math.min(
              s.count,
              Math.min(g.start + g.count, c.start + c.count)
            );
          for (let _ = v, x = y; _ < x; _ += 3) {
            const b = _,
              S = _ + 1,
              T = _ + 2;
            (p = mc(this, f, e, Ps, u, d, b, S, T)),
              p &&
                ((p.faceIndex = Math.floor(_ / 3)),
                (p.face.materialIndex = g.materialIndex),
                t.push(p));
          }
        }
      else {
        const h = Math.max(0, c.start),
          m = Math.min(s.count, c.start + c.count);
        for (let g = h, f = m; g < f; g += 3) {
          const v = g,
            y = g + 1,
            _ = g + 2;
          (p = mc(this, r, e, Ps, u, d, v, y, _)),
            p && ((p.faceIndex = Math.floor(g / 3)), t.push(p));
        }
      }
  }
}
function _M(n, e, t, i, r, o, p, a) {
  let s;
  if (
    (e.side === Xn
      ? (s = i.intersectTriangle(p, o, r, !0, a))
      : (s = i.intersectTriangle(r, o, p, e.side === _r, a)),
    s === null)
  )
    return null;
  pc.copy(a), pc.applyMatrix4(n.matrixWorld);
  const u = t.ray.origin.distanceTo(pc);
  return u < t.near || u > t.far
    ? null
    : { distance: u, point: pc.clone(), object: n };
}
function mc(n, e, t, i, r, o, p, a, s) {
  n.getVertexPosition(p, la),
    n.getVertexPosition(a, ca),
    n.getVertexPosition(s, ua);
  const u = _M(n, e, t, i, la, ca, ua, pf);
  if (u) {
    r &&
      (hc.fromBufferAttribute(r, p),
      fc.fromBufferAttribute(r, a),
      dc.fromBufferAttribute(r, s),
      (u.uv = Ri.getUV(pf, la, ca, ua, hc, fc, dc, new ze()))),
      o &&
        (hc.fromBufferAttribute(o, p),
        fc.fromBufferAttribute(o, a),
        dc.fromBufferAttribute(o, s),
        (u.uv2 = Ri.getUV(pf, la, ca, ua, hc, fc, dc, new ze())));
    const d = { a: p, b: a, c: s, normal: new Q(), materialIndex: 0 };
    Ri.getNormal(la, ca, ua, d.normal), (u.face = d);
  }
  return u;
}
class Sl extends Rn {
  constructor(e = 1, t = 1, i = 1, r = 1, o = 1, p = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: o,
        depthSegments: p,
      });
    const a = this;
    (r = Math.floor(r)), (o = Math.floor(o)), (p = Math.floor(p));
    const s = [],
      u = [],
      d = [],
      l = [];
    let c = 0,
      h = 0;
    m("z", "y", "x", -1, -1, i, t, e, p, o, 0),
      m("z", "y", "x", 1, -1, i, t, -e, p, o, 1),
      m("x", "z", "y", 1, 1, e, i, t, r, p, 2),
      m("x", "z", "y", 1, -1, e, i, -t, r, p, 3),
      m("x", "y", "z", 1, -1, e, t, i, r, o, 4),
      m("x", "y", "z", -1, -1, e, t, -i, r, o, 5),
      this.setIndex(s),
      this.setAttribute("position", new an(u, 3)),
      this.setAttribute("normal", new an(d, 3)),
      this.setAttribute("uv", new an(l, 2));
    function m(g, f, v, y, _, x, b, S, T, w, P) {
      const F = x / T,
        V = b / w,
        J = x / 2,
        z = b / 2,
        B = S / 2,
        G = T + 1,
        ie = w + 1;
      let re = 0,
        j = 0;
      const C = new Q();
      for (let R = 0; R < ie; R++) {
        const A = R * V - z;
        for (let O = 0; O < G; O++) {
          const H = O * F - J;
          (C[g] = H * y),
            (C[f] = A * _),
            (C[v] = B),
            u.push(C.x, C.y, C.z),
            (C[g] = 0),
            (C[f] = 0),
            (C[v] = S > 0 ? 1 : -1),
            d.push(C.x, C.y, C.z),
            l.push(O / T),
            l.push(1 - R / w),
            (re += 1);
        }
      }
      for (let R = 0; R < w; R++)
        for (let A = 0; A < T; A++) {
          const O = c + A + G * R,
            H = c + A + G * (R + 1),
            I = c + (A + 1) + G * (R + 1),
            E = c + (A + 1) + G * R;
          s.push(O, H, E), s.push(H, I, E), (j += 6);
        }
      a.addGroup(h, j, P), (h += j), (c += re);
    }
  }
  static fromJSON(e) {
    return new Sl(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function wo(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? (e[t][i] = r.clone())
        : Array.isArray(r)
        ? (e[t][i] = r.slice())
        : (e[t][i] = r);
    }
  }
  return e;
}
function sn(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = wo(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function xM(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function Hb(n) {
  return n.getRenderTarget() === null && n.outputEncoding === ot ? pi : ol;
}
const bM = { clone: wo, merge: sn };
var SM = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  wM = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ls extends Ln {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = SM),
      (this.fragmentShader = wM),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = wo(e.uniforms)),
      (this.uniformsGroups = xM(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const r in this.uniforms) {
      const p = this.uniforms[r].value;
      p && p.isTexture
        ? (t.uniforms[r] = { type: "t", value: p.toJSON(e).uuid })
        : p && p.isColor
        ? (t.uniforms[r] = { type: "c", value: p.getHex() })
        : p && p.isVector2
        ? (t.uniforms[r] = { type: "v2", value: p.toArray() })
        : p && p.isVector3
        ? (t.uniforms[r] = { type: "v3", value: p.toArray() })
        : p && p.isVector4
        ? (t.uniforms[r] = { type: "v4", value: p.toArray() })
        : p && p.isMatrix3
        ? (t.uniforms[r] = { type: "m3", value: p.toArray() })
        : p && p.isMatrix4
        ? (t.uniforms[r] = { type: "m4", value: p.toArray() })
        : (t.uniforms[r] = { value: p });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Vb extends St {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Xe()),
      (this.projectionMatrix = new Xe()),
      (this.projectionMatrixInverse = new Xe());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ln extends Vb {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = al * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Fa * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return al * 2 * Math.atan(Math.tan(Fa * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, r, o, p) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = o),
      (this.view.height = p),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Fa * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      o = -0.5 * r;
    const p = this.view;
    if (this.view !== null && this.view.enabled) {
      const s = p.fullWidth,
        u = p.fullHeight;
      (o += (p.offsetX * r) / s),
        (t -= (p.offsetY * i) / u),
        (r *= p.width / s),
        (i *= p.height / u);
    }
    const a = this.filmOffset;
    a !== 0 && (o += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(o, o + r, t, t - i, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Os = -90,
  Ls = 1;
class TM extends St {
  constructor(e, t, i) {
    super(), (this.type = "CubeCamera"), (this.renderTarget = i);
    const r = new ln(Os, Ls, e, t);
    (r.layers = this.layers), r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r);
    const o = new ln(Os, Ls, e, t);
    (o.layers = this.layers),
      o.up.set(0, 1, 0),
      o.lookAt(-1, 0, 0),
      this.add(o);
    const p = new ln(Os, Ls, e, t);
    (p.layers = this.layers),
      p.up.set(0, 0, -1),
      p.lookAt(0, 1, 0),
      this.add(p);
    const a = new ln(Os, Ls, e, t);
    (a.layers = this.layers),
      a.up.set(0, 0, 1),
      a.lookAt(0, -1, 0),
      this.add(a);
    const s = new ln(Os, Ls, e, t);
    (s.layers = this.layers), s.up.set(0, 1, 0), s.lookAt(0, 0, 1), this.add(s);
    const u = new ln(Os, Ls, e, t);
    (u.layers = this.layers),
      u.up.set(0, 1, 0),
      u.lookAt(0, 0, -1),
      this.add(u);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget,
      [r, o, p, a, s, u] = this.children,
      d = e.getRenderTarget(),
      l = e.toneMapping,
      c = e.xr.enabled;
    (e.toneMapping = Bi), (e.xr.enabled = !1);
    const h = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0),
      e.render(t, r),
      e.setRenderTarget(i, 1),
      e.render(t, o),
      e.setRenderTarget(i, 2),
      e.render(t, p),
      e.setRenderTarget(i, 3),
      e.render(t, a),
      e.setRenderTarget(i, 4),
      e.render(t, s),
      (i.texture.generateMipmaps = h),
      e.setRenderTarget(i, 5),
      e.render(t, u),
      e.setRenderTarget(d),
      (e.toneMapping = l),
      (e.xr.enabled = c),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class Wb extends jt {
  constructor(e, t, i, r, o, p, a, s, u, d) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : yo),
      super(e, t, i, r, o, p, a, s, u, d),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class CM extends as {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    (this.texture = new Wb(
      r,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : mn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.encoding = t.encoding),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Sl(5, 5, 5),
      o = new ls({
        name: "CubemapFromEquirect",
        uniforms: wo(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Xn,
        blending: gr,
      });
    o.uniforms.tEquirect.value = t;
    const p = new vn(r, o),
      a = t.minFilter;
    return (
      t.minFilter === rs && (t.minFilter = mn),
      new TM(1, 10, this).update(e, p),
      (t.minFilter = a),
      p.geometry.dispose(),
      p.material.dispose(),
      this
    );
  }
  clear(e, t, i, r) {
    const o = e.getRenderTarget();
    for (let p = 0; p < 6; p++) e.setRenderTarget(this, p), e.clear(t, i, r);
    e.setRenderTarget(o);
  }
}
const mf = new Q(),
  MM = new Q(),
  EM = new An();
class Fr {
  constructor(e = new Q(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = mf.subVectors(i, t).cross(MM.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const i = e.delta(mf),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / r;
    return o < 0 || o > 1 ? null : t.copy(i).multiplyScalar(o).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || EM.getNormalMatrix(e),
      r = this.coplanarPoint(mf).applyMatrix4(e),
      o = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(o)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ds = new Ro(),
  gc = new Q();
class sm {
  constructor(
    e = new Fr(),
    t = new Fr(),
    i = new Fr(),
    r = new Fr(),
    o = new Fr(),
    p = new Fr()
  ) {
    this.planes = [e, t, i, r, o, p];
  }
  set(e, t, i, r, o, p) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(o),
      a[5].copy(p),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      i = e.elements,
      r = i[0],
      o = i[1],
      p = i[2],
      a = i[3],
      s = i[4],
      u = i[5],
      d = i[6],
      l = i[7],
      c = i[8],
      h = i[9],
      m = i[10],
      g = i[11],
      f = i[12],
      v = i[13],
      y = i[14],
      _ = i[15];
    return (
      t[0].setComponents(a - r, l - s, g - c, _ - f).normalize(),
      t[1].setComponents(a + r, l + s, g + c, _ + f).normalize(),
      t[2].setComponents(a + o, l + u, g + h, _ + v).normalize(),
      t[3].setComponents(a - o, l - u, g - h, _ - v).normalize(),
      t[4].setComponents(a - p, l - d, g - m, _ - y).normalize(),
      t[5].setComponents(a + p, l + d, g + m, _ + y).normalize(),
      this
    );
  }
  intersectsObject(e) {
    const t = e.geometry;
    return (
      t.boundingSphere === null && t.computeBoundingSphere(),
      Ds.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ds)
    );
  }
  intersectsSprite(e) {
    return (
      Ds.center.set(0, 0, 0),
      (Ds.radius = 0.7071067811865476),
      Ds.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ds)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let o = 0; o < 6; o++) if (t[o].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((gc.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (gc.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (gc.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(gc) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Gb() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(o, p) {
    t(o, p), (i = n.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (o) {
      t = o;
    },
    setContext: function (o) {
      n = o;
    },
  };
}
function AM(n, e) {
  const t = e.isWebGL2,
    i = new WeakMap();
  function r(u, d) {
    const l = u.array,
      c = u.usage,
      h = n.createBuffer();
    n.bindBuffer(d, h), n.bufferData(d, l, c), u.onUploadCallback();
    let m;
    if (l instanceof Float32Array) m = 5126;
    else if (l instanceof Uint16Array)
      if (u.isFloat16BufferAttribute)
        if (t) m = 5131;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else m = 5123;
    else if (l instanceof Int16Array) m = 5122;
    else if (l instanceof Uint32Array) m = 5125;
    else if (l instanceof Int32Array) m = 5124;
    else if (l instanceof Int8Array) m = 5120;
    else if (l instanceof Uint8Array) m = 5121;
    else if (l instanceof Uint8ClampedArray) m = 5121;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + l
      );
    return {
      buffer: h,
      type: m,
      bytesPerElement: l.BYTES_PER_ELEMENT,
      version: u.version,
    };
  }
  function o(u, d, l) {
    const c = d.array,
      h = d.updateRange;
    n.bindBuffer(l, u),
      h.count === -1
        ? n.bufferSubData(l, 0, c)
        : (t
            ? n.bufferSubData(
                l,
                h.offset * c.BYTES_PER_ELEMENT,
                c,
                h.offset,
                h.count
              )
            : n.bufferSubData(
                l,
                h.offset * c.BYTES_PER_ELEMENT,
                c.subarray(h.offset, h.offset + h.count)
              ),
          (h.count = -1)),
      d.onUploadCallback();
  }
  function p(u) {
    return u.isInterleavedBufferAttribute && (u = u.data), i.get(u);
  }
  function a(u) {
    u.isInterleavedBufferAttribute && (u = u.data);
    const d = i.get(u);
    d && (n.deleteBuffer(d.buffer), i.delete(u));
  }
  function s(u, d) {
    if (u.isGLBufferAttribute) {
      const c = i.get(u);
      (!c || c.version < u.version) &&
        i.set(u, {
          buffer: u.buffer,
          type: u.type,
          bytesPerElement: u.elementSize,
          version: u.version,
        });
      return;
    }
    u.isInterleavedBufferAttribute && (u = u.data);
    const l = i.get(u);
    l === void 0
      ? i.set(u, r(u, d))
      : l.version < u.version && (o(l.buffer, u, d), (l.version = u.version));
  }
  return { get: p, remove: a, update: s };
}
class om extends Rn {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      });
    const o = e / 2,
      p = t / 2,
      a = Math.floor(i),
      s = Math.floor(r),
      u = a + 1,
      d = s + 1,
      l = e / a,
      c = t / s,
      h = [],
      m = [],
      g = [],
      f = [];
    for (let v = 0; v < d; v++) {
      const y = v * c - p;
      for (let _ = 0; _ < u; _++) {
        const x = _ * l - o;
        m.push(x, -y, 0), g.push(0, 0, 1), f.push(_ / a), f.push(1 - v / s);
      }
    }
    for (let v = 0; v < s; v++)
      for (let y = 0; y < a; y++) {
        const _ = y + u * v,
          x = y + u * (v + 1),
          b = y + 1 + u * (v + 1),
          S = y + 1 + u * v;
        h.push(_, x, S), h.push(x, b, S);
      }
    this.setIndex(h),
      this.setAttribute("position", new an(m, 3)),
      this.setAttribute("normal", new an(g, 3)),
      this.setAttribute("uv", new an(f, 2));
  }
  static fromJSON(e) {
    return new om(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var PM = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
  OM = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  LM = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  DM = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  RM = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  IM = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  kM = "vec3 transformed = vec3( position );",
  FM = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  NM = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
  BM = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  zM = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  UM = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  jM = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  HM = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  VM = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  WM = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  GM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  $M = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  XM = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  YM = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
  KM = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  qM = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  ZM = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  JM = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
  QM = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  eE = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  tE = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  nE = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  iE = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  rE = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  sE = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  oE = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  aE = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  lE = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  cE = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  uE = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  hE = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  fE = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  dE = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  pE = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  mE = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  gE = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  vE = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  yE = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  _E = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  xE = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  bE = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  SE = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  wE = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
  TE = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  CE = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  ME = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  EE = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  AE = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  PE = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  OE = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  LE = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  DE = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  RE = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  IE = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  kE = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  FE = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  NE = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  BE = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  zE = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  UE = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  jE = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  HE = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
  VE = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  WE = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  GE = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  $E = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  XE = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
  YE = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  KE = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
  qE = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
  ZE = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  JE = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  QE = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
  e2 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  t2 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  n2 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  i2 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  r2 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  s2 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  o2 = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  a2 = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  l2 = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
  c2 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  u2 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  h2 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  f2 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  d2 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  p2 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  m2 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  g2 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  v2 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  y2 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
  _2 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  x2 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
  b2 = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
  S2 = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
  w2 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
  T2 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
  C2 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
  M2 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const E2 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  A2 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  P2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  O2 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  L2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  D2 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  R2 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  I2 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  k2 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  F2 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  N2 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  B2 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  z2 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  U2 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  j2 = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  H2 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  V2 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  W2 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  G2 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  $2 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  X2 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  Y2 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  K2 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  q2 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Z2 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  J2 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Q2 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  eA = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  tA = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  nA = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  iA = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  rA = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  sA = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  oA = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Ve = {
    alphamap_fragment: PM,
    alphamap_pars_fragment: OM,
    alphatest_fragment: LM,
    alphatest_pars_fragment: DM,
    aomap_fragment: RM,
    aomap_pars_fragment: IM,
    begin_vertex: kM,
    beginnormal_vertex: FM,
    bsdfs: NM,
    iridescence_fragment: BM,
    bumpmap_pars_fragment: zM,
    clipping_planes_fragment: UM,
    clipping_planes_pars_fragment: jM,
    clipping_planes_pars_vertex: HM,
    clipping_planes_vertex: VM,
    color_fragment: WM,
    color_pars_fragment: GM,
    color_pars_vertex: $M,
    color_vertex: XM,
    common: YM,
    cube_uv_reflection_fragment: KM,
    defaultnormal_vertex: qM,
    displacementmap_pars_vertex: ZM,
    displacementmap_vertex: JM,
    emissivemap_fragment: QM,
    emissivemap_pars_fragment: eE,
    encodings_fragment: tE,
    encodings_pars_fragment: nE,
    envmap_fragment: iE,
    envmap_common_pars_fragment: rE,
    envmap_pars_fragment: sE,
    envmap_pars_vertex: oE,
    envmap_physical_pars_fragment: yE,
    envmap_vertex: aE,
    fog_vertex: lE,
    fog_pars_vertex: cE,
    fog_fragment: uE,
    fog_pars_fragment: hE,
    gradientmap_pars_fragment: fE,
    lightmap_fragment: dE,
    lightmap_pars_fragment: pE,
    lights_lambert_fragment: mE,
    lights_lambert_pars_fragment: gE,
    lights_pars_begin: vE,
    lights_toon_fragment: _E,
    lights_toon_pars_fragment: xE,
    lights_phong_fragment: bE,
    lights_phong_pars_fragment: SE,
    lights_physical_fragment: wE,
    lights_physical_pars_fragment: TE,
    lights_fragment_begin: CE,
    lights_fragment_maps: ME,
    lights_fragment_end: EE,
    logdepthbuf_fragment: AE,
    logdepthbuf_pars_fragment: PE,
    logdepthbuf_pars_vertex: OE,
    logdepthbuf_vertex: LE,
    map_fragment: DE,
    map_pars_fragment: RE,
    map_particle_fragment: IE,
    map_particle_pars_fragment: kE,
    metalnessmap_fragment: FE,
    metalnessmap_pars_fragment: NE,
    morphcolor_vertex: BE,
    morphnormal_vertex: zE,
    morphtarget_pars_vertex: UE,
    morphtarget_vertex: jE,
    normal_fragment_begin: HE,
    normal_fragment_maps: VE,
    normal_pars_fragment: WE,
    normal_pars_vertex: GE,
    normal_vertex: $E,
    normalmap_pars_fragment: XE,
    clearcoat_normal_fragment_begin: YE,
    clearcoat_normal_fragment_maps: KE,
    clearcoat_pars_fragment: qE,
    iridescence_pars_fragment: ZE,
    output_fragment: JE,
    packing: QE,
    premultiplied_alpha_fragment: e2,
    project_vertex: t2,
    dithering_fragment: n2,
    dithering_pars_fragment: i2,
    roughnessmap_fragment: r2,
    roughnessmap_pars_fragment: s2,
    shadowmap_pars_fragment: o2,
    shadowmap_pars_vertex: a2,
    shadowmap_vertex: l2,
    shadowmask_pars_fragment: c2,
    skinbase_vertex: u2,
    skinning_pars_vertex: h2,
    skinning_vertex: f2,
    skinnormal_vertex: d2,
    specularmap_fragment: p2,
    specularmap_pars_fragment: m2,
    tonemapping_fragment: g2,
    tonemapping_pars_fragment: v2,
    transmission_fragment: y2,
    transmission_pars_fragment: _2,
    uv_pars_fragment: x2,
    uv_pars_vertex: b2,
    uv_vertex: S2,
    uv2_pars_fragment: w2,
    uv2_pars_vertex: T2,
    uv2_vertex: C2,
    worldpos_vertex: M2,
    background_vert: E2,
    background_frag: A2,
    backgroundCube_vert: P2,
    backgroundCube_frag: O2,
    cube_vert: L2,
    cube_frag: D2,
    depth_vert: R2,
    depth_frag: I2,
    distanceRGBA_vert: k2,
    distanceRGBA_frag: F2,
    equirect_vert: N2,
    equirect_frag: B2,
    linedashed_vert: z2,
    linedashed_frag: U2,
    meshbasic_vert: j2,
    meshbasic_frag: H2,
    meshlambert_vert: V2,
    meshlambert_frag: W2,
    meshmatcap_vert: G2,
    meshmatcap_frag: $2,
    meshnormal_vert: X2,
    meshnormal_frag: Y2,
    meshphong_vert: K2,
    meshphong_frag: q2,
    meshphysical_vert: Z2,
    meshphysical_frag: J2,
    meshtoon_vert: Q2,
    meshtoon_frag: eA,
    points_vert: tA,
    points_frag: nA,
    shadow_vert: iA,
    shadow_frag: rA,
    sprite_vert: sA,
    sprite_frag: oA,
  },
  Te = {
    common: {
      diffuse: { value: new je(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new An() },
      uv2Transform: { value: new An() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new ze(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new je(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new je(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new An() },
    },
    sprite: {
      diffuse: { value: new je(16777215) },
      opacity: { value: 1 },
      center: { value: new ze(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new An() },
    },
  },
  mi = {
    basic: {
      uniforms: sn([
        Te.common,
        Te.specularmap,
        Te.envmap,
        Te.aomap,
        Te.lightmap,
        Te.fog,
      ]),
      vertexShader: Ve.meshbasic_vert,
      fragmentShader: Ve.meshbasic_frag,
    },
    lambert: {
      uniforms: sn([
        Te.common,
        Te.specularmap,
        Te.envmap,
        Te.aomap,
        Te.lightmap,
        Te.emissivemap,
        Te.bumpmap,
        Te.normalmap,
        Te.displacementmap,
        Te.fog,
        Te.lights,
        { emissive: { value: new je(0) } },
      ]),
      vertexShader: Ve.meshlambert_vert,
      fragmentShader: Ve.meshlambert_frag,
    },
    phong: {
      uniforms: sn([
        Te.common,
        Te.specularmap,
        Te.envmap,
        Te.aomap,
        Te.lightmap,
        Te.emissivemap,
        Te.bumpmap,
        Te.normalmap,
        Te.displacementmap,
        Te.fog,
        Te.lights,
        {
          emissive: { value: new je(0) },
          specular: { value: new je(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Ve.meshphong_vert,
      fragmentShader: Ve.meshphong_frag,
    },
    standard: {
      uniforms: sn([
        Te.common,
        Te.envmap,
        Te.aomap,
        Te.lightmap,
        Te.emissivemap,
        Te.bumpmap,
        Te.normalmap,
        Te.displacementmap,
        Te.roughnessmap,
        Te.metalnessmap,
        Te.fog,
        Te.lights,
        {
          emissive: { value: new je(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Ve.meshphysical_vert,
      fragmentShader: Ve.meshphysical_frag,
    },
    toon: {
      uniforms: sn([
        Te.common,
        Te.aomap,
        Te.lightmap,
        Te.emissivemap,
        Te.bumpmap,
        Te.normalmap,
        Te.displacementmap,
        Te.gradientmap,
        Te.fog,
        Te.lights,
        { emissive: { value: new je(0) } },
      ]),
      vertexShader: Ve.meshtoon_vert,
      fragmentShader: Ve.meshtoon_frag,
    },
    matcap: {
      uniforms: sn([
        Te.common,
        Te.bumpmap,
        Te.normalmap,
        Te.displacementmap,
        Te.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Ve.meshmatcap_vert,
      fragmentShader: Ve.meshmatcap_frag,
    },
    points: {
      uniforms: sn([Te.points, Te.fog]),
      vertexShader: Ve.points_vert,
      fragmentShader: Ve.points_frag,
    },
    dashed: {
      uniforms: sn([
        Te.common,
        Te.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Ve.linedashed_vert,
      fragmentShader: Ve.linedashed_frag,
    },
    depth: {
      uniforms: sn([Te.common, Te.displacementmap]),
      vertexShader: Ve.depth_vert,
      fragmentShader: Ve.depth_frag,
    },
    normal: {
      uniforms: sn([
        Te.common,
        Te.bumpmap,
        Te.normalmap,
        Te.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Ve.meshnormal_vert,
      fragmentShader: Ve.meshnormal_frag,
    },
    sprite: {
      uniforms: sn([Te.sprite, Te.fog]),
      vertexShader: Ve.sprite_vert,
      fragmentShader: Ve.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new An() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ve.background_vert,
      fragmentShader: Ve.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ve.backgroundCube_vert,
      fragmentShader: Ve.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Ve.cube_vert,
      fragmentShader: Ve.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ve.equirect_vert,
      fragmentShader: Ve.equirect_frag,
    },
    distanceRGBA: {
      uniforms: sn([
        Te.common,
        Te.displacementmap,
        {
          referencePosition: { value: new Q() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Ve.distanceRGBA_vert,
      fragmentShader: Ve.distanceRGBA_frag,
    },
    shadow: {
      uniforms: sn([
        Te.lights,
        Te.fog,
        { color: { value: new je(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Ve.shadow_vert,
      fragmentShader: Ve.shadow_frag,
    },
  };
mi.physical = {
  uniforms: sn([
    mi.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new ze(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new je(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new ze() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new je(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: new je(1, 1, 1) },
      specularColorMap: { value: null },
    },
  ]),
  vertexShader: Ve.meshphysical_vert,
  fragmentShader: Ve.meshphysical_frag,
};
const vc = { r: 0, b: 0, g: 0 };
function aA(n, e, t, i, r, o, p) {
  const a = new je(0);
  let s = o === !0 ? 0 : 1,
    u,
    d,
    l = null,
    c = 0,
    h = null;
  function m(f, v) {
    let y = !1,
      _ = v.isScene === !0 ? v.background : null;
    _ && _.isTexture && (_ = (v.backgroundBlurriness > 0 ? t : e).get(_));
    const x = n.xr,
      b = x.getSession && x.getSession();
    b && b.environmentBlendMode === "additive" && (_ = null),
      _ === null ? g(a, s) : _ && _.isColor && (g(_, 1), (y = !0)),
      (n.autoClear || y) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      _ && (_.isCubeTexture || _.mapping === Wu)
        ? (d === void 0 &&
            ((d = new vn(
              new Sl(1, 1, 1),
              new ls({
                name: "BackgroundCubeMaterial",
                uniforms: wo(mi.backgroundCube.uniforms),
                vertexShader: mi.backgroundCube.vertexShader,
                fragmentShader: mi.backgroundCube.fragmentShader,
                side: Xn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            d.geometry.deleteAttribute("normal"),
            d.geometry.deleteAttribute("uv"),
            (d.onBeforeRender = function (S, T, w) {
              this.matrixWorld.copyPosition(w.matrixWorld);
            }),
            Object.defineProperty(d.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(d)),
          (d.material.uniforms.envMap.value = _),
          (d.material.uniforms.flipEnvMap.value =
            _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
          (d.material.uniforms.backgroundBlurriness.value =
            v.backgroundBlurriness),
          (d.material.uniforms.backgroundIntensity.value =
            v.backgroundIntensity),
          (d.material.toneMapped = _.encoding !== ot),
          (l !== _ || c !== _.version || h !== n.toneMapping) &&
            ((d.material.needsUpdate = !0),
            (l = _),
            (c = _.version),
            (h = n.toneMapping)),
          d.layers.enableAll(),
          f.unshift(d, d.geometry, d.material, 0, 0, null))
        : _ &&
          _.isTexture &&
          (u === void 0 &&
            ((u = new vn(
              new om(2, 2),
              new ls({
                name: "BackgroundMaterial",
                uniforms: wo(mi.background.uniforms),
                vertexShader: mi.background.vertexShader,
                fragmentShader: mi.background.fragmentShader,
                side: _r,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            Object.defineProperty(u.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(u)),
          (u.material.uniforms.t2D.value = _),
          (u.material.uniforms.backgroundIntensity.value =
            v.backgroundIntensity),
          (u.material.toneMapped = _.encoding !== ot),
          _.matrixAutoUpdate === !0 && _.updateMatrix(),
          u.material.uniforms.uvTransform.value.copy(_.matrix),
          (l !== _ || c !== _.version || h !== n.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (l = _),
            (c = _.version),
            (h = n.toneMapping)),
          u.layers.enableAll(),
          f.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function g(f, v) {
    f.getRGB(vc, Hb(n)), i.buffers.color.setClear(vc.r, vc.g, vc.b, v, p);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (f, v = 1) {
      a.set(f), (s = v), g(a, s);
    },
    getClearAlpha: function () {
      return s;
    },
    setClearAlpha: function (f) {
      (s = f), g(a, s);
    },
    render: m,
  };
}
function lA(n, e, t, i) {
  const r = n.getParameter(34921),
    o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    p = i.isWebGL2 || o !== null,
    a = {},
    s = f(null);
  let u = s,
    d = !1;
  function l(B, G, ie, re, j) {
    let C = !1;
    if (p) {
      const R = g(re, ie, G);
      u !== R && ((u = R), h(u.object)),
        (C = v(B, re, ie, j)),
        C && y(B, re, ie, j);
    } else {
      const R = G.wireframe === !0;
      (u.geometry !== re.id || u.program !== ie.id || u.wireframe !== R) &&
        ((u.geometry = re.id),
        (u.program = ie.id),
        (u.wireframe = R),
        (C = !0));
    }
    j !== null && t.update(j, 34963),
      (C || d) &&
        ((d = !1),
        w(B, G, ie, re),
        j !== null && n.bindBuffer(34963, t.get(j).buffer));
  }
  function c() {
    return i.isWebGL2 ? n.createVertexArray() : o.createVertexArrayOES();
  }
  function h(B) {
    return i.isWebGL2 ? n.bindVertexArray(B) : o.bindVertexArrayOES(B);
  }
  function m(B) {
    return i.isWebGL2 ? n.deleteVertexArray(B) : o.deleteVertexArrayOES(B);
  }
  function g(B, G, ie) {
    const re = ie.wireframe === !0;
    let j = a[B.id];
    j === void 0 && ((j = {}), (a[B.id] = j));
    let C = j[G.id];
    C === void 0 && ((C = {}), (j[G.id] = C));
    let R = C[re];
    return R === void 0 && ((R = f(c())), (C[re] = R)), R;
  }
  function f(B) {
    const G = [],
      ie = [],
      re = [];
    for (let j = 0; j < r; j++) (G[j] = 0), (ie[j] = 0), (re[j] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: G,
      enabledAttributes: ie,
      attributeDivisors: re,
      object: B,
      attributes: {},
      index: null,
    };
  }
  function v(B, G, ie, re) {
    const j = u.attributes,
      C = G.attributes;
    let R = 0;
    const A = ie.getAttributes();
    for (const O in A)
      if (A[O].location >= 0) {
        const I = j[O];
        let E = C[O];
        if (
          (E === void 0 &&
            (O === "instanceMatrix" &&
              B.instanceMatrix &&
              (E = B.instanceMatrix),
            O === "instanceColor" && B.instanceColor && (E = B.instanceColor)),
          I === void 0 || I.attribute !== E || (E && I.data !== E.data))
        )
          return !0;
        R++;
      }
    return u.attributesNum !== R || u.index !== re;
  }
  function y(B, G, ie, re) {
    const j = {},
      C = G.attributes;
    let R = 0;
    const A = ie.getAttributes();
    for (const O in A)
      if (A[O].location >= 0) {
        let I = C[O];
        I === void 0 &&
          (O === "instanceMatrix" && B.instanceMatrix && (I = B.instanceMatrix),
          O === "instanceColor" && B.instanceColor && (I = B.instanceColor));
        const E = {};
        (E.attribute = I), I && I.data && (E.data = I.data), (j[O] = E), R++;
      }
    (u.attributes = j), (u.attributesNum = R), (u.index = re);
  }
  function _() {
    const B = u.newAttributes;
    for (let G = 0, ie = B.length; G < ie; G++) B[G] = 0;
  }
  function x(B) {
    b(B, 0);
  }
  function b(B, G) {
    const ie = u.newAttributes,
      re = u.enabledAttributes,
      j = u.attributeDivisors;
    (ie[B] = 1),
      re[B] === 0 && (n.enableVertexAttribArray(B), (re[B] = 1)),
      j[B] !== G &&
        ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](B, G),
        (j[B] = G));
  }
  function S() {
    const B = u.newAttributes,
      G = u.enabledAttributes;
    for (let ie = 0, re = G.length; ie < re; ie++)
      G[ie] !== B[ie] && (n.disableVertexAttribArray(ie), (G[ie] = 0));
  }
  function T(B, G, ie, re, j, C) {
    i.isWebGL2 === !0 && (ie === 5124 || ie === 5125)
      ? n.vertexAttribIPointer(B, G, ie, j, C)
      : n.vertexAttribPointer(B, G, ie, re, j, C);
  }
  function w(B, G, ie, re) {
    if (
      i.isWebGL2 === !1 &&
      (B.isInstancedMesh || re.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    _();
    const j = re.attributes,
      C = ie.getAttributes(),
      R = G.defaultAttributeValues;
    for (const A in C) {
      const O = C[A];
      if (O.location >= 0) {
        let H = j[A];
        if (
          (H === void 0 &&
            (A === "instanceMatrix" &&
              B.instanceMatrix &&
              (H = B.instanceMatrix),
            A === "instanceColor" && B.instanceColor && (H = B.instanceColor)),
          H !== void 0)
        ) {
          const I = H.normalized,
            E = H.itemSize,
            k = t.get(H);
          if (k === void 0) continue;
          const $ = k.buffer,
            Y = k.type,
            X = k.bytesPerElement;
          if (H.isInterleavedBufferAttribute) {
            const ee = H.data,
              he = ee.stride,
              pe = H.offset;
            if (ee.isInstancedInterleavedBuffer) {
              for (let Z = 0; Z < O.locationSize; Z++)
                b(O.location + Z, ee.meshPerAttribute);
              B.isInstancedMesh !== !0 &&
                re._maxInstanceCount === void 0 &&
                (re._maxInstanceCount = ee.meshPerAttribute * ee.count);
            } else for (let Z = 0; Z < O.locationSize; Z++) x(O.location + Z);
            n.bindBuffer(34962, $);
            for (let Z = 0; Z < O.locationSize; Z++)
              T(
                O.location + Z,
                E / O.locationSize,
                Y,
                I,
                he * X,
                (pe + (E / O.locationSize) * Z) * X
              );
          } else {
            if (H.isInstancedBufferAttribute) {
              for (let ee = 0; ee < O.locationSize; ee++)
                b(O.location + ee, H.meshPerAttribute);
              B.isInstancedMesh !== !0 &&
                re._maxInstanceCount === void 0 &&
                (re._maxInstanceCount = H.meshPerAttribute * H.count);
            } else
              for (let ee = 0; ee < O.locationSize; ee++) x(O.location + ee);
            n.bindBuffer(34962, $);
            for (let ee = 0; ee < O.locationSize; ee++)
              T(
                O.location + ee,
                E / O.locationSize,
                Y,
                I,
                E * X,
                (E / O.locationSize) * ee * X
              );
          }
        } else if (R !== void 0) {
          const I = R[A];
          if (I !== void 0)
            switch (I.length) {
              case 2:
                n.vertexAttrib2fv(O.location, I);
                break;
              case 3:
                n.vertexAttrib3fv(O.location, I);
                break;
              case 4:
                n.vertexAttrib4fv(O.location, I);
                break;
              default:
                n.vertexAttrib1fv(O.location, I);
            }
        }
      }
    }
    S();
  }
  function P() {
    J();
    for (const B in a) {
      const G = a[B];
      for (const ie in G) {
        const re = G[ie];
        for (const j in re) m(re[j].object), delete re[j];
        delete G[ie];
      }
      delete a[B];
    }
  }
  function F(B) {
    if (a[B.id] === void 0) return;
    const G = a[B.id];
    for (const ie in G) {
      const re = G[ie];
      for (const j in re) m(re[j].object), delete re[j];
      delete G[ie];
    }
    delete a[B.id];
  }
  function V(B) {
    for (const G in a) {
      const ie = a[G];
      if (ie[B.id] === void 0) continue;
      const re = ie[B.id];
      for (const j in re) m(re[j].object), delete re[j];
      delete ie[B.id];
    }
  }
  function J() {
    z(), (d = !0), u !== s && ((u = s), h(u.object));
  }
  function z() {
    (s.geometry = null), (s.program = null), (s.wireframe = !1);
  }
  return {
    setup: l,
    reset: J,
    resetDefaultState: z,
    dispose: P,
    releaseStatesOfGeometry: F,
    releaseStatesOfProgram: V,
    initAttributes: _,
    enableAttribute: x,
    disableUnusedAttributes: S,
  };
}
function cA(n, e, t, i) {
  const r = i.isWebGL2;
  let o;
  function p(u) {
    o = u;
  }
  function a(u, d) {
    n.drawArrays(o, u, d), t.update(d, o, 1);
  }
  function s(u, d, l) {
    if (l === 0) return;
    let c, h;
    if (r) (c = n), (h = "drawArraysInstanced");
    else if (
      ((c = e.get("ANGLE_instanced_arrays")),
      (h = "drawArraysInstancedANGLE"),
      c === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    c[h](o, u, d, l), t.update(d, o, l);
  }
  (this.setMode = p), (this.render = a), (this.renderInstances = s);
}
function uA(n, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const T = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function o(T) {
    if (T === "highp") {
      if (
        n.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        n.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      T = "mediump";
    }
    return T === "mediump" &&
      n.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      n.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const p =
    (typeof WebGL2RenderingContext < "u" &&
      n instanceof WebGL2RenderingContext) ||
    (typeof WebGL2ComputeRenderingContext < "u" &&
      n instanceof WebGL2ComputeRenderingContext);
  let a = t.precision !== void 0 ? t.precision : "highp";
  const s = o(a);
  s !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      s,
      "instead."
    ),
    (a = s));
  const u = p || e.has("WEBGL_draw_buffers"),
    d = t.logarithmicDepthBuffer === !0,
    l = n.getParameter(34930),
    c = n.getParameter(35660),
    h = n.getParameter(3379),
    m = n.getParameter(34076),
    g = n.getParameter(34921),
    f = n.getParameter(36347),
    v = n.getParameter(36348),
    y = n.getParameter(36349),
    _ = c > 0,
    x = p || e.has("OES_texture_float"),
    b = _ && x,
    S = p ? n.getParameter(36183) : 0;
  return {
    isWebGL2: p,
    drawBuffers: u,
    getMaxAnisotropy: r,
    getMaxPrecision: o,
    precision: a,
    logarithmicDepthBuffer: d,
    maxTextures: l,
    maxVertexTextures: c,
    maxTextureSize: h,
    maxCubemapSize: m,
    maxAttributes: g,
    maxVertexUniforms: f,
    maxVaryings: v,
    maxFragmentUniforms: y,
    vertexTextures: _,
    floatFragmentTextures: x,
    floatVertexTextures: b,
    maxSamples: S,
  };
}
function hA(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    o = !1;
  const p = new Fr(),
    a = new An(),
    s = { value: null, needsUpdate: !1 };
  (this.uniform = s),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (l, c, h) {
      const m = l.length !== 0 || c || i !== 0 || r;
      return (r = c), (t = d(l, h, 0)), (i = l.length), m;
    }),
    (this.beginShadows = function () {
      (o = !0), d(null);
    }),
    (this.endShadows = function () {
      (o = !1), u();
    }),
    (this.setState = function (l, c, h) {
      const m = l.clippingPlanes,
        g = l.clipIntersection,
        f = l.clipShadows,
        v = n.get(l);
      if (!r || m === null || m.length === 0 || (o && !f)) o ? d(null) : u();
      else {
        const y = o ? 0 : i,
          _ = y * 4;
        let x = v.clippingState || null;
        (s.value = x), (x = d(m, c, _, h));
        for (let b = 0; b !== _; ++b) x[b] = t[b];
        (v.clippingState = x),
          (this.numIntersection = g ? this.numPlanes : 0),
          (this.numPlanes += y);
      }
    });
  function u() {
    s.value !== t && ((s.value = t), (s.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function d(l, c, h, m) {
    const g = l !== null ? l.length : 0;
    let f = null;
    if (g !== 0) {
      if (((f = s.value), m !== !0 || f === null)) {
        const v = h + g * 4,
          y = c.matrixWorldInverse;
        a.getNormalMatrix(y),
          (f === null || f.length < v) && (f = new Float32Array(v));
        for (let _ = 0, x = h; _ !== g; ++_, x += 4)
          p.copy(l[_]).applyMatrix4(y, a),
            p.normal.toArray(f, x),
            (f[x + 3] = p.constant);
      }
      (s.value = f), (s.needsUpdate = !0);
    }
    return (e.numPlanes = g), (e.numIntersection = 0), f;
  }
}
function fA(n) {
  let e = new WeakMap();
  function t(p, a) {
    return a === Bd ? (p.mapping = yo) : a === zd && (p.mapping = _o), p;
  }
  function i(p) {
    if (p && p.isTexture && p.isRenderTargetTexture === !1) {
      const a = p.mapping;
      if (a === Bd || a === zd)
        if (e.has(p)) {
          const s = e.get(p).texture;
          return t(s, p.mapping);
        } else {
          const s = p.image;
          if (s && s.height > 0) {
            const u = new CM(s.height / 2);
            return (
              u.fromEquirectangularTexture(n, p),
              e.set(p, u),
              p.addEventListener("dispose", r),
              t(u.texture, p.mapping)
            );
          } else return null;
        }
    }
    return p;
  }
  function r(p) {
    const a = p.target;
    a.removeEventListener("dispose", r);
    const s = e.get(a);
    s !== void 0 && (e.delete(a), s.dispose());
  }
  function o() {
    e = new WeakMap();
  }
  return { get: i, dispose: o };
}
class am extends Vb {
  constructor(e = -1, t = 1, i = 1, r = -1, o = 0.1, p = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = o),
      (this.far = p),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, o, p) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = o),
      (this.view.height = p),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let o = i - e,
      p = i + e,
      a = r + t,
      s = r - t;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (o += u * this.view.offsetX),
        (p = o + u * this.view.width),
        (a -= d * this.view.offsetY),
        (s = a - d * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(o, p, a, s, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const Ys = 4,
  Qv = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Ur = 20,
  gf = new am(),
  e0 = new je();
let vf = null;
const Nr = (1 + Math.sqrt(5)) / 2,
  Rs = 1 / Nr,
  t0 = [
    new Q(1, 1, 1),
    new Q(-1, 1, 1),
    new Q(1, 1, -1),
    new Q(-1, 1, -1),
    new Q(0, Nr, Rs),
    new Q(0, Nr, -Rs),
    new Q(Rs, 0, Nr),
    new Q(-Rs, 0, Nr),
    new Q(Nr, Rs, 0),
    new Q(-Nr, Rs, 0),
  ];
class n0 {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    (vf = this._renderer.getRenderTarget()), this._setSize(256);
    const o = this._allocateTargets();
    return (
      (o.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, o),
      t > 0 && this._blur(o, 0, 0, t),
      this._applyPMREM(o),
      this._cleanup(o),
      o
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = s0()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = r0()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(vf),
      (e.scissorTest = !1),
      yc(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === yo || e.mapping === _o
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (vf = this._renderer.getRenderTarget());
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: mn,
        minFilter: mn,
        generateMipmaps: !1,
        type: rl,
        format: Wn,
        encoding: os,
        depthBuffer: !1,
      },
      r = i0(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = i0(e, t, i));
      const { _lodMax: o } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = dA(o)),
        (this._blurMaterial = pA(o, e, t));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new vn(this._lodPlanes[0], e);
    this._renderer.compile(t, gf);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new ln(90, 1, t, i),
      s = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      d = this._renderer,
      l = d.autoClear,
      c = d.toneMapping;
    d.getClearColor(e0), (d.toneMapping = Bi), (d.autoClear = !1);
    const h = new Gr({
        name: "PMREM.Background",
        side: Xn,
        depthWrite: !1,
        depthTest: !1,
      }),
      m = new vn(new Sl(), h);
    let g = !1;
    const f = e.background;
    f
      ? f.isColor && (h.color.copy(f), (e.background = null), (g = !0))
      : (h.color.copy(e0), (g = !0));
    for (let v = 0; v < 6; v++) {
      const y = v % 3;
      y === 0
        ? (a.up.set(0, s[v], 0), a.lookAt(u[v], 0, 0))
        : y === 1
        ? (a.up.set(0, 0, s[v]), a.lookAt(0, u[v], 0))
        : (a.up.set(0, s[v], 0), a.lookAt(0, 0, u[v]));
      const _ = this._cubeSize;
      yc(r, y * _, v > 2 ? _ : 0, _, _),
        d.setRenderTarget(r),
        g && d.render(m, a),
        d.render(e, a);
    }
    m.geometry.dispose(),
      m.material.dispose(),
      (d.toneMapping = c),
      (d.autoClear = l),
      (e.background = f);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === yo || e.mapping === _o;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = s0()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = r0());
    const o = r ? this._cubemapMaterial : this._equirectMaterial,
      p = new vn(this._lodPlanes[0], o),
      a = o.uniforms;
    a.envMap.value = e;
    const s = this._cubeSize;
    yc(t, 0, 0, 3 * s, 2 * s), i.setRenderTarget(t), i.render(p, gf);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const o = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        p = t0[(r - 1) % t0.length];
      this._blur(e, r - 1, r, o, p);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, o) {
    const p = this._pingPongRenderTarget;
    this._halfBlur(e, p, t, i, r, "latitudinal", o),
      this._halfBlur(p, e, i, i, r, "longitudinal", o);
  }
  _halfBlur(e, t, i, r, o, p, a) {
    const s = this._renderer,
      u = this._blurMaterial;
    p !== "latitudinal" &&
      p !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const d = 3,
      l = new vn(this._lodPlanes[r], u),
      c = u.uniforms,
      h = this._sizeLods[i] - 1,
      m = isFinite(o) ? Math.PI / (2 * h) : (2 * Math.PI) / (2 * Ur - 1),
      g = o / m,
      f = isFinite(o) ? 1 + Math.floor(d * g) : Ur;
    f > Ur &&
      console.warn(
        `sigmaRadians, ${o}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${Ur}`
      );
    const v = [];
    let y = 0;
    for (let T = 0; T < Ur; ++T) {
      const w = T / g,
        P = Math.exp((-w * w) / 2);
      v.push(P), T === 0 ? (y += P) : T < f && (y += 2 * P);
    }
    for (let T = 0; T < v.length; T++) v[T] = v[T] / y;
    (c.envMap.value = e.texture),
      (c.samples.value = f),
      (c.weights.value = v),
      (c.latitudinal.value = p === "latitudinal"),
      a && (c.poleAxis.value = a);
    const { _lodMax: _ } = this;
    (c.dTheta.value = m), (c.mipInt.value = _ - i);
    const x = this._sizeLods[r],
      b = 3 * x * (r > _ - Ys ? r - _ + Ys : 0),
      S = 4 * (this._cubeSize - x);
    yc(t, b, S, 3 * x, 2 * x), s.setRenderTarget(t), s.render(l, gf);
  }
}
function dA(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const o = n - Ys + 1 + Qv.length;
  for (let p = 0; p < o; p++) {
    const a = Math.pow(2, r);
    t.push(a);
    let s = 1 / a;
    p > n - Ys ? (s = Qv[p - n + Ys - 1]) : p === 0 && (s = 0), i.push(s);
    const u = 1 / (a - 2),
      d = -u,
      l = 1 + u,
      c = [d, d, l, d, l, l, d, d, l, l, d, l],
      h = 6,
      m = 6,
      g = 3,
      f = 2,
      v = 1,
      y = new Float32Array(g * m * h),
      _ = new Float32Array(f * m * h),
      x = new Float32Array(v * m * h);
    for (let S = 0; S < h; S++) {
      const T = ((S % 3) * 2) / 3 - 1,
        w = S > 2 ? 0 : -1,
        P = [
          T,
          w,
          0,
          T + 2 / 3,
          w,
          0,
          T + 2 / 3,
          w + 1,
          0,
          T,
          w,
          0,
          T + 2 / 3,
          w + 1,
          0,
          T,
          w + 1,
          0,
        ];
      y.set(P, g * m * S), _.set(c, f * m * S);
      const F = [S, S, S, S, S, S];
      x.set(F, v * m * S);
    }
    const b = new Rn();
    b.setAttribute("position", new Gt(y, g)),
      b.setAttribute("uv", new Gt(_, f)),
      b.setAttribute("faceIndex", new Gt(x, v)),
      e.push(b),
      r > Ys && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function i0(n, e, t) {
  const i = new as(n, e, t);
  return (
    (i.texture.mapping = Wu),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function yc(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function pA(n, e, t) {
  const i = new Float32Array(Ur),
    r = new Q(0, 1, 0);
  return new ls({
    name: "SphericalGaussianBlur",
    defines: {
      n: Ur,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: lm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: gr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function r0() {
  return new ls({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: lm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: gr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function s0() {
  return new ls({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: lm(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: gr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function lm() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function mA(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const s = a.mapping,
        u = s === Bd || s === zd,
        d = s === yo || s === _o;
      if (u || d)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let l = e.get(a);
          return (
            t === null && (t = new n0(n)),
            (l = u ? t.fromEquirectangular(a, l) : t.fromCubemap(a, l)),
            e.set(a, l),
            l.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const l = a.image;
            if ((u && l && l.height > 0) || (d && l && r(l))) {
              t === null && (t = new n0(n));
              const c = u ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, c), a.addEventListener("dispose", o), c.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function r(a) {
    let s = 0;
    const u = 6;
    for (let d = 0; d < u; d++) a[d] !== void 0 && s++;
    return s === u;
  }
  function o(a) {
    const s = a.target;
    s.removeEventListener("dispose", o);
    const u = e.get(s);
    u !== void 0 && (e.delete(s), u.dispose());
  }
  function p() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: i, dispose: p };
}
function gA(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function (i) {
      i.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        r
      );
    },
  };
}
function vA(n, e, t, i) {
  const r = {},
    o = new WeakMap();
  function p(l) {
    const c = l.target;
    c.index !== null && e.remove(c.index);
    for (const m in c.attributes) e.remove(c.attributes[m]);
    c.removeEventListener("dispose", p), delete r[c.id];
    const h = o.get(c);
    h && (e.remove(h), o.delete(c)),
      i.releaseStatesOfGeometry(c),
      c.isInstancedBufferGeometry === !0 && delete c._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(l, c) {
    return (
      r[c.id] === !0 ||
        (c.addEventListener("dispose", p),
        (r[c.id] = !0),
        t.memory.geometries++),
      c
    );
  }
  function s(l) {
    const c = l.attributes;
    for (const m in c) e.update(c[m], 34962);
    const h = l.morphAttributes;
    for (const m in h) {
      const g = h[m];
      for (let f = 0, v = g.length; f < v; f++) e.update(g[f], 34962);
    }
  }
  function u(l) {
    const c = [],
      h = l.index,
      m = l.attributes.position;
    let g = 0;
    if (h !== null) {
      const y = h.array;
      g = h.version;
      for (let _ = 0, x = y.length; _ < x; _ += 3) {
        const b = y[_ + 0],
          S = y[_ + 1],
          T = y[_ + 2];
        c.push(b, S, S, T, T, b);
      }
    } else {
      const y = m.array;
      g = m.version;
      for (let _ = 0, x = y.length / 3 - 1; _ < x; _ += 3) {
        const b = _ + 0,
          S = _ + 1,
          T = _ + 2;
        c.push(b, S, S, T, T, b);
      }
    }
    const f = new (Ib(c) ? jb : Ub)(c, 1);
    f.version = g;
    const v = o.get(l);
    v && e.remove(v), o.set(l, f);
  }
  function d(l) {
    const c = o.get(l);
    if (c) {
      const h = l.index;
      h !== null && c.version < h.version && u(l);
    } else u(l);
    return o.get(l);
  }
  return { get: a, update: s, getWireframeAttribute: d };
}
function yA(n, e, t, i) {
  const r = i.isWebGL2;
  let o;
  function p(c) {
    o = c;
  }
  let a, s;
  function u(c) {
    (a = c.type), (s = c.bytesPerElement);
  }
  function d(c, h) {
    n.drawElements(o, h, a, c * s), t.update(h, o, 1);
  }
  function l(c, h, m) {
    if (m === 0) return;
    let g, f;
    if (r) (g = n), (f = "drawElementsInstanced");
    else if (
      ((g = e.get("ANGLE_instanced_arrays")),
      (f = "drawElementsInstancedANGLE"),
      g === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    g[f](o, h, a, c * s, m), t.update(h, o, m);
  }
  (this.setMode = p),
    (this.setIndex = u),
    (this.render = d),
    (this.renderInstances = l);
}
function _A(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(o, p, a) {
    switch ((t.calls++, p)) {
      case 4:
        t.triangles += a * (o / 3);
        break;
      case 1:
        t.lines += a * (o / 2);
        break;
      case 3:
        t.lines += a * (o - 1);
        break;
      case 2:
        t.lines += a * o;
        break;
      case 0:
        t.points += a * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", p);
        break;
    }
  }
  function r() {
    t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function xA(n, e) {
  return n[0] - e[0];
}
function bA(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function SA(n, e, t) {
  const i = {},
    r = new Float32Array(8),
    o = new WeakMap(),
    p = new ht(),
    a = [];
  for (let u = 0; u < 8; u++) a[u] = [u, 0];
  function s(u, d, l, c) {
    const h = u.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const g =
          d.morphAttributes.position ||
          d.morphAttributes.normal ||
          d.morphAttributes.color,
        f = g !== void 0 ? g.length : 0;
      let v = o.get(d);
      if (v === void 0 || v.count !== f) {
        let ie = function () {
          B.dispose(), o.delete(d), d.removeEventListener("dispose", ie);
        };
        var m = ie;
        v !== void 0 && v.texture.dispose();
        const x = d.morphAttributes.position !== void 0,
          b = d.morphAttributes.normal !== void 0,
          S = d.morphAttributes.color !== void 0,
          T = d.morphAttributes.position || [],
          w = d.morphAttributes.normal || [],
          P = d.morphAttributes.color || [];
        let F = 0;
        x === !0 && (F = 1), b === !0 && (F = 2), S === !0 && (F = 3);
        let V = d.attributes.position.count * F,
          J = 1;
        V > e.maxTextureSize &&
          ((J = Math.ceil(V / e.maxTextureSize)), (V = e.maxTextureSize));
        const z = new Float32Array(V * J * 4 * f),
          B = new Bb(z, V, J, f);
        (B.type = or), (B.needsUpdate = !0);
        const G = F * 4;
        for (let re = 0; re < f; re++) {
          const j = T[re],
            C = w[re],
            R = P[re],
            A = V * J * 4 * re;
          for (let O = 0; O < j.count; O++) {
            const H = O * G;
            x === !0 &&
              (p.fromBufferAttribute(j, O),
              (z[A + H + 0] = p.x),
              (z[A + H + 1] = p.y),
              (z[A + H + 2] = p.z),
              (z[A + H + 3] = 0)),
              b === !0 &&
                (p.fromBufferAttribute(C, O),
                (z[A + H + 4] = p.x),
                (z[A + H + 5] = p.y),
                (z[A + H + 6] = p.z),
                (z[A + H + 7] = 0)),
              S === !0 &&
                (p.fromBufferAttribute(R, O),
                (z[A + H + 8] = p.x),
                (z[A + H + 9] = p.y),
                (z[A + H + 10] = p.z),
                (z[A + H + 11] = R.itemSize === 4 ? p.w : 1));
          }
        }
        (v = { count: f, texture: B, size: new ze(V, J) }),
          o.set(d, v),
          d.addEventListener("dispose", ie);
      }
      let y = 0;
      for (let x = 0; x < h.length; x++) y += h[x];
      const _ = d.morphTargetsRelative ? 1 : 1 - y;
      c.getUniforms().setValue(n, "morphTargetBaseInfluence", _),
        c.getUniforms().setValue(n, "morphTargetInfluences", h),
        c.getUniforms().setValue(n, "morphTargetsTexture", v.texture, t),
        c.getUniforms().setValue(n, "morphTargetsTextureSize", v.size);
    } else {
      const g = h === void 0 ? 0 : h.length;
      let f = i[d.id];
      if (f === void 0 || f.length !== g) {
        f = [];
        for (let b = 0; b < g; b++) f[b] = [b, 0];
        i[d.id] = f;
      }
      for (let b = 0; b < g; b++) {
        const S = f[b];
        (S[0] = b), (S[1] = h[b]);
      }
      f.sort(bA);
      for (let b = 0; b < 8; b++)
        b < g && f[b][1]
          ? ((a[b][0] = f[b][0]), (a[b][1] = f[b][1]))
          : ((a[b][0] = Number.MAX_SAFE_INTEGER), (a[b][1] = 0));
      a.sort(xA);
      const v = d.morphAttributes.position,
        y = d.morphAttributes.normal;
      let _ = 0;
      for (let b = 0; b < 8; b++) {
        const S = a[b],
          T = S[0],
          w = S[1];
        T !== Number.MAX_SAFE_INTEGER && w
          ? (v &&
              d.getAttribute("morphTarget" + b) !== v[T] &&
              d.setAttribute("morphTarget" + b, v[T]),
            y &&
              d.getAttribute("morphNormal" + b) !== y[T] &&
              d.setAttribute("morphNormal" + b, y[T]),
            (r[b] = w),
            (_ += w))
          : (v &&
              d.hasAttribute("morphTarget" + b) === !0 &&
              d.deleteAttribute("morphTarget" + b),
            y &&
              d.hasAttribute("morphNormal" + b) === !0 &&
              d.deleteAttribute("morphNormal" + b),
            (r[b] = 0));
      }
      const x = d.morphTargetsRelative ? 1 : 1 - _;
      c.getUniforms().setValue(n, "morphTargetBaseInfluence", x),
        c.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return { update: s };
}
function wA(n, e, t, i) {
  let r = new WeakMap();
  function o(s) {
    const u = i.render.frame,
      d = s.geometry,
      l = e.get(s, d);
    return (
      r.get(l) !== u && (e.update(l), r.set(l, u)),
      s.isInstancedMesh &&
        (s.hasEventListener("dispose", a) === !1 &&
          s.addEventListener("dispose", a),
        t.update(s.instanceMatrix, 34962),
        s.instanceColor !== null && t.update(s.instanceColor, 34962)),
      l
    );
  }
  function p() {
    r = new WeakMap();
  }
  function a(s) {
    const u = s.target;
    u.removeEventListener("dispose", a),
      t.remove(u.instanceMatrix),
      u.instanceColor !== null && t.remove(u.instanceColor);
  }
  return { update: o, dispose: p };
}
const $b = new jt(),
  Xb = new Bb(),
  Yb = new cM(),
  Kb = new Wb(),
  o0 = [],
  a0 = [],
  l0 = new Float32Array(16),
  c0 = new Float32Array(9),
  u0 = new Float32Array(4);
function Io(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let o = o0[r];
  if ((o === void 0 && ((o = new Float32Array(r)), (o0[r] = o)), e !== 0)) {
    i.toArray(o, 0);
    for (let p = 1, a = 0; p !== e; ++p) (a += t), n[p].toArray(o, a);
  }
  return o;
}
function It(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function kt(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function Gu(n, e) {
  let t = a0[e];
  t === void 0 && ((t = new Int32Array(e)), (a0[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function TA(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function CA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (It(t, e)) return;
    n.uniform2fv(this.addr, e), kt(t, e);
  }
}
function MA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (It(t, e)) return;
    n.uniform3fv(this.addr, e), kt(t, e);
  }
}
function EA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (It(t, e)) return;
    n.uniform4fv(this.addr, e), kt(t, e);
  }
}
function AA(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (It(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), kt(t, e);
  } else {
    if (It(t, i)) return;
    u0.set(i), n.uniformMatrix2fv(this.addr, !1, u0), kt(t, i);
  }
}
function PA(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (It(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), kt(t, e);
  } else {
    if (It(t, i)) return;
    c0.set(i), n.uniformMatrix3fv(this.addr, !1, c0), kt(t, i);
  }
}
function OA(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (It(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), kt(t, e);
  } else {
    if (It(t, i)) return;
    l0.set(i), n.uniformMatrix4fv(this.addr, !1, l0), kt(t, i);
  }
}
function LA(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function DA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (It(t, e)) return;
    n.uniform2iv(this.addr, e), kt(t, e);
  }
}
function RA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (It(t, e)) return;
    n.uniform3iv(this.addr, e), kt(t, e);
  }
}
function IA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (It(t, e)) return;
    n.uniform4iv(this.addr, e), kt(t, e);
  }
}
function kA(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function FA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (It(t, e)) return;
    n.uniform2uiv(this.addr, e), kt(t, e);
  }
}
function NA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (It(t, e)) return;
    n.uniform3uiv(this.addr, e), kt(t, e);
  }
}
function BA(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (It(t, e)) return;
    n.uniform4uiv(this.addr, e), kt(t, e);
  }
}
function zA(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2D(e || $b, r);
}
function UA(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || Yb, r);
}
function jA(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || Kb, r);
}
function HA(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || Xb, r);
}
function VA(n) {
  switch (n) {
    case 5126:
      return TA;
    case 35664:
      return CA;
    case 35665:
      return MA;
    case 35666:
      return EA;
    case 35674:
      return AA;
    case 35675:
      return PA;
    case 35676:
      return OA;
    case 5124:
    case 35670:
      return LA;
    case 35667:
    case 35671:
      return DA;
    case 35668:
    case 35672:
      return RA;
    case 35669:
    case 35673:
      return IA;
    case 5125:
      return kA;
    case 36294:
      return FA;
    case 36295:
      return NA;
    case 36296:
      return BA;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return zA;
    case 35679:
    case 36299:
    case 36307:
      return UA;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return jA;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return HA;
  }
}
function WA(n, e) {
  n.uniform1fv(this.addr, e);
}
function GA(n, e) {
  const t = Io(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function $A(n, e) {
  const t = Io(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function XA(n, e) {
  const t = Io(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function YA(n, e) {
  const t = Io(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function KA(n, e) {
  const t = Io(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function qA(n, e) {
  const t = Io(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function ZA(n, e) {
  n.uniform1iv(this.addr, e);
}
function JA(n, e) {
  n.uniform2iv(this.addr, e);
}
function QA(n, e) {
  n.uniform3iv(this.addr, e);
}
function eP(n, e) {
  n.uniform4iv(this.addr, e);
}
function tP(n, e) {
  n.uniform1uiv(this.addr, e);
}
function nP(n, e) {
  n.uniform2uiv(this.addr, e);
}
function iP(n, e) {
  n.uniform3uiv(this.addr, e);
}
function rP(n, e) {
  n.uniform4uiv(this.addr, e);
}
function sP(n, e, t) {
  const i = this.cache,
    r = e.length,
    o = Gu(t, r);
  It(i, o) || (n.uniform1iv(this.addr, o), kt(i, o));
  for (let p = 0; p !== r; ++p) t.setTexture2D(e[p] || $b, o[p]);
}
function oP(n, e, t) {
  const i = this.cache,
    r = e.length,
    o = Gu(t, r);
  It(i, o) || (n.uniform1iv(this.addr, o), kt(i, o));
  for (let p = 0; p !== r; ++p) t.setTexture3D(e[p] || Yb, o[p]);
}
function aP(n, e, t) {
  const i = this.cache,
    r = e.length,
    o = Gu(t, r);
  It(i, o) || (n.uniform1iv(this.addr, o), kt(i, o));
  for (let p = 0; p !== r; ++p) t.setTextureCube(e[p] || Kb, o[p]);
}
function lP(n, e, t) {
  const i = this.cache,
    r = e.length,
    o = Gu(t, r);
  It(i, o) || (n.uniform1iv(this.addr, o), kt(i, o));
  for (let p = 0; p !== r; ++p) t.setTexture2DArray(e[p] || Xb, o[p]);
}
function cP(n) {
  switch (n) {
    case 5126:
      return WA;
    case 35664:
      return GA;
    case 35665:
      return $A;
    case 35666:
      return XA;
    case 35674:
      return YA;
    case 35675:
      return KA;
    case 35676:
      return qA;
    case 5124:
    case 35670:
      return ZA;
    case 35667:
    case 35671:
      return JA;
    case 35668:
    case 35672:
      return QA;
    case 35669:
    case 35673:
      return eP;
    case 5125:
      return tP;
    case 36294:
      return nP;
    case 36295:
      return iP;
    case 36296:
      return rP;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return sP;
    case 35679:
    case 36299:
    case 36307:
      return oP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return aP;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return lP;
  }
}
class uP {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = VA(t.type));
  }
}
class hP {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = cP(t.type));
  }
}
class fP {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let o = 0, p = r.length; o !== p; ++o) {
      const a = r[o];
      a.setValue(e, t[a.id], i);
    }
  }
}
const yf = /(\w+)(\])?(\[|\.)?/g;
function h0(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function dP(n, e, t) {
  const i = n.name,
    r = i.length;
  for (yf.lastIndex = 0; ; ) {
    const o = yf.exec(i),
      p = yf.lastIndex;
    let a = o[1];
    const s = o[2] === "]",
      u = o[3];
    if ((s && (a = a | 0), u === void 0 || (u === "[" && p + 2 === r))) {
      h0(t, u === void 0 ? new uP(a, n, e) : new hP(a, n, e));
      break;
    } else {
      let l = t.map[a];
      l === void 0 && ((l = new fP(a)), h0(t, l)), (t = l);
    }
  }
}
class Vc {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, 35718);
    for (let r = 0; r < i; ++r) {
      const o = e.getActiveUniform(t, r),
        p = e.getUniformLocation(t, o.name);
      dP(o, p, this);
    }
  }
  setValue(e, t, i, r) {
    const o = this.map[t];
    o !== void 0 && o.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let o = 0, p = t.length; o !== p; ++o) {
      const a = t[o],
        s = i[a.id];
      s.needsUpdate !== !1 && a.setValue(e, s.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, o = e.length; r !== o; ++r) {
      const p = e[r];
      p.id in t && i.push(p);
    }
    return i;
  }
}
function f0(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
let pP = 0;
function mP(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    o = Math.min(e + 6, t.length);
  for (let p = r; p < o; p++) {
    const a = p + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[p]}`);
  }
  return i.join(`
`);
}
function gP(n) {
  switch (n) {
    case os:
      return ["Linear", "( value )"];
    case ot:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
        ["Linear", "( value )"]
      );
  }
}
function d0(n, e, t) {
  const i = n.getShaderParameter(e, 35713),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(r);
  if (o) {
    const p = parseInt(o[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      mP(n.getShaderSource(e), p)
    );
  } else return r;
}
function vP(n, e) {
  const t = gP(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function yP(n, e) {
  let t;
  switch (e) {
    case SC:
      t = "Linear";
      break;
    case wC:
      t = "Reinhard";
      break;
    case TC:
      t = "OptimizedCineon";
      break;
    case CC:
      t = "ACESFilmic";
      break;
    case MC:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function _P(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.tangentSpaceNormalMap ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(Ma).join(`
`);
}
function xP(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function bP(n, e) {
  const t = {},
    i = n.getProgramParameter(e, 35721);
  for (let r = 0; r < i; r++) {
    const o = n.getActiveAttrib(e, r),
      p = o.name;
    let a = 1;
    o.type === 35674 && (a = 2),
      o.type === 35675 && (a = 3),
      o.type === 35676 && (a = 4),
      (t[p] = {
        type: o.type,
        location: n.getAttribLocation(e, p),
        locationSize: a,
      });
  }
  return t;
}
function Ma(n) {
  return n !== "";
}
function p0(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function m0(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const SP = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Wd(n) {
  return n.replace(SP, wP);
}
function wP(n, e) {
  const t = Ve[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return Wd(t);
}
const TP =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function g0(n) {
  return n.replace(TP, CP);
}
function CP(n, e, t, i) {
  let r = "";
  for (let o = parseInt(e); o < parseInt(t); o++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + o + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, o);
  return r;
}
function v0(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;";
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function MP(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Mb
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === eC
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === Ca && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function EP(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case yo:
      case _o:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Wu:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function AP(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case _o:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function PP(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case tm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case xC:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case bC:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function OP(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function LP(n, e, t, i) {
  const r = n.getContext(),
    o = t.defines;
  let p = t.vertexShader,
    a = t.fragmentShader;
  const s = MP(t),
    u = EP(t),
    d = AP(t),
    l = PP(t),
    c = OP(t),
    h = t.isWebGL2 ? "" : _P(t),
    m = xP(o),
    g = r.createProgram();
  let f,
    v,
    y = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((f = [m].filter(Ma).join(`
`)),
      f.length > 0 &&
        (f += `
`),
      (v = [h, m].filter(Ma).join(`
`)),
      v.length > 0 &&
        (v += `
`))
    : ((f = [
        v0(t),
        "#define SHADER_NAME " + t.shaderName,
        m,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + d : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.displacementMap && t.supportsVertexTextures
          ? "#define USE_DISPLACEMENTMAP"
          : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + s : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Ma).join(`
`)),
      (v = [
        h,
        v0(t),
        "#define SHADER_NAME " + t.shaderName,
        m,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + d : "",
        t.envMap ? "#define " + l : "",
        c ? "#define CUBEUV_TEXEL_WIDTH " + c.texelWidth : "",
        c ? "#define CUBEUV_TEXEL_HEIGHT " + c.texelHeight : "",
        c ? "#define CUBEUV_MAX_MIP " + c.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + s : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Bi ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Bi ? Ve.tonemapping_pars_fragment : "",
        t.toneMapping !== Bi ? yP("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Ve.encodings_pars_fragment,
        vP("linearToOutputTexel", t.outputEncoding),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(Ma).join(`
`))),
    (p = Wd(p)),
    (p = p0(p, t)),
    (p = m0(p, t)),
    (a = Wd(a)),
    (a = p0(a, t)),
    (a = m0(a, t)),
    (p = g0(p)),
    (a = g0(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (f =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        f),
      (v =
        [
          "#define varying in",
          t.glslVersion === jv
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === jv ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        v));
  const _ = y + f + p,
    x = y + v + a,
    b = f0(r, 35633, _),
    S = f0(r, 35632, x);
  if (
    (r.attachShader(g, b),
    r.attachShader(g, S),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(g, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(g, 0, "position"),
    r.linkProgram(g),
    n.debug.checkShaderErrors)
  ) {
    const P = r.getProgramInfoLog(g).trim(),
      F = r.getShaderInfoLog(b).trim(),
      V = r.getShaderInfoLog(S).trim();
    let J = !0,
      z = !0;
    if (r.getProgramParameter(g, 35714) === !1) {
      J = !1;
      const B = d0(r, b, "vertex"),
        G = d0(r, S, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " +
          r.getError() +
          " - VALIDATE_STATUS " +
          r.getProgramParameter(g, 35715) +
          `

Program Info Log: ` +
          P +
          `
` +
          B +
          `
` +
          G
      );
    } else
      P !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", P)
        : (F === "" || V === "") && (z = !1);
    z &&
      (this.diagnostics = {
        runnable: J,
        programLog: P,
        vertexShader: { log: F, prefix: f },
        fragmentShader: { log: V, prefix: v },
      });
  }
  r.deleteShader(b), r.deleteShader(S);
  let T;
  this.getUniforms = function () {
    return T === void 0 && (T = new Vc(r, g)), T;
  };
  let w;
  return (
    (this.getAttributes = function () {
      return w === void 0 && (w = bP(r, g)), w;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(g),
        (this.program = void 0);
    }),
    (this.name = t.shaderName),
    (this.id = pP++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = g),
    (this.vertexShader = b),
    (this.fragmentShader = S),
    this
  );
}
let DP = 0;
class RP {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      o = this._getShaderStage(i),
      p = this._getShaderCacheForMaterial(e);
    return (
      p.has(r) === !1 && (p.add(r), r.usedTimes++),
      p.has(o) === !1 && (p.add(o), o.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && ((i = new IP(e)), t.set(e, i)), i;
  }
}
class IP {
  constructor(e) {
    (this.id = DP++), (this.code = e), (this.usedTimes = 0);
  }
}
function kP(n, e, t, i, r, o, p) {
  const a = new zb(),
    s = new RP(),
    u = [],
    d = r.isWebGL2,
    l = r.logarithmicDepthBuffer,
    c = r.vertexTextures;
  let h = r.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function g(w, P, F, V, J) {
    const z = V.fog,
      B = J.geometry,
      G = w.isMeshStandardMaterial ? V.environment : null,
      ie = (w.isMeshStandardMaterial ? t : e).get(w.envMap || G),
      re = ie && ie.mapping === Wu ? ie.image.height : null,
      j = m[w.type];
    w.precision !== null &&
      ((h = r.getMaxPrecision(w.precision)),
      h !== w.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          w.precision,
          "not supported, using",
          h,
          "instead."
        ));
    const C =
        B.morphAttributes.position ||
        B.morphAttributes.normal ||
        B.morphAttributes.color,
      R = C !== void 0 ? C.length : 0;
    let A = 0;
    B.morphAttributes.position !== void 0 && (A = 1),
      B.morphAttributes.normal !== void 0 && (A = 2),
      B.morphAttributes.color !== void 0 && (A = 3);
    let O, H, I, E;
    if (j) {
      const he = mi[j];
      (O = he.vertexShader), (H = he.fragmentShader);
    } else
      (O = w.vertexShader),
        (H = w.fragmentShader),
        s.update(w),
        (I = s.getVertexShaderID(w)),
        (E = s.getFragmentShaderID(w));
    const k = n.getRenderTarget(),
      $ = w.alphaTest > 0,
      Y = w.clearcoat > 0,
      X = w.iridescence > 0;
    return {
      isWebGL2: d,
      shaderID: j,
      shaderName: w.type,
      vertexShader: O,
      fragmentShader: H,
      defines: w.defines,
      customVertexShaderID: I,
      customFragmentShaderID: E,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: h,
      instancing: J.isInstancedMesh === !0,
      instancingColor: J.isInstancedMesh === !0 && J.instanceColor !== null,
      supportsVertexTextures: c,
      outputEncoding:
        k === null
          ? n.outputEncoding
          : k.isXRRenderTarget === !0
          ? k.texture.encoding
          : os,
      map: !!w.map,
      matcap: !!w.matcap,
      envMap: !!ie,
      envMapMode: ie && ie.mapping,
      envMapCubeUVHeight: re,
      lightMap: !!w.lightMap,
      aoMap: !!w.aoMap,
      emissiveMap: !!w.emissiveMap,
      bumpMap: !!w.bumpMap,
      normalMap: !!w.normalMap,
      objectSpaceNormalMap: w.normalMapType === $C,
      tangentSpaceNormalMap: w.normalMapType === nm,
      decodeVideoTexture:
        !!w.map && w.map.isVideoTexture === !0 && w.map.encoding === ot,
      clearcoat: Y,
      clearcoatMap: Y && !!w.clearcoatMap,
      clearcoatRoughnessMap: Y && !!w.clearcoatRoughnessMap,
      clearcoatNormalMap: Y && !!w.clearcoatNormalMap,
      iridescence: X,
      iridescenceMap: X && !!w.iridescenceMap,
      iridescenceThicknessMap: X && !!w.iridescenceThicknessMap,
      displacementMap: !!w.displacementMap,
      roughnessMap: !!w.roughnessMap,
      metalnessMap: !!w.metalnessMap,
      specularMap: !!w.specularMap,
      specularIntensityMap: !!w.specularIntensityMap,
      specularColorMap: !!w.specularColorMap,
      opaque: w.transparent === !1 && w.blending === ro,
      alphaMap: !!w.alphaMap,
      alphaTest: $,
      gradientMap: !!w.gradientMap,
      sheen: w.sheen > 0,
      sheenColorMap: !!w.sheenColorMap,
      sheenRoughnessMap: !!w.sheenRoughnessMap,
      transmission: w.transmission > 0,
      transmissionMap: !!w.transmissionMap,
      thicknessMap: !!w.thicknessMap,
      combine: w.combine,
      vertexTangents: !!w.normalMap && !!B.attributes.tangent,
      vertexColors: w.vertexColors,
      vertexAlphas:
        w.vertexColors === !0 &&
        !!B.attributes.color &&
        B.attributes.color.itemSize === 4,
      vertexUvs:
        !!w.map ||
        !!w.bumpMap ||
        !!w.normalMap ||
        !!w.specularMap ||
        !!w.alphaMap ||
        !!w.emissiveMap ||
        !!w.roughnessMap ||
        !!w.metalnessMap ||
        !!w.clearcoatMap ||
        !!w.clearcoatRoughnessMap ||
        !!w.clearcoatNormalMap ||
        !!w.iridescenceMap ||
        !!w.iridescenceThicknessMap ||
        !!w.displacementMap ||
        !!w.transmissionMap ||
        !!w.thicknessMap ||
        !!w.specularIntensityMap ||
        !!w.specularColorMap ||
        !!w.sheenColorMap ||
        !!w.sheenRoughnessMap,
      uvsVertexOnly:
        !(
          w.map ||
          w.bumpMap ||
          w.normalMap ||
          w.specularMap ||
          w.alphaMap ||
          w.emissiveMap ||
          w.roughnessMap ||
          w.metalnessMap ||
          w.clearcoatNormalMap ||
          w.iridescenceMap ||
          w.iridescenceThicknessMap ||
          w.transmission > 0 ||
          w.transmissionMap ||
          w.thicknessMap ||
          w.specularIntensityMap ||
          w.specularColorMap ||
          w.sheen > 0 ||
          w.sheenColorMap ||
          w.sheenRoughnessMap
        ) && !!w.displacementMap,
      fog: !!z,
      useFog: w.fog === !0,
      fogExp2: z && z.isFogExp2,
      flatShading: !!w.flatShading,
      sizeAttenuation: w.sizeAttenuation,
      logarithmicDepthBuffer: l,
      skinning: J.isSkinnedMesh === !0,
      morphTargets: B.morphAttributes.position !== void 0,
      morphNormals: B.morphAttributes.normal !== void 0,
      morphColors: B.morphAttributes.color !== void 0,
      morphTargetsCount: R,
      morphTextureStride: A,
      numDirLights: P.directional.length,
      numPointLights: P.point.length,
      numSpotLights: P.spot.length,
      numSpotLightMaps: P.spotLightMap.length,
      numRectAreaLights: P.rectArea.length,
      numHemiLights: P.hemi.length,
      numDirLightShadows: P.directionalShadowMap.length,
      numPointLightShadows: P.pointShadowMap.length,
      numSpotLightShadows: P.spotShadowMap.length,
      numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps,
      numClippingPlanes: p.numPlanes,
      numClipIntersection: p.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: n.shadowMap.enabled && F.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: w.toneMapped ? n.toneMapping : Bi,
      physicallyCorrectLights: n.physicallyCorrectLights,
      premultipliedAlpha: w.premultipliedAlpha,
      doubleSided: w.side === Vu,
      flipSided: w.side === Xn,
      useDepthPacking: !!w.depthPacking,
      depthPacking: w.depthPacking || 0,
      index0AttributeName: w.index0AttributeName,
      extensionDerivatives: w.extensions && w.extensions.derivatives,
      extensionFragDepth: w.extensions && w.extensions.fragDepth,
      extensionDrawBuffers: w.extensions && w.extensions.drawBuffers,
      extensionShaderTextureLOD: w.extensions && w.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: w.customProgramCacheKey(),
    };
  }
  function f(w) {
    const P = [];
    if (
      (w.shaderID
        ? P.push(w.shaderID)
        : (P.push(w.customVertexShaderID), P.push(w.customFragmentShaderID)),
      w.defines !== void 0)
    )
      for (const F in w.defines) P.push(F), P.push(w.defines[F]);
    return (
      w.isRawShaderMaterial === !1 &&
        (v(P, w), y(P, w), P.push(n.outputEncoding)),
      P.push(w.customProgramCacheKey),
      P.join()
    );
  }
  function v(w, P) {
    w.push(P.precision),
      w.push(P.outputEncoding),
      w.push(P.envMapMode),
      w.push(P.envMapCubeUVHeight),
      w.push(P.combine),
      w.push(P.vertexUvs),
      w.push(P.fogExp2),
      w.push(P.sizeAttenuation),
      w.push(P.morphTargetsCount),
      w.push(P.morphAttributeCount),
      w.push(P.numDirLights),
      w.push(P.numPointLights),
      w.push(P.numSpotLights),
      w.push(P.numSpotLightMaps),
      w.push(P.numHemiLights),
      w.push(P.numRectAreaLights),
      w.push(P.numDirLightShadows),
      w.push(P.numPointLightShadows),
      w.push(P.numSpotLightShadows),
      w.push(P.numSpotLightShadowsWithMaps),
      w.push(P.shadowMapType),
      w.push(P.toneMapping),
      w.push(P.numClippingPlanes),
      w.push(P.numClipIntersection),
      w.push(P.depthPacking);
  }
  function y(w, P) {
    a.disableAll(),
      P.isWebGL2 && a.enable(0),
      P.supportsVertexTextures && a.enable(1),
      P.instancing && a.enable(2),
      P.instancingColor && a.enable(3),
      P.map && a.enable(4),
      P.matcap && a.enable(5),
      P.envMap && a.enable(6),
      P.lightMap && a.enable(7),
      P.aoMap && a.enable(8),
      P.emissiveMap && a.enable(9),
      P.bumpMap && a.enable(10),
      P.normalMap && a.enable(11),
      P.objectSpaceNormalMap && a.enable(12),
      P.tangentSpaceNormalMap && a.enable(13),
      P.clearcoat && a.enable(14),
      P.clearcoatMap && a.enable(15),
      P.clearcoatRoughnessMap && a.enable(16),
      P.clearcoatNormalMap && a.enable(17),
      P.iridescence && a.enable(18),
      P.iridescenceMap && a.enable(19),
      P.iridescenceThicknessMap && a.enable(20),
      P.displacementMap && a.enable(21),
      P.specularMap && a.enable(22),
      P.roughnessMap && a.enable(23),
      P.metalnessMap && a.enable(24),
      P.gradientMap && a.enable(25),
      P.alphaMap && a.enable(26),
      P.alphaTest && a.enable(27),
      P.vertexColors && a.enable(28),
      P.vertexAlphas && a.enable(29),
      P.vertexUvs && a.enable(30),
      P.vertexTangents && a.enable(31),
      P.uvsVertexOnly && a.enable(32),
      w.push(a.mask),
      a.disableAll(),
      P.fog && a.enable(0),
      P.useFog && a.enable(1),
      P.flatShading && a.enable(2),
      P.logarithmicDepthBuffer && a.enable(3),
      P.skinning && a.enable(4),
      P.morphTargets && a.enable(5),
      P.morphNormals && a.enable(6),
      P.morphColors && a.enable(7),
      P.premultipliedAlpha && a.enable(8),
      P.shadowMapEnabled && a.enable(9),
      P.physicallyCorrectLights && a.enable(10),
      P.doubleSided && a.enable(11),
      P.flipSided && a.enable(12),
      P.useDepthPacking && a.enable(13),
      P.dithering && a.enable(14),
      P.specularIntensityMap && a.enable(15),
      P.specularColorMap && a.enable(16),
      P.transmission && a.enable(17),
      P.transmissionMap && a.enable(18),
      P.thicknessMap && a.enable(19),
      P.sheen && a.enable(20),
      P.sheenColorMap && a.enable(21),
      P.sheenRoughnessMap && a.enable(22),
      P.decodeVideoTexture && a.enable(23),
      P.opaque && a.enable(24),
      w.push(a.mask);
  }
  function _(w) {
    const P = m[w.type];
    let F;
    if (P) {
      const V = mi[P];
      F = bM.clone(V.uniforms);
    } else F = w.uniforms;
    return F;
  }
  function x(w, P) {
    let F;
    for (let V = 0, J = u.length; V < J; V++) {
      const z = u[V];
      if (z.cacheKey === P) {
        (F = z), ++F.usedTimes;
        break;
      }
    }
    return F === void 0 && ((F = new LP(n, P, w, o)), u.push(F)), F;
  }
  function b(w) {
    if (--w.usedTimes === 0) {
      const P = u.indexOf(w);
      (u[P] = u[u.length - 1]), u.pop(), w.destroy();
    }
  }
  function S(w) {
    s.remove(w);
  }
  function T() {
    s.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: f,
    getUniforms: _,
    acquireProgram: x,
    releaseProgram: b,
    releaseShaderCache: S,
    programs: u,
    dispose: T,
  };
}
function FP() {
  let n = new WeakMap();
  function e(o) {
    let p = n.get(o);
    return p === void 0 && ((p = {}), n.set(o, p)), p;
  }
  function t(o) {
    n.delete(o);
  }
  function i(o, p, a) {
    n.get(o)[p] = a;
  }
  function r() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function NP(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function y0(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function _0() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function o() {
    (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
  }
  function p(l, c, h, m, g, f) {
    let v = n[e];
    return (
      v === void 0
        ? ((v = {
            id: l.id,
            object: l,
            geometry: c,
            material: h,
            groupOrder: m,
            renderOrder: l.renderOrder,
            z: g,
            group: f,
          }),
          (n[e] = v))
        : ((v.id = l.id),
          (v.object = l),
          (v.geometry = c),
          (v.material = h),
          (v.groupOrder = m),
          (v.renderOrder = l.renderOrder),
          (v.z = g),
          (v.group = f)),
      e++,
      v
    );
  }
  function a(l, c, h, m, g, f) {
    const v = p(l, c, h, m, g, f);
    h.transmission > 0
      ? i.push(v)
      : h.transparent === !0
      ? r.push(v)
      : t.push(v);
  }
  function s(l, c, h, m, g, f) {
    const v = p(l, c, h, m, g, f);
    h.transmission > 0
      ? i.unshift(v)
      : h.transparent === !0
      ? r.unshift(v)
      : t.unshift(v);
  }
  function u(l, c) {
    t.length > 1 && t.sort(l || NP),
      i.length > 1 && i.sort(c || y0),
      r.length > 1 && r.sort(c || y0);
  }
  function d() {
    for (let l = e, c = n.length; l < c; l++) {
      const h = n[l];
      if (h.id === null) break;
      (h.id = null),
        (h.object = null),
        (h.geometry = null),
        (h.material = null),
        (h.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: o,
    push: a,
    unshift: s,
    finish: d,
    sort: u,
  };
}
function BP() {
  let n = new WeakMap();
  function e(i, r) {
    const o = n.get(i);
    let p;
    return (
      o === void 0
        ? ((p = new _0()), n.set(i, [p]))
        : r >= o.length
        ? ((p = new _0()), o.push(p))
        : (p = o[r]),
      p
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function zP() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new Q(), color: new je() };
          break;
        case "SpotLight":
          t = {
            position: new Q(),
            direction: new Q(),
            color: new je(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new Q(), color: new je(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new Q(), skyColor: new je(), groundColor: new je() };
          break;
        case "RectAreaLight":
          t = {
            color: new je(),
            position: new Q(),
            halfWidth: new Q(),
            halfHeight: new Q(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function UP() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ze(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ze(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ze(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let jP = 0;
function HP(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function VP(n, e) {
  const t = new zP(),
    i = UP(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let d = 0; d < 9; d++) r.probe.push(new Q());
  const o = new Q(),
    p = new Xe(),
    a = new Xe();
  function s(d, l) {
    let c = 0,
      h = 0,
      m = 0;
    for (let V = 0; V < 9; V++) r.probe[V].set(0, 0, 0);
    let g = 0,
      f = 0,
      v = 0,
      y = 0,
      _ = 0,
      x = 0,
      b = 0,
      S = 0,
      T = 0,
      w = 0;
    d.sort(HP);
    const P = l !== !0 ? Math.PI : 1;
    for (let V = 0, J = d.length; V < J; V++) {
      const z = d[V],
        B = z.color,
        G = z.intensity,
        ie = z.distance,
        re = z.shadow && z.shadow.map ? z.shadow.map.texture : null;
      if (z.isAmbientLight)
        (c += B.r * G * P), (h += B.g * G * P), (m += B.b * G * P);
      else if (z.isLightProbe)
        for (let j = 0; j < 9; j++)
          r.probe[j].addScaledVector(z.sh.coefficients[j], G);
      else if (z.isDirectionalLight) {
        const j = t.get(z);
        if (
          (j.color.copy(z.color).multiplyScalar(z.intensity * P), z.castShadow)
        ) {
          const C = z.shadow,
            R = i.get(z);
          (R.shadowBias = C.bias),
            (R.shadowNormalBias = C.normalBias),
            (R.shadowRadius = C.radius),
            (R.shadowMapSize = C.mapSize),
            (r.directionalShadow[g] = R),
            (r.directionalShadowMap[g] = re),
            (r.directionalShadowMatrix[g] = z.shadow.matrix),
            x++;
        }
        (r.directional[g] = j), g++;
      } else if (z.isSpotLight) {
        const j = t.get(z);
        j.position.setFromMatrixPosition(z.matrixWorld),
          j.color.copy(B).multiplyScalar(G * P),
          (j.distance = ie),
          (j.coneCos = Math.cos(z.angle)),
          (j.penumbraCos = Math.cos(z.angle * (1 - z.penumbra))),
          (j.decay = z.decay),
          (r.spot[v] = j);
        const C = z.shadow;
        if (
          (z.map &&
            ((r.spotLightMap[T] = z.map),
            T++,
            C.updateMatrices(z),
            z.castShadow && w++),
          (r.spotLightMatrix[v] = C.matrix),
          z.castShadow)
        ) {
          const R = i.get(z);
          (R.shadowBias = C.bias),
            (R.shadowNormalBias = C.normalBias),
            (R.shadowRadius = C.radius),
            (R.shadowMapSize = C.mapSize),
            (r.spotShadow[v] = R),
            (r.spotShadowMap[v] = re),
            S++;
        }
        v++;
      } else if (z.isRectAreaLight) {
        const j = t.get(z);
        j.color.copy(B).multiplyScalar(G),
          j.halfWidth.set(z.width * 0.5, 0, 0),
          j.halfHeight.set(0, z.height * 0.5, 0),
          (r.rectArea[y] = j),
          y++;
      } else if (z.isPointLight) {
        const j = t.get(z);
        if (
          (j.color.copy(z.color).multiplyScalar(z.intensity * P),
          (j.distance = z.distance),
          (j.decay = z.decay),
          z.castShadow)
        ) {
          const C = z.shadow,
            R = i.get(z);
          (R.shadowBias = C.bias),
            (R.shadowNormalBias = C.normalBias),
            (R.shadowRadius = C.radius),
            (R.shadowMapSize = C.mapSize),
            (R.shadowCameraNear = C.camera.near),
            (R.shadowCameraFar = C.camera.far),
            (r.pointShadow[f] = R),
            (r.pointShadowMap[f] = re),
            (r.pointShadowMatrix[f] = z.shadow.matrix),
            b++;
        }
        (r.point[f] = j), f++;
      } else if (z.isHemisphereLight) {
        const j = t.get(z);
        j.skyColor.copy(z.color).multiplyScalar(G * P),
          j.groundColor.copy(z.groundColor).multiplyScalar(G * P),
          (r.hemi[_] = j),
          _++;
      }
    }
    y > 0 &&
      (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = Te.LTC_FLOAT_1), (r.rectAreaLTC2 = Te.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
        ? ((r.rectAreaLTC1 = Te.LTC_HALF_1), (r.rectAreaLTC2 = Te.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (r.ambient[0] = c),
      (r.ambient[1] = h),
      (r.ambient[2] = m);
    const F = r.hash;
    (F.directionalLength !== g ||
      F.pointLength !== f ||
      F.spotLength !== v ||
      F.rectAreaLength !== y ||
      F.hemiLength !== _ ||
      F.numDirectionalShadows !== x ||
      F.numPointShadows !== b ||
      F.numSpotShadows !== S ||
      F.numSpotMaps !== T) &&
      ((r.directional.length = g),
      (r.spot.length = v),
      (r.rectArea.length = y),
      (r.point.length = f),
      (r.hemi.length = _),
      (r.directionalShadow.length = x),
      (r.directionalShadowMap.length = x),
      (r.pointShadow.length = b),
      (r.pointShadowMap.length = b),
      (r.spotShadow.length = S),
      (r.spotShadowMap.length = S),
      (r.directionalShadowMatrix.length = x),
      (r.pointShadowMatrix.length = b),
      (r.spotLightMatrix.length = S + T - w),
      (r.spotLightMap.length = T),
      (r.numSpotLightShadowsWithMaps = w),
      (F.directionalLength = g),
      (F.pointLength = f),
      (F.spotLength = v),
      (F.rectAreaLength = y),
      (F.hemiLength = _),
      (F.numDirectionalShadows = x),
      (F.numPointShadows = b),
      (F.numSpotShadows = S),
      (F.numSpotMaps = T),
      (r.version = jP++));
  }
  function u(d, l) {
    let c = 0,
      h = 0,
      m = 0,
      g = 0,
      f = 0;
    const v = l.matrixWorldInverse;
    for (let y = 0, _ = d.length; y < _; y++) {
      const x = d[y];
      if (x.isDirectionalLight) {
        const b = r.directional[c];
        b.direction.setFromMatrixPosition(x.matrixWorld),
          o.setFromMatrixPosition(x.target.matrixWorld),
          b.direction.sub(o),
          b.direction.transformDirection(v),
          c++;
      } else if (x.isSpotLight) {
        const b = r.spot[m];
        b.position.setFromMatrixPosition(x.matrixWorld),
          b.position.applyMatrix4(v),
          b.direction.setFromMatrixPosition(x.matrixWorld),
          o.setFromMatrixPosition(x.target.matrixWorld),
          b.direction.sub(o),
          b.direction.transformDirection(v),
          m++;
      } else if (x.isRectAreaLight) {
        const b = r.rectArea[g];
        b.position.setFromMatrixPosition(x.matrixWorld),
          b.position.applyMatrix4(v),
          a.identity(),
          p.copy(x.matrixWorld),
          p.premultiply(v),
          a.extractRotation(p),
          b.halfWidth.set(x.width * 0.5, 0, 0),
          b.halfHeight.set(0, x.height * 0.5, 0),
          b.halfWidth.applyMatrix4(a),
          b.halfHeight.applyMatrix4(a),
          g++;
      } else if (x.isPointLight) {
        const b = r.point[h];
        b.position.setFromMatrixPosition(x.matrixWorld),
          b.position.applyMatrix4(v),
          h++;
      } else if (x.isHemisphereLight) {
        const b = r.hemi[f];
        b.direction.setFromMatrixPosition(x.matrixWorld),
          b.direction.transformDirection(v),
          f++;
      }
    }
  }
  return { setup: s, setupView: u, state: r };
}
function x0(n, e) {
  const t = new VP(n, e),
    i = [],
    r = [];
  function o() {
    (i.length = 0), (r.length = 0);
  }
  function p(l) {
    i.push(l);
  }
  function a(l) {
    r.push(l);
  }
  function s(l) {
    t.setup(i, l);
  }
  function u(l) {
    t.setupView(i, l);
  }
  return {
    init: o,
    state: { lightsArray: i, shadowsArray: r, lights: t },
    setupLights: s,
    setupLightsView: u,
    pushLight: p,
    pushShadow: a,
  };
}
function WP(n, e) {
  let t = new WeakMap();
  function i(o, p = 0) {
    const a = t.get(o);
    let s;
    return (
      a === void 0
        ? ((s = new x0(n, e)), t.set(o, [s]))
        : p >= a.length
        ? ((s = new x0(n, e)), a.push(s))
        : (s = a[p]),
      s
    );
  }
  function r() {
    t = new WeakMap();
  }
  return { get: i, dispose: r };
}
class GP extends Ln {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = WC),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class $P extends Ln {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new Q()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.referencePosition.copy(e.referencePosition),
      (this.nearDistance = e.nearDistance),
      (this.farDistance = e.farDistance),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const XP = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  YP = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function KP(n, e, t) {
  let i = new sm();
  const r = new ze(),
    o = new ze(),
    p = new ht(),
    a = new GP({ depthPacking: GC }),
    s = new $P(),
    u = {},
    d = t.maxTextureSize,
    l = { 0: Xn, 1: _r, 2: Vu },
    c = new ls({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new ze() },
        radius: { value: 4 },
      },
      vertexShader: XP,
      fragmentShader: YP,
    }),
    h = c.clone();
  h.defines.HORIZONTAL_PASS = 1;
  const m = new Rn();
  m.setAttribute(
    "position",
    new Gt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const g = new vn(m, c),
    f = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Mb),
    (this.render = function (x, b, S) {
      if (
        f.enabled === !1 ||
        (f.autoUpdate === !1 && f.needsUpdate === !1) ||
        x.length === 0
      )
        return;
      const T = n.getRenderTarget(),
        w = n.getActiveCubeFace(),
        P = n.getActiveMipmapLevel(),
        F = n.state;
      F.setBlending(gr),
        F.buffers.color.setClear(1, 1, 1, 1),
        F.buffers.depth.setTest(!0),
        F.setScissorTest(!1);
      for (let V = 0, J = x.length; V < J; V++) {
        const z = x[V],
          B = z.shadow;
        if (B === void 0) {
          console.warn("THREE.WebGLShadowMap:", z, "has no shadow.");
          continue;
        }
        if (B.autoUpdate === !1 && B.needsUpdate === !1) continue;
        r.copy(B.mapSize);
        const G = B.getFrameExtents();
        if (
          (r.multiply(G),
          o.copy(B.mapSize),
          (r.x > d || r.y > d) &&
            (r.x > d &&
              ((o.x = Math.floor(d / G.x)),
              (r.x = o.x * G.x),
              (B.mapSize.x = o.x)),
            r.y > d &&
              ((o.y = Math.floor(d / G.y)),
              (r.y = o.y * G.y),
              (B.mapSize.y = o.y))),
          B.map === null)
        ) {
          const re = this.type !== Ca ? { minFilter: zt, magFilter: zt } : {};
          (B.map = new as(r.x, r.y, re)),
            (B.map.texture.name = z.name + ".shadowMap"),
            B.camera.updateProjectionMatrix();
        }
        n.setRenderTarget(B.map), n.clear();
        const ie = B.getViewportCount();
        for (let re = 0; re < ie; re++) {
          const j = B.getViewport(re);
          p.set(o.x * j.x, o.y * j.y, o.x * j.z, o.y * j.w),
            F.viewport(p),
            B.updateMatrices(z, re),
            (i = B.getFrustum()),
            _(b, S, B.camera, z, this.type);
        }
        B.isPointLightShadow !== !0 && this.type === Ca && v(B, S),
          (B.needsUpdate = !1);
      }
      (f.needsUpdate = !1), n.setRenderTarget(T, w, P);
    });
  function v(x, b) {
    const S = e.update(g);
    c.defines.VSM_SAMPLES !== x.blurSamples &&
      ((c.defines.VSM_SAMPLES = x.blurSamples),
      (h.defines.VSM_SAMPLES = x.blurSamples),
      (c.needsUpdate = !0),
      (h.needsUpdate = !0)),
      x.mapPass === null && (x.mapPass = new as(r.x, r.y)),
      (c.uniforms.shadow_pass.value = x.map.texture),
      (c.uniforms.resolution.value = x.mapSize),
      (c.uniforms.radius.value = x.radius),
      n.setRenderTarget(x.mapPass),
      n.clear(),
      n.renderBufferDirect(b, null, S, c, g, null),
      (h.uniforms.shadow_pass.value = x.mapPass.texture),
      (h.uniforms.resolution.value = x.mapSize),
      (h.uniforms.radius.value = x.radius),
      n.setRenderTarget(x.map),
      n.clear(),
      n.renderBufferDirect(b, null, S, h, g, null);
  }
  function y(x, b, S, T, w, P) {
    let F = null;
    const V =
      S.isPointLight === !0 ? x.customDistanceMaterial : x.customDepthMaterial;
    if (V !== void 0) F = V;
    else if (
      ((F = S.isPointLight === !0 ? s : a),
      (n.localClippingEnabled &&
        b.clipShadows === !0 &&
        Array.isArray(b.clippingPlanes) &&
        b.clippingPlanes.length !== 0) ||
        (b.displacementMap && b.displacementScale !== 0) ||
        (b.alphaMap && b.alphaTest > 0) ||
        (b.map && b.alphaTest > 0))
    ) {
      const J = F.uuid,
        z = b.uuid;
      let B = u[J];
      B === void 0 && ((B = {}), (u[J] = B));
      let G = B[z];
      G === void 0 && ((G = F.clone()), (B[z] = G)), (F = G);
    }
    return (
      (F.visible = b.visible),
      (F.wireframe = b.wireframe),
      P === Ca
        ? (F.side = b.shadowSide !== null ? b.shadowSide : b.side)
        : (F.side = b.shadowSide !== null ? b.shadowSide : l[b.side]),
      (F.alphaMap = b.alphaMap),
      (F.alphaTest = b.alphaTest),
      (F.map = b.map),
      (F.clipShadows = b.clipShadows),
      (F.clippingPlanes = b.clippingPlanes),
      (F.clipIntersection = b.clipIntersection),
      (F.displacementMap = b.displacementMap),
      (F.displacementScale = b.displacementScale),
      (F.displacementBias = b.displacementBias),
      (F.wireframeLinewidth = b.wireframeLinewidth),
      (F.linewidth = b.linewidth),
      S.isPointLight === !0 &&
        F.isMeshDistanceMaterial === !0 &&
        (F.referencePosition.setFromMatrixPosition(S.matrixWorld),
        (F.nearDistance = T),
        (F.farDistance = w)),
      F
    );
  }
  function _(x, b, S, T, w) {
    if (x.visible === !1) return;
    if (
      x.layers.test(b.layers) &&
      (x.isMesh || x.isLine || x.isPoints) &&
      (x.castShadow || (x.receiveShadow && w === Ca)) &&
      (!x.frustumCulled || i.intersectsObject(x))
    ) {
      x.modelViewMatrix.multiplyMatrices(S.matrixWorldInverse, x.matrixWorld);
      const V = e.update(x),
        J = x.material;
      if (Array.isArray(J)) {
        const z = V.groups;
        for (let B = 0, G = z.length; B < G; B++) {
          const ie = z[B],
            re = J[ie.materialIndex];
          if (re && re.visible) {
            const j = y(x, re, T, S.near, S.far, w);
            n.renderBufferDirect(S, null, V, j, x, ie);
          }
        }
      } else if (J.visible) {
        const z = y(x, J, T, S.near, S.far, w);
        n.renderBufferDirect(S, null, V, z, x, null);
      }
    }
    const F = x.children;
    for (let V = 0, J = F.length; V < J; V++) _(F[V], b, S, T, w);
  }
}
function qP(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let q = !1;
    const fe = new ht();
    let xe = null;
    const Ae = new ht(0, 0, 0, 0);
    return {
      setMask: function (Ie) {
        xe !== Ie && !q && (n.colorMask(Ie, Ie, Ie, Ie), (xe = Ie));
      },
      setLocked: function (Ie) {
        q = Ie;
      },
      setClear: function (Ie, et, Ct, Xt, Cr) {
        Cr === !0 && ((Ie *= Xt), (et *= Xt), (Ct *= Xt)),
          fe.set(Ie, et, Ct, Xt),
          Ae.equals(fe) === !1 && (n.clearColor(Ie, et, Ct, Xt), Ae.copy(fe));
      },
      reset: function () {
        (q = !1), (xe = null), Ae.set(-1, 0, 0, 0);
      },
    };
  }
  function o() {
    let q = !1,
      fe = null,
      xe = null,
      Ae = null;
    return {
      setTest: function (Ie) {
        Ie ? $(2929) : Y(2929);
      },
      setMask: function (Ie) {
        fe !== Ie && !q && (n.depthMask(Ie), (fe = Ie));
      },
      setFunc: function (Ie) {
        if (xe !== Ie) {
          switch (Ie) {
            case dC:
              n.depthFunc(512);
              break;
            case pC:
              n.depthFunc(519);
              break;
            case mC:
              n.depthFunc(513);
              break;
            case Nd:
              n.depthFunc(515);
              break;
            case gC:
              n.depthFunc(514);
              break;
            case vC:
              n.depthFunc(518);
              break;
            case yC:
              n.depthFunc(516);
              break;
            case _C:
              n.depthFunc(517);
              break;
            default:
              n.depthFunc(515);
          }
          xe = Ie;
        }
      },
      setLocked: function (Ie) {
        q = Ie;
      },
      setClear: function (Ie) {
        Ae !== Ie && (n.clearDepth(Ie), (Ae = Ie));
      },
      reset: function () {
        (q = !1), (fe = null), (xe = null), (Ae = null);
      },
    };
  }
  function p() {
    let q = !1,
      fe = null,
      xe = null,
      Ae = null,
      Ie = null,
      et = null,
      Ct = null,
      Xt = null,
      Cr = null;
    return {
      setTest: function (yt) {
        q || (yt ? $(2960) : Y(2960));
      },
      setMask: function (yt) {
        fe !== yt && !q && (n.stencilMask(yt), (fe = yt));
      },
      setFunc: function (yt, wi, Nn) {
        (xe !== yt || Ae !== wi || Ie !== Nn) &&
          (n.stencilFunc(yt, wi, Nn), (xe = yt), (Ae = wi), (Ie = Nn));
      },
      setOp: function (yt, wi, Nn) {
        (et !== yt || Ct !== wi || Xt !== Nn) &&
          (n.stencilOp(yt, wi, Nn), (et = yt), (Ct = wi), (Xt = Nn));
      },
      setLocked: function (yt) {
        q = yt;
      },
      setClear: function (yt) {
        Cr !== yt && (n.clearStencil(yt), (Cr = yt));
      },
      reset: function () {
        (q = !1),
          (fe = null),
          (xe = null),
          (Ae = null),
          (Ie = null),
          (et = null),
          (Ct = null),
          (Xt = null),
          (Cr = null);
      },
    };
  }
  const a = new r(),
    s = new o(),
    u = new p(),
    d = new WeakMap(),
    l = new WeakMap();
  let c = {},
    h = {},
    m = new WeakMap(),
    g = [],
    f = null,
    v = !1,
    y = null,
    _ = null,
    x = null,
    b = null,
    S = null,
    T = null,
    w = null,
    P = !1,
    F = null,
    V = null,
    J = null,
    z = null,
    B = null;
  const G = n.getParameter(35661);
  let ie = !1,
    re = 0;
  const j = n.getParameter(7938);
  j.indexOf("WebGL") !== -1
    ? ((re = parseFloat(/^WebGL (\d)/.exec(j)[1])), (ie = re >= 1))
    : j.indexOf("OpenGL ES") !== -1 &&
      ((re = parseFloat(/^OpenGL ES (\d)/.exec(j)[1])), (ie = re >= 2));
  let C = null,
    R = {};
  const A = n.getParameter(3088),
    O = n.getParameter(2978),
    H = new ht().fromArray(A),
    I = new ht().fromArray(O);
  function E(q, fe, xe) {
    const Ae = new Uint8Array(4),
      Ie = n.createTexture();
    n.bindTexture(q, Ie),
      n.texParameteri(q, 10241, 9728),
      n.texParameteri(q, 10240, 9728);
    for (let et = 0; et < xe; et++)
      n.texImage2D(fe + et, 0, 6408, 1, 1, 0, 6408, 5121, Ae);
    return Ie;
  }
  const k = {};
  (k[3553] = E(3553, 3553, 1)),
    (k[34067] = E(34067, 34069, 6)),
    a.setClear(0, 0, 0, 1),
    s.setClear(1),
    u.setClear(0),
    $(2929),
    s.setFunc(Nd),
    ue(!1),
    oe(hv),
    $(2884),
    K(gr);
  function $(q) {
    c[q] !== !0 && (n.enable(q), (c[q] = !0));
  }
  function Y(q) {
    c[q] !== !1 && (n.disable(q), (c[q] = !1));
  }
  function X(q, fe) {
    return h[q] !== fe
      ? (n.bindFramebuffer(q, fe),
        (h[q] = fe),
        i && (q === 36009 && (h[36160] = fe), q === 36160 && (h[36009] = fe)),
        !0)
      : !1;
  }
  function ee(q, fe) {
    let xe = g,
      Ae = !1;
    if (q)
      if (
        ((xe = m.get(fe)),
        xe === void 0 && ((xe = []), m.set(fe, xe)),
        q.isWebGLMultipleRenderTargets)
      ) {
        const Ie = q.texture;
        if (xe.length !== Ie.length || xe[0] !== 36064) {
          for (let et = 0, Ct = Ie.length; et < Ct; et++) xe[et] = 36064 + et;
          (xe.length = Ie.length), (Ae = !0);
        }
      } else xe[0] !== 36064 && ((xe[0] = 36064), (Ae = !0));
    else xe[0] !== 1029 && ((xe[0] = 1029), (Ae = !0));
    Ae &&
      (t.isWebGL2
        ? n.drawBuffers(xe)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(xe));
  }
  function he(q) {
    return f !== q ? (n.useProgram(q), (f = q), !0) : !1;
  }
  const pe = { [ks]: 32774, [nC]: 32778, [iC]: 32779 };
  if (i) (pe[mv] = 32775), (pe[gv] = 32776);
  else {
    const q = e.get("EXT_blend_minmax");
    q !== null && ((pe[mv] = q.MIN_EXT), (pe[gv] = q.MAX_EXT));
  }
  const Z = {
    [rC]: 0,
    [sC]: 1,
    [oC]: 768,
    [Eb]: 770,
    [fC]: 776,
    [uC]: 774,
    [lC]: 772,
    [aC]: 769,
    [Ab]: 771,
    [hC]: 775,
    [cC]: 773,
  };
  function K(q, fe, xe, Ae, Ie, et, Ct, Xt) {
    if (q === gr) {
      v === !0 && (Y(3042), (v = !1));
      return;
    }
    if ((v === !1 && ($(3042), (v = !0)), q !== tC)) {
      if (q !== y || Xt !== P) {
        if (
          ((_ !== ks || S !== ks) &&
            (n.blendEquation(32774), (_ = ks), (S = ks)),
          Xt)
        )
          switch (q) {
            case ro:
              n.blendFuncSeparate(1, 771, 1, 771);
              break;
            case fv:
              n.blendFunc(1, 1);
              break;
            case dv:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case pv:
              n.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
        else
          switch (q) {
            case ro:
              n.blendFuncSeparate(770, 771, 1, 771);
              break;
            case fv:
              n.blendFunc(770, 1);
              break;
            case dv:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case pv:
              n.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", q);
              break;
          }
        (x = null), (b = null), (T = null), (w = null), (y = q), (P = Xt);
      }
      return;
    }
    (Ie = Ie || fe),
      (et = et || xe),
      (Ct = Ct || Ae),
      (fe !== _ || Ie !== S) &&
        (n.blendEquationSeparate(pe[fe], pe[Ie]), (_ = fe), (S = Ie)),
      (xe !== x || Ae !== b || et !== T || Ct !== w) &&
        (n.blendFuncSeparate(Z[xe], Z[Ae], Z[et], Z[Ct]),
        (x = xe),
        (b = Ae),
        (T = et),
        (w = Ct)),
      (y = q),
      (P = !1);
  }
  function ce(q, fe) {
    q.side === Vu ? Y(2884) : $(2884);
    let xe = q.side === Xn;
    fe && (xe = !xe),
      ue(xe),
      q.blending === ro && q.transparent === !1
        ? K(gr)
        : K(
            q.blending,
            q.blendEquation,
            q.blendSrc,
            q.blendDst,
            q.blendEquationAlpha,
            q.blendSrcAlpha,
            q.blendDstAlpha,
            q.premultipliedAlpha
          ),
      s.setFunc(q.depthFunc),
      s.setTest(q.depthTest),
      s.setMask(q.depthWrite),
      a.setMask(q.colorWrite);
    const Ae = q.stencilWrite;
    u.setTest(Ae),
      Ae &&
        (u.setMask(q.stencilWriteMask),
        u.setFunc(q.stencilFunc, q.stencilRef, q.stencilFuncMask),
        u.setOp(q.stencilFail, q.stencilZFail, q.stencilZPass)),
      ge(q.polygonOffset, q.polygonOffsetFactor, q.polygonOffsetUnits),
      q.alphaToCoverage === !0 ? $(32926) : Y(32926);
  }
  function ue(q) {
    F !== q && (q ? n.frontFace(2304) : n.frontFace(2305), (F = q));
  }
  function oe(q) {
    q !== JT
      ? ($(2884),
        q !== V &&
          (q === hv
            ? n.cullFace(1029)
            : q === QT
            ? n.cullFace(1028)
            : n.cullFace(1032)))
      : Y(2884),
      (V = q);
  }
  function le(q) {
    q !== J && (ie && n.lineWidth(q), (J = q));
  }
  function ge(q, fe, xe) {
    q
      ? ($(32823),
        (z !== fe || B !== xe) && (n.polygonOffset(fe, xe), (z = fe), (B = xe)))
      : Y(32823);
  }
  function Re(q) {
    q ? $(3089) : Y(3089);
  }
  function Me(q) {
    q === void 0 && (q = 33984 + G - 1),
      C !== q && (n.activeTexture(q), (C = q));
  }
  function L(q, fe, xe) {
    xe === void 0 && (C === null ? (xe = 33984 + G - 1) : (xe = C));
    let Ae = R[xe];
    Ae === void 0 && ((Ae = { type: void 0, texture: void 0 }), (R[xe] = Ae)),
      (Ae.type !== q || Ae.texture !== fe) &&
        (C !== xe && (n.activeTexture(xe), (C = xe)),
        n.bindTexture(q, fe || k[q]),
        (Ae.type = q),
        (Ae.texture = fe));
  }
  function D() {
    const q = R[C];
    q !== void 0 &&
      q.type !== void 0 &&
      (n.bindTexture(q.type, null), (q.type = void 0), (q.texture = void 0));
  }
  function ne() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function de() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function ye() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function _e() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Pe() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function U() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function te() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function we() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Se() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Ee() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (q) {
      console.error("THREE.WebGLState:", q);
    }
  }
  function Le(q) {
    H.equals(q) === !1 && (n.scissor(q.x, q.y, q.z, q.w), H.copy(q));
  }
  function De(q) {
    I.equals(q) === !1 && (n.viewport(q.x, q.y, q.z, q.w), I.copy(q));
  }
  function He(q, fe) {
    let xe = l.get(fe);
    xe === void 0 && ((xe = new WeakMap()), l.set(fe, xe));
    let Ae = xe.get(q);
    Ae === void 0 && ((Ae = n.getUniformBlockIndex(fe, q.name)), xe.set(q, Ae));
  }
  function We(q, fe) {
    const Ae = l.get(fe).get(q);
    d.get(fe) !== Ae &&
      (n.uniformBlockBinding(fe, Ae, q.__bindingPointIndex), d.set(fe, Ae));
  }
  function it() {
    n.disable(3042),
      n.disable(2884),
      n.disable(2929),
      n.disable(32823),
      n.disable(3089),
      n.disable(2960),
      n.disable(32926),
      n.blendEquation(32774),
      n.blendFunc(1, 0),
      n.blendFuncSeparate(1, 0, 1, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(513),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(519, 0, 4294967295),
      n.stencilOp(7680, 7680, 7680),
      n.clearStencil(0),
      n.cullFace(1029),
      n.frontFace(2305),
      n.polygonOffset(0, 0),
      n.activeTexture(33984),
      n.bindFramebuffer(36160, null),
      i === !0 &&
        (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (c = {}),
      (C = null),
      (R = {}),
      (h = {}),
      (m = new WeakMap()),
      (g = []),
      (f = null),
      (v = !1),
      (y = null),
      (_ = null),
      (x = null),
      (b = null),
      (S = null),
      (T = null),
      (w = null),
      (P = !1),
      (F = null),
      (V = null),
      (J = null),
      (z = null),
      (B = null),
      H.set(0, 0, n.canvas.width, n.canvas.height),
      I.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      s.reset(),
      u.reset();
  }
  return {
    buffers: { color: a, depth: s, stencil: u },
    enable: $,
    disable: Y,
    bindFramebuffer: X,
    drawBuffers: ee,
    useProgram: he,
    setBlending: K,
    setMaterial: ce,
    setFlipSided: ue,
    setCullFace: oe,
    setLineWidth: le,
    setPolygonOffset: ge,
    setScissorTest: Re,
    activeTexture: Me,
    bindTexture: L,
    unbindTexture: D,
    compressedTexImage2D: ne,
    compressedTexImage3D: de,
    texImage2D: Se,
    texImage3D: Ee,
    updateUBOMapping: He,
    uniformBlockBinding: We,
    texStorage2D: te,
    texStorage3D: we,
    texSubImage2D: ye,
    texSubImage3D: _e,
    compressedTexSubImage2D: Pe,
    compressedTexSubImage3D: U,
    scissor: Le,
    viewport: De,
    reset: it,
  };
}
function ZP(n, e, t, i, r, o, p) {
  const a = r.isWebGL2,
    s = r.maxTextures,
    u = r.maxCubemapSize,
    d = r.maxTextureSize,
    l = r.maxSamples,
    c = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    h =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    m = new WeakMap();
  let g;
  const f = new WeakMap();
  let v = !1;
  try {
    v =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function y(L, D) {
    return v ? new OffscreenCanvas(L, D) : ll("canvas");
  }
  function _(L, D, ne, de) {
    let ye = 1;
    if (
      ((L.width > de || L.height > de) &&
        (ye = de / Math.max(L.width, L.height)),
      ye < 1 || D === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && L instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && L instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && L instanceof ImageBitmap)
      ) {
        const _e = D ? xu : Math.floor,
          Pe = _e(ye * L.width),
          U = _e(ye * L.height);
        g === void 0 && (g = y(Pe, U));
        const te = ne ? y(Pe, U) : g;
        return (
          (te.width = Pe),
          (te.height = U),
          te.getContext("2d").drawImage(L, 0, 0, Pe, U),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              L.width +
              "x" +
              L.height +
              ") to (" +
              Pe +
              "x" +
              U +
              ")."
          ),
          te
        );
      } else
        return (
          "data" in L &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                L.width +
                "x" +
                L.height +
                ")."
            ),
          L
        );
    return L;
  }
  function x(L) {
    return Vd(L.width) && Vd(L.height);
  }
  function b(L) {
    return a
      ? !1
      : L.wrapS !== Vn ||
          L.wrapT !== Vn ||
          (L.minFilter !== zt && L.minFilter !== mn);
  }
  function S(L, D) {
    return L.generateMipmaps && D && L.minFilter !== zt && L.minFilter !== mn;
  }
  function T(L) {
    n.generateMipmap(L);
  }
  function w(L, D, ne, de, ye = !1) {
    if (a === !1) return D;
    if (L !== null) {
      if (n[L] !== void 0) return n[L];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          L +
          "'"
      );
    }
    let _e = D;
    return (
      D === 6403 &&
        (ne === 5126 && (_e = 33326),
        ne === 5131 && (_e = 33325),
        ne === 5121 && (_e = 33321)),
      D === 33319 &&
        (ne === 5126 && (_e = 33328),
        ne === 5131 && (_e = 33327),
        ne === 5121 && (_e = 33323)),
      D === 6408 &&
        (ne === 5126 && (_e = 34836),
        ne === 5131 && (_e = 34842),
        ne === 5121 && (_e = de === ot && ye === !1 ? 35907 : 32856),
        ne === 32819 && (_e = 32854),
        ne === 32820 && (_e = 32855)),
      (_e === 33325 ||
        _e === 33326 ||
        _e === 33327 ||
        _e === 33328 ||
        _e === 34842 ||
        _e === 34836) &&
        e.get("EXT_color_buffer_float"),
      _e
    );
  }
  function P(L, D, ne) {
    return S(L, ne) === !0 ||
      (L.isFramebufferTexture && L.minFilter !== zt && L.minFilter !== mn)
      ? Math.log2(Math.max(D.width, D.height)) + 1
      : L.mipmaps !== void 0 && L.mipmaps.length > 0
      ? L.mipmaps.length
      : L.isCompressedTexture && Array.isArray(L.image)
      ? D.mipmaps.length
      : 1;
  }
  function F(L) {
    return L === zt || L === Ud || L === jc ? 9728 : 9729;
  }
  function V(L) {
    const D = L.target;
    D.removeEventListener("dispose", V), z(D), D.isVideoTexture && m.delete(D);
  }
  function J(L) {
    const D = L.target;
    D.removeEventListener("dispose", J), G(D);
  }
  function z(L) {
    const D = i.get(L);
    if (D.__webglInit === void 0) return;
    const ne = L.source,
      de = f.get(ne);
    if (de) {
      const ye = de[D.__cacheKey];
      ye.usedTimes--,
        ye.usedTimes === 0 && B(L),
        Object.keys(de).length === 0 && f.delete(ne);
    }
    i.remove(L);
  }
  function B(L) {
    const D = i.get(L);
    n.deleteTexture(D.__webglTexture);
    const ne = L.source,
      de = f.get(ne);
    delete de[D.__cacheKey], p.memory.textures--;
  }
  function G(L) {
    const D = L.texture,
      ne = i.get(L),
      de = i.get(D);
    if (
      (de.__webglTexture !== void 0 &&
        (n.deleteTexture(de.__webglTexture), p.memory.textures--),
      L.depthTexture && L.depthTexture.dispose(),
      L.isWebGLCubeRenderTarget)
    )
      for (let ye = 0; ye < 6; ye++)
        n.deleteFramebuffer(ne.__webglFramebuffer[ye]),
          ne.__webglDepthbuffer &&
            n.deleteRenderbuffer(ne.__webglDepthbuffer[ye]);
    else {
      if (
        (n.deleteFramebuffer(ne.__webglFramebuffer),
        ne.__webglDepthbuffer && n.deleteRenderbuffer(ne.__webglDepthbuffer),
        ne.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(ne.__webglMultisampledFramebuffer),
        ne.__webglColorRenderbuffer)
      )
        for (let ye = 0; ye < ne.__webglColorRenderbuffer.length; ye++)
          ne.__webglColorRenderbuffer[ye] &&
            n.deleteRenderbuffer(ne.__webglColorRenderbuffer[ye]);
      ne.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(ne.__webglDepthRenderbuffer);
    }
    if (L.isWebGLMultipleRenderTargets)
      for (let ye = 0, _e = D.length; ye < _e; ye++) {
        const Pe = i.get(D[ye]);
        Pe.__webglTexture &&
          (n.deleteTexture(Pe.__webglTexture), p.memory.textures--),
          i.remove(D[ye]);
      }
    i.remove(D), i.remove(L);
  }
  let ie = 0;
  function re() {
    ie = 0;
  }
  function j() {
    const L = ie;
    return (
      L >= s &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            L +
            " texture units while this GPU supports only " +
            s
        ),
      (ie += 1),
      L
    );
  }
  function C(L) {
    const D = [];
    return (
      D.push(L.wrapS),
      D.push(L.wrapT),
      D.push(L.wrapR || 0),
      D.push(L.magFilter),
      D.push(L.minFilter),
      D.push(L.anisotropy),
      D.push(L.internalFormat),
      D.push(L.format),
      D.push(L.type),
      D.push(L.generateMipmaps),
      D.push(L.premultiplyAlpha),
      D.push(L.flipY),
      D.push(L.unpackAlignment),
      D.push(L.encoding),
      D.join()
    );
  }
  function R(L, D) {
    const ne = i.get(L);
    if (
      (L.isVideoTexture && Re(L),
      L.isRenderTargetTexture === !1 &&
        L.version > 0 &&
        ne.__version !== L.version)
    ) {
      const de = L.image;
      if (de === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (de.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Y(ne, L, D);
        return;
      }
    }
    t.bindTexture(3553, ne.__webglTexture, 33984 + D);
  }
  function A(L, D) {
    const ne = i.get(L);
    if (L.version > 0 && ne.__version !== L.version) {
      Y(ne, L, D);
      return;
    }
    t.bindTexture(35866, ne.__webglTexture, 33984 + D);
  }
  function O(L, D) {
    const ne = i.get(L);
    if (L.version > 0 && ne.__version !== L.version) {
      Y(ne, L, D);
      return;
    }
    t.bindTexture(32879, ne.__webglTexture, 33984 + D);
  }
  function H(L, D) {
    const ne = i.get(L);
    if (L.version > 0 && ne.__version !== L.version) {
      X(ne, L, D);
      return;
    }
    t.bindTexture(34067, ne.__webglTexture, 33984 + D);
  }
  const I = { [xo]: 10497, [Vn]: 33071, [_u]: 33648 },
    E = {
      [zt]: 9728,
      [Ud]: 9984,
      [jc]: 9986,
      [mn]: 9729,
      [Ob]: 9985,
      [rs]: 9987,
    };
  function k(L, D, ne) {
    if (
      (ne
        ? (n.texParameteri(L, 10242, I[D.wrapS]),
          n.texParameteri(L, 10243, I[D.wrapT]),
          (L === 32879 || L === 35866) && n.texParameteri(L, 32882, I[D.wrapR]),
          n.texParameteri(L, 10240, E[D.magFilter]),
          n.texParameteri(L, 10241, E[D.minFilter]))
        : (n.texParameteri(L, 10242, 33071),
          n.texParameteri(L, 10243, 33071),
          (L === 32879 || L === 35866) && n.texParameteri(L, 32882, 33071),
          (D.wrapS !== Vn || D.wrapT !== Vn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri(L, 10240, F(D.magFilter)),
          n.texParameteri(L, 10241, F(D.minFilter)),
          D.minFilter !== zt &&
            D.minFilter !== mn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const de = e.get("EXT_texture_filter_anisotropic");
      if (
        D.magFilter === zt ||
        (D.minFilter !== jc && D.minFilter !== rs) ||
        (D.type === or && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          D.type === rl &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (D.anisotropy > 1 || i.get(D).__currentAnisotropy) &&
        (n.texParameterf(
          L,
          de.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(D.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(D).__currentAnisotropy = D.anisotropy));
    }
  }
  function $(L, D) {
    let ne = !1;
    L.__webglInit === void 0 &&
      ((L.__webglInit = !0), D.addEventListener("dispose", V));
    const de = D.source;
    let ye = f.get(de);
    ye === void 0 && ((ye = {}), f.set(de, ye));
    const _e = C(D);
    if (_e !== L.__cacheKey) {
      ye[_e] === void 0 &&
        ((ye[_e] = { texture: n.createTexture(), usedTimes: 0 }),
        p.memory.textures++,
        (ne = !0)),
        ye[_e].usedTimes++;
      const Pe = ye[L.__cacheKey];
      Pe !== void 0 &&
        (ye[L.__cacheKey].usedTimes--, Pe.usedTimes === 0 && B(D)),
        (L.__cacheKey = _e),
        (L.__webglTexture = ye[_e].texture);
    }
    return ne;
  }
  function Y(L, D, ne) {
    let de = 3553;
    (D.isDataArrayTexture || D.isCompressedArrayTexture) && (de = 35866),
      D.isData3DTexture && (de = 32879);
    const ye = $(L, D),
      _e = D.source;
    t.bindTexture(de, L.__webglTexture, 33984 + ne);
    const Pe = i.get(_e);
    if (_e.version !== Pe.__version || ye === !0) {
      t.activeTexture(33984 + ne),
        n.pixelStorei(37440, D.flipY),
        n.pixelStorei(37441, D.premultiplyAlpha),
        n.pixelStorei(3317, D.unpackAlignment),
        n.pixelStorei(37443, 0);
      const U = b(D) && x(D.image) === !1;
      let te = _(D.image, U, !1, d);
      te = Me(D, te);
      const we = x(te) || a,
        Se = o.convert(D.format, D.encoding);
      let Ee = o.convert(D.type),
        Le = w(D.internalFormat, Se, Ee, D.encoding, D.isVideoTexture);
      k(de, D, we);
      let De;
      const He = D.mipmaps,
        We = a && D.isVideoTexture !== !0,
        it = Pe.__version === void 0 || ye === !0,
        q = P(D, te, we);
      if (D.isDepthTexture)
        (Le = 6402),
          a
            ? D.type === or
              ? (Le = 36012)
              : D.type === Wr
              ? (Le = 33190)
              : D.type === so
              ? (Le = 35056)
              : (Le = 33189)
            : D.type === or &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          D.format === Kr &&
            Le === 6402 &&
            D.type !== Lb &&
            D.type !== Wr &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (D.type = Wr),
            (Ee = o.convert(D.type))),
          D.format === bo &&
            Le === 6402 &&
            ((Le = 34041),
            D.type !== so &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (D.type = so),
              (Ee = o.convert(D.type)))),
          it &&
            (We
              ? t.texStorage2D(3553, 1, Le, te.width, te.height)
              : t.texImage2D(
                  3553,
                  0,
                  Le,
                  te.width,
                  te.height,
                  0,
                  Se,
                  Ee,
                  null
                ));
      else if (D.isDataTexture)
        if (He.length > 0 && we) {
          We && it && t.texStorage2D(3553, q, Le, He[0].width, He[0].height);
          for (let fe = 0, xe = He.length; fe < xe; fe++)
            (De = He[fe]),
              We
                ? t.texSubImage2D(
                    3553,
                    fe,
                    0,
                    0,
                    De.width,
                    De.height,
                    Se,
                    Ee,
                    De.data
                  )
                : t.texImage2D(
                    3553,
                    fe,
                    Le,
                    De.width,
                    De.height,
                    0,
                    Se,
                    Ee,
                    De.data
                  );
          D.generateMipmaps = !1;
        } else
          We
            ? (it && t.texStorage2D(3553, q, Le, te.width, te.height),
              t.texSubImage2D(
                3553,
                0,
                0,
                0,
                te.width,
                te.height,
                Se,
                Ee,
                te.data
              ))
            : t.texImage2D(
                3553,
                0,
                Le,
                te.width,
                te.height,
                0,
                Se,
                Ee,
                te.data
              );
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          We &&
            it &&
            t.texStorage3D(35866, q, Le, He[0].width, He[0].height, te.depth);
          for (let fe = 0, xe = He.length; fe < xe; fe++)
            (De = He[fe]),
              D.format !== Wn
                ? Se !== null
                  ? We
                    ? t.compressedTexSubImage3D(
                        35866,
                        fe,
                        0,
                        0,
                        0,
                        De.width,
                        De.height,
                        te.depth,
                        Se,
                        De.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        35866,
                        fe,
                        Le,
                        De.width,
                        De.height,
                        te.depth,
                        0,
                        De.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : We
                ? t.texSubImage3D(
                    35866,
                    fe,
                    0,
                    0,
                    0,
                    De.width,
                    De.height,
                    te.depth,
                    Se,
                    Ee,
                    De.data
                  )
                : t.texImage3D(
                    35866,
                    fe,
                    Le,
                    De.width,
                    De.height,
                    te.depth,
                    0,
                    Se,
                    Ee,
                    De.data
                  );
        } else {
          We && it && t.texStorage2D(3553, q, Le, He[0].width, He[0].height);
          for (let fe = 0, xe = He.length; fe < xe; fe++)
            (De = He[fe]),
              D.format !== Wn
                ? Se !== null
                  ? We
                    ? t.compressedTexSubImage2D(
                        3553,
                        fe,
                        0,
                        0,
                        De.width,
                        De.height,
                        Se,
                        De.data
                      )
                    : t.compressedTexImage2D(
                        3553,
                        fe,
                        Le,
                        De.width,
                        De.height,
                        0,
                        De.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : We
                ? t.texSubImage2D(
                    3553,
                    fe,
                    0,
                    0,
                    De.width,
                    De.height,
                    Se,
                    Ee,
                    De.data
                  )
                : t.texImage2D(
                    3553,
                    fe,
                    Le,
                    De.width,
                    De.height,
                    0,
                    Se,
                    Ee,
                    De.data
                  );
        }
      else if (D.isDataArrayTexture)
        We
          ? (it && t.texStorage3D(35866, q, Le, te.width, te.height, te.depth),
            t.texSubImage3D(
              35866,
              0,
              0,
              0,
              0,
              te.width,
              te.height,
              te.depth,
              Se,
              Ee,
              te.data
            ))
          : t.texImage3D(
              35866,
              0,
              Le,
              te.width,
              te.height,
              te.depth,
              0,
              Se,
              Ee,
              te.data
            );
      else if (D.isData3DTexture)
        We
          ? (it && t.texStorage3D(32879, q, Le, te.width, te.height, te.depth),
            t.texSubImage3D(
              32879,
              0,
              0,
              0,
              0,
              te.width,
              te.height,
              te.depth,
              Se,
              Ee,
              te.data
            ))
          : t.texImage3D(
              32879,
              0,
              Le,
              te.width,
              te.height,
              te.depth,
              0,
              Se,
              Ee,
              te.data
            );
      else if (D.isFramebufferTexture) {
        if (it)
          if (We) t.texStorage2D(3553, q, Le, te.width, te.height);
          else {
            let fe = te.width,
              xe = te.height;
            for (let Ae = 0; Ae < q; Ae++)
              t.texImage2D(3553, Ae, Le, fe, xe, 0, Se, Ee, null),
                (fe >>= 1),
                (xe >>= 1);
          }
      } else if (He.length > 0 && we) {
        We && it && t.texStorage2D(3553, q, Le, He[0].width, He[0].height);
        for (let fe = 0, xe = He.length; fe < xe; fe++)
          (De = He[fe]),
            We
              ? t.texSubImage2D(3553, fe, 0, 0, Se, Ee, De)
              : t.texImage2D(3553, fe, Le, Se, Ee, De);
        D.generateMipmaps = !1;
      } else
        We
          ? (it && t.texStorage2D(3553, q, Le, te.width, te.height),
            t.texSubImage2D(3553, 0, 0, 0, Se, Ee, te))
          : t.texImage2D(3553, 0, Le, Se, Ee, te);
      S(D, we) && T(de),
        (Pe.__version = _e.version),
        D.onUpdate && D.onUpdate(D);
    }
    L.__version = D.version;
  }
  function X(L, D, ne) {
    if (D.image.length !== 6) return;
    const de = $(L, D),
      ye = D.source;
    t.bindTexture(34067, L.__webglTexture, 33984 + ne);
    const _e = i.get(ye);
    if (ye.version !== _e.__version || de === !0) {
      t.activeTexture(33984 + ne),
        n.pixelStorei(37440, D.flipY),
        n.pixelStorei(37441, D.premultiplyAlpha),
        n.pixelStorei(3317, D.unpackAlignment),
        n.pixelStorei(37443, 0);
      const Pe = D.isCompressedTexture || D.image[0].isCompressedTexture,
        U = D.image[0] && D.image[0].isDataTexture,
        te = [];
      for (let fe = 0; fe < 6; fe++)
        !Pe && !U
          ? (te[fe] = _(D.image[fe], !1, !0, u))
          : (te[fe] = U ? D.image[fe].image : D.image[fe]),
          (te[fe] = Me(D, te[fe]));
      const we = te[0],
        Se = x(we) || a,
        Ee = o.convert(D.format, D.encoding),
        Le = o.convert(D.type),
        De = w(D.internalFormat, Ee, Le, D.encoding),
        He = a && D.isVideoTexture !== !0,
        We = _e.__version === void 0 || de === !0;
      let it = P(D, we, Se);
      k(34067, D, Se);
      let q;
      if (Pe) {
        He && We && t.texStorage2D(34067, it, De, we.width, we.height);
        for (let fe = 0; fe < 6; fe++) {
          q = te[fe].mipmaps;
          for (let xe = 0; xe < q.length; xe++) {
            const Ae = q[xe];
            D.format !== Wn
              ? Ee !== null
                ? He
                  ? t.compressedTexSubImage2D(
                      34069 + fe,
                      xe,
                      0,
                      0,
                      Ae.width,
                      Ae.height,
                      Ee,
                      Ae.data
                    )
                  : t.compressedTexImage2D(
                      34069 + fe,
                      xe,
                      De,
                      Ae.width,
                      Ae.height,
                      0,
                      Ae.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : He
              ? t.texSubImage2D(
                  34069 + fe,
                  xe,
                  0,
                  0,
                  Ae.width,
                  Ae.height,
                  Ee,
                  Le,
                  Ae.data
                )
              : t.texImage2D(
                  34069 + fe,
                  xe,
                  De,
                  Ae.width,
                  Ae.height,
                  0,
                  Ee,
                  Le,
                  Ae.data
                );
          }
        }
      } else {
        (q = D.mipmaps),
          He &&
            We &&
            (q.length > 0 && it++,
            t.texStorage2D(34067, it, De, te[0].width, te[0].height));
        for (let fe = 0; fe < 6; fe++)
          if (U) {
            He
              ? t.texSubImage2D(
                  34069 + fe,
                  0,
                  0,
                  0,
                  te[fe].width,
                  te[fe].height,
                  Ee,
                  Le,
                  te[fe].data
                )
              : t.texImage2D(
                  34069 + fe,
                  0,
                  De,
                  te[fe].width,
                  te[fe].height,
                  0,
                  Ee,
                  Le,
                  te[fe].data
                );
            for (let xe = 0; xe < q.length; xe++) {
              const Ie = q[xe].image[fe].image;
              He
                ? t.texSubImage2D(
                    34069 + fe,
                    xe + 1,
                    0,
                    0,
                    Ie.width,
                    Ie.height,
                    Ee,
                    Le,
                    Ie.data
                  )
                : t.texImage2D(
                    34069 + fe,
                    xe + 1,
                    De,
                    Ie.width,
                    Ie.height,
                    0,
                    Ee,
                    Le,
                    Ie.data
                  );
            }
          } else {
            He
              ? t.texSubImage2D(34069 + fe, 0, 0, 0, Ee, Le, te[fe])
              : t.texImage2D(34069 + fe, 0, De, Ee, Le, te[fe]);
            for (let xe = 0; xe < q.length; xe++) {
              const Ae = q[xe];
              He
                ? t.texSubImage2D(
                    34069 + fe,
                    xe + 1,
                    0,
                    0,
                    Ee,
                    Le,
                    Ae.image[fe]
                  )
                : t.texImage2D(34069 + fe, xe + 1, De, Ee, Le, Ae.image[fe]);
            }
          }
      }
      S(D, Se) && T(34067),
        (_e.__version = ye.version),
        D.onUpdate && D.onUpdate(D);
    }
    L.__version = D.version;
  }
  function ee(L, D, ne, de, ye) {
    const _e = o.convert(ne.format, ne.encoding),
      Pe = o.convert(ne.type),
      U = w(ne.internalFormat, _e, Pe, ne.encoding);
    i.get(D).__hasExternalTextures ||
      (ye === 32879 || ye === 35866
        ? t.texImage3D(ye, 0, U, D.width, D.height, D.depth, 0, _e, Pe, null)
        : t.texImage2D(ye, 0, U, D.width, D.height, 0, _e, Pe, null)),
      t.bindFramebuffer(36160, L),
      ge(D)
        ? c.framebufferTexture2DMultisampleEXT(
            36160,
            de,
            ye,
            i.get(ne).__webglTexture,
            0,
            le(D)
          )
        : (ye === 3553 || (ye >= 34069 && ye <= 34074)) &&
          n.framebufferTexture2D(36160, de, ye, i.get(ne).__webglTexture, 0),
      t.bindFramebuffer(36160, null);
  }
  function he(L, D, ne) {
    if ((n.bindRenderbuffer(36161, L), D.depthBuffer && !D.stencilBuffer)) {
      let de = 33189;
      if (ne || ge(D)) {
        const ye = D.depthTexture;
        ye &&
          ye.isDepthTexture &&
          (ye.type === or ? (de = 36012) : ye.type === Wr && (de = 33190));
        const _e = le(D);
        ge(D)
          ? c.renderbufferStorageMultisampleEXT(
              36161,
              _e,
              de,
              D.width,
              D.height
            )
          : n.renderbufferStorageMultisample(36161, _e, de, D.width, D.height);
      } else n.renderbufferStorage(36161, de, D.width, D.height);
      n.framebufferRenderbuffer(36160, 36096, 36161, L);
    } else if (D.depthBuffer && D.stencilBuffer) {
      const de = le(D);
      ne && ge(D) === !1
        ? n.renderbufferStorageMultisample(36161, de, 35056, D.width, D.height)
        : ge(D)
        ? c.renderbufferStorageMultisampleEXT(
            36161,
            de,
            35056,
            D.width,
            D.height
          )
        : n.renderbufferStorage(36161, 34041, D.width, D.height),
        n.framebufferRenderbuffer(36160, 33306, 36161, L);
    } else {
      const de =
        D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture];
      for (let ye = 0; ye < de.length; ye++) {
        const _e = de[ye],
          Pe = o.convert(_e.format, _e.encoding),
          U = o.convert(_e.type),
          te = w(_e.internalFormat, Pe, U, _e.encoding),
          we = le(D);
        ne && ge(D) === !1
          ? n.renderbufferStorageMultisample(36161, we, te, D.width, D.height)
          : ge(D)
          ? c.renderbufferStorageMultisampleEXT(
              36161,
              we,
              te,
              D.width,
              D.height
            )
          : n.renderbufferStorage(36161, te, D.width, D.height);
      }
    }
    n.bindRenderbuffer(36161, null);
  }
  function pe(L, D) {
    if (D && D.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(36160, L),
      !(D.depthTexture && D.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!i.get(D.depthTexture).__webglTexture ||
      D.depthTexture.image.width !== D.width ||
      D.depthTexture.image.height !== D.height) &&
      ((D.depthTexture.image.width = D.width),
      (D.depthTexture.image.height = D.height),
      (D.depthTexture.needsUpdate = !0)),
      R(D.depthTexture, 0);
    const de = i.get(D.depthTexture).__webglTexture,
      ye = le(D);
    if (D.depthTexture.format === Kr)
      ge(D)
        ? c.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, de, 0, ye)
        : n.framebufferTexture2D(36160, 36096, 3553, de, 0);
    else if (D.depthTexture.format === bo)
      ge(D)
        ? c.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, de, 0, ye)
        : n.framebufferTexture2D(36160, 33306, 3553, de, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function Z(L) {
    const D = i.get(L),
      ne = L.isWebGLCubeRenderTarget === !0;
    if (L.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (ne)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      pe(D.__webglFramebuffer, L);
    } else if (ne) {
      D.__webglDepthbuffer = [];
      for (let de = 0; de < 6; de++)
        t.bindFramebuffer(36160, D.__webglFramebuffer[de]),
          (D.__webglDepthbuffer[de] = n.createRenderbuffer()),
          he(D.__webglDepthbuffer[de], L, !1);
    } else
      t.bindFramebuffer(36160, D.__webglFramebuffer),
        (D.__webglDepthbuffer = n.createRenderbuffer()),
        he(D.__webglDepthbuffer, L, !1);
    t.bindFramebuffer(36160, null);
  }
  function K(L, D, ne) {
    const de = i.get(L);
    D !== void 0 && ee(de.__webglFramebuffer, L, L.texture, 36064, 3553),
      ne !== void 0 && Z(L);
  }
  function ce(L) {
    const D = L.texture,
      ne = i.get(L),
      de = i.get(D);
    L.addEventListener("dispose", J),
      L.isWebGLMultipleRenderTargets !== !0 &&
        (de.__webglTexture === void 0 &&
          (de.__webglTexture = n.createTexture()),
        (de.__version = D.version),
        p.memory.textures++);
    const ye = L.isWebGLCubeRenderTarget === !0,
      _e = L.isWebGLMultipleRenderTargets === !0,
      Pe = x(L) || a;
    if (ye) {
      ne.__webglFramebuffer = [];
      for (let U = 0; U < 6; U++)
        ne.__webglFramebuffer[U] = n.createFramebuffer();
    } else {
      if (((ne.__webglFramebuffer = n.createFramebuffer()), _e))
        if (r.drawBuffers) {
          const U = L.texture;
          for (let te = 0, we = U.length; te < we; te++) {
            const Se = i.get(U[te]);
            Se.__webglTexture === void 0 &&
              ((Se.__webglTexture = n.createTexture()), p.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (a && L.samples > 0 && ge(L) === !1) {
        const U = _e ? D : [D];
        (ne.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (ne.__webglColorRenderbuffer = []),
          t.bindFramebuffer(36160, ne.__webglMultisampledFramebuffer);
        for (let te = 0; te < U.length; te++) {
          const we = U[te];
          (ne.__webglColorRenderbuffer[te] = n.createRenderbuffer()),
            n.bindRenderbuffer(36161, ne.__webglColorRenderbuffer[te]);
          const Se = o.convert(we.format, we.encoding),
            Ee = o.convert(we.type),
            Le = w(
              we.internalFormat,
              Se,
              Ee,
              we.encoding,
              L.isXRRenderTarget === !0
            ),
            De = le(L);
          n.renderbufferStorageMultisample(36161, De, Le, L.width, L.height),
            n.framebufferRenderbuffer(
              36160,
              36064 + te,
              36161,
              ne.__webglColorRenderbuffer[te]
            );
        }
        n.bindRenderbuffer(36161, null),
          L.depthBuffer &&
            ((ne.__webglDepthRenderbuffer = n.createRenderbuffer()),
            he(ne.__webglDepthRenderbuffer, L, !0)),
          t.bindFramebuffer(36160, null);
      }
    }
    if (ye) {
      t.bindTexture(34067, de.__webglTexture), k(34067, D, Pe);
      for (let U = 0; U < 6; U++)
        ee(ne.__webglFramebuffer[U], L, D, 36064, 34069 + U);
      S(D, Pe) && T(34067), t.unbindTexture();
    } else if (_e) {
      const U = L.texture;
      for (let te = 0, we = U.length; te < we; te++) {
        const Se = U[te],
          Ee = i.get(Se);
        t.bindTexture(3553, Ee.__webglTexture),
          k(3553, Se, Pe),
          ee(ne.__webglFramebuffer, L, Se, 36064 + te, 3553),
          S(Se, Pe) && T(3553);
      }
      t.unbindTexture();
    } else {
      let U = 3553;
      (L.isWebGL3DRenderTarget || L.isWebGLArrayRenderTarget) &&
        (a
          ? (U = L.isWebGL3DRenderTarget ? 32879 : 35866)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(U, de.__webglTexture),
        k(U, D, Pe),
        ee(ne.__webglFramebuffer, L, D, 36064, U),
        S(D, Pe) && T(U),
        t.unbindTexture();
    }
    L.depthBuffer && Z(L);
  }
  function ue(L) {
    const D = x(L) || a,
      ne = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
    for (let de = 0, ye = ne.length; de < ye; de++) {
      const _e = ne[de];
      if (S(_e, D)) {
        const Pe = L.isWebGLCubeRenderTarget ? 34067 : 3553,
          U = i.get(_e).__webglTexture;
        t.bindTexture(Pe, U), T(Pe), t.unbindTexture();
      }
    }
  }
  function oe(L) {
    if (a && L.samples > 0 && ge(L) === !1) {
      const D = L.isWebGLMultipleRenderTargets ? L.texture : [L.texture],
        ne = L.width,
        de = L.height;
      let ye = 16384;
      const _e = [],
        Pe = L.stencilBuffer ? 33306 : 36096,
        U = i.get(L),
        te = L.isWebGLMultipleRenderTargets === !0;
      if (te)
        for (let we = 0; we < D.length; we++)
          t.bindFramebuffer(36160, U.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(36160, 36064 + we, 36161, null),
            t.bindFramebuffer(36160, U.__webglFramebuffer),
            n.framebufferTexture2D(36009, 36064 + we, 3553, null, 0);
      t.bindFramebuffer(36008, U.__webglMultisampledFramebuffer),
        t.bindFramebuffer(36009, U.__webglFramebuffer);
      for (let we = 0; we < D.length; we++) {
        _e.push(36064 + we), L.depthBuffer && _e.push(Pe);
        const Se =
          U.__ignoreDepthValues !== void 0 ? U.__ignoreDepthValues : !1;
        if (
          (Se === !1 &&
            (L.depthBuffer && (ye |= 256), L.stencilBuffer && (ye |= 1024)),
          te &&
            n.framebufferRenderbuffer(
              36008,
              36064,
              36161,
              U.__webglColorRenderbuffer[we]
            ),
          Se === !0 &&
            (n.invalidateFramebuffer(36008, [Pe]),
            n.invalidateFramebuffer(36009, [Pe])),
          te)
        ) {
          const Ee = i.get(D[we]).__webglTexture;
          n.framebufferTexture2D(36009, 36064, 3553, Ee, 0);
        }
        n.blitFramebuffer(0, 0, ne, de, 0, 0, ne, de, ye, 9728),
          h && n.invalidateFramebuffer(36008, _e);
      }
      if ((t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), te))
        for (let we = 0; we < D.length; we++) {
          t.bindFramebuffer(36160, U.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              36160,
              36064 + we,
              36161,
              U.__webglColorRenderbuffer[we]
            );
          const Se = i.get(D[we]).__webglTexture;
          t.bindFramebuffer(36160, U.__webglFramebuffer),
            n.framebufferTexture2D(36009, 36064 + we, 3553, Se, 0);
        }
      t.bindFramebuffer(36009, U.__webglMultisampledFramebuffer);
    }
  }
  function le(L) {
    return Math.min(l, L.samples);
  }
  function ge(L) {
    const D = i.get(L);
    return (
      a &&
      L.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      D.__useRenderToTexture !== !1
    );
  }
  function Re(L) {
    const D = p.render.frame;
    m.get(L) !== D && (m.set(L, D), L.update());
  }
  function Me(L, D) {
    const ne = L.encoding,
      de = L.format,
      ye = L.type;
    return (
      L.isCompressedTexture === !0 ||
        L.isVideoTexture === !0 ||
        L.format === Hd ||
        (ne !== os &&
          (ne === ot
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && de === Wn
                ? ((L.format = Hd),
                  (L.minFilter = mn),
                  (L.generateMipmaps = !1))
                : (D = Fb.sRGBToLinear(D))
              : (de !== Wn || ye !== ss) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture encoding:",
                ne
              ))),
      D
    );
  }
  (this.allocateTextureUnit = j),
    (this.resetTextureUnits = re),
    (this.setTexture2D = R),
    (this.setTexture2DArray = A),
    (this.setTexture3D = O),
    (this.setTextureCube = H),
    (this.rebindTextures = K),
    (this.setupRenderTarget = ce),
    (this.updateRenderTargetMipmap = ue),
    (this.updateMultisampleRenderTarget = oe),
    (this.setupDepthRenderbuffer = Z),
    (this.setupFrameBufferTexture = ee),
    (this.useMultisampledRTT = ge);
}
function JP(n, e, t) {
  const i = t.isWebGL2;
  function r(o, p = null) {
    let a;
    if (o === ss) return 5121;
    if (o === OC) return 32819;
    if (o === LC) return 32820;
    if (o === EC) return 5120;
    if (o === AC) return 5122;
    if (o === Lb) return 5123;
    if (o === PC) return 5124;
    if (o === Wr) return 5125;
    if (o === or) return 5126;
    if (o === rl)
      return i
        ? 5131
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (o === DC) return 6406;
    if (o === Wn) return 6408;
    if (o === IC) return 6409;
    if (o === kC) return 6410;
    if (o === Kr) return 6402;
    if (o === bo) return 34041;
    if (o === RC)
      return (
        console.warn(
          "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
        ),
        6408
      );
    if (o === Hd)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (o === FC) return 6403;
    if (o === NC) return 36244;
    if (o === BC) return 33319;
    if (o === zC) return 33320;
    if (o === UC) return 36249;
    if (o === Vh || o === Wh || o === Gh || o === $h)
      if (p === ot)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (o === Vh) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (o === Wh) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (o === Gh) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (o === $h) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (o === Vh) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === Wh) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === Gh) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === $h) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (o === vv || o === yv || o === _v || o === xv)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (o === vv) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === yv) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === _v) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === xv) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (o === jC)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (o === bv || o === Sv)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (o === bv)
          return p === ot ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (o === Sv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      o === wv ||
      o === Tv ||
      o === Cv ||
      o === Mv ||
      o === Ev ||
      o === Av ||
      o === Pv ||
      o === Ov ||
      o === Lv ||
      o === Dv ||
      o === Rv ||
      o === Iv ||
      o === kv ||
      o === Fv
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (o === wv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (o === Tv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (o === Cv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (o === Mv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (o === Ev)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (o === Av)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (o === Pv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (o === Ov)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (o === Lv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (o === Dv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (o === Rv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (o === Iv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (o === kv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (o === Fv)
          return p === ot
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (o === Nv)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (o === Nv)
          return p === ot
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    return o === so
      ? i
        ? 34042
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[o] !== void 0
      ? n[o]
      : null;
  }
  return { convert: r };
}
class QP extends ln {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class ar extends St {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const eO = { type: "move" };
class _f {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new ar()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new ar()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Q()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Q())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new ar()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Q()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Q())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      o = null,
      p = null;
    const a = this._targetRay,
      s = this._grip,
      u = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        p = !0;
        for (const g of e.hand.values()) {
          const f = t.getJointPose(g, i),
            v = this._getHandJoint(u, g);
          f !== null &&
            (v.matrix.fromArray(f.transform.matrix),
            v.matrix.decompose(v.position, v.rotation, v.scale),
            (v.jointRadius = f.radius)),
            (v.visible = f !== null);
        }
        const d = u.joints["index-finger-tip"],
          l = u.joints["thumb-tip"],
          c = d.position.distanceTo(l.position),
          h = 0.02,
          m = 0.005;
        u.inputState.pinching && c > h + m
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            c <= h - m &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        s !== null &&
          e.gripSpace &&
          ((o = t.getPose(e.gripSpace, i)),
          o !== null &&
            (s.matrix.fromArray(o.transform.matrix),
            s.matrix.decompose(s.position, s.rotation, s.scale),
            o.linearVelocity
              ? ((s.hasLinearVelocity = !0),
                s.linearVelocity.copy(o.linearVelocity))
              : (s.hasLinearVelocity = !1),
            o.angularVelocity
              ? ((s.hasAngularVelocity = !0),
                s.angularVelocity.copy(o.angularVelocity))
              : (s.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && o !== null && (r = o),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(eO)));
    }
    return (
      a !== null && (a.visible = r !== null),
      s !== null && (s.visible = o !== null),
      u !== null && (u.visible = p !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new ar();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class tO extends jt {
  constructor(e, t, i, r, o, p, a, s, u, d) {
    if (((d = d !== void 0 ? d : Kr), d !== Kr && d !== bo))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && d === Kr && (i = Wr),
      i === void 0 && d === bo && (i = so),
      super(null, r, o, p, a, s, d, i, u),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : zt),
      (this.minFilter = s !== void 0 ? s : zt),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class nO extends fs {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      o = 1,
      p = null,
      a = "local-floor",
      s = null,
      u = null,
      d = null,
      l = null,
      c = null,
      h = null;
    const m = t.getContextAttributes();
    let g = null,
      f = null;
    const v = [],
      y = [],
      _ = new Set(),
      x = new Map(),
      b = new ln();
    b.layers.enable(1), (b.viewport = new ht());
    const S = new ln();
    S.layers.enable(2), (S.viewport = new ht());
    const T = [b, S],
      w = new QP();
    w.layers.enable(1), w.layers.enable(2);
    let P = null,
      F = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (A) {
        let O = v[A];
        return (
          O === void 0 && ((O = new _f()), (v[A] = O)), O.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (A) {
        let O = v[A];
        return O === void 0 && ((O = new _f()), (v[A] = O)), O.getGripSpace();
      }),
      (this.getHand = function (A) {
        let O = v[A];
        return O === void 0 && ((O = new _f()), (v[A] = O)), O.getHandSpace();
      });
    function V(A) {
      const O = y.indexOf(A.inputSource);
      if (O === -1) return;
      const H = v[O];
      H !== void 0 && H.dispatchEvent({ type: A.type, data: A.inputSource });
    }
    function J() {
      r.removeEventListener("select", V),
        r.removeEventListener("selectstart", V),
        r.removeEventListener("selectend", V),
        r.removeEventListener("squeeze", V),
        r.removeEventListener("squeezestart", V),
        r.removeEventListener("squeezeend", V),
        r.removeEventListener("end", J),
        r.removeEventListener("inputsourceschange", z);
      for (let A = 0; A < v.length; A++) {
        const O = y[A];
        O !== null && ((y[A] = null), v[A].disconnect(O));
      }
      (P = null),
        (F = null),
        e.setRenderTarget(g),
        (c = null),
        (l = null),
        (d = null),
        (r = null),
        (f = null),
        R.stop(),
        (i.isPresenting = !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (A) {
      (o = A),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (A) {
        (a = A),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return s || p;
      }),
      (this.setReferenceSpace = function (A) {
        s = A;
      }),
      (this.getBaseLayer = function () {
        return l !== null ? l : c;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return h;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (A) {
        if (((r = A), r !== null)) {
          if (
            ((g = e.getRenderTarget()),
            r.addEventListener("select", V),
            r.addEventListener("selectstart", V),
            r.addEventListener("selectend", V),
            r.addEventListener("squeeze", V),
            r.addEventListener("squeezestart", V),
            r.addEventListener("squeezeend", V),
            r.addEventListener("end", J),
            r.addEventListener("inputsourceschange", z),
            m.xrCompatible !== !0 && (await t.makeXRCompatible()),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const O = {
              antialias: r.renderState.layers === void 0 ? m.antialias : !0,
              alpha: m.alpha,
              depth: m.depth,
              stencil: m.stencil,
              framebufferScaleFactor: o,
            };
            (c = new XRWebGLLayer(r, t, O)),
              r.updateRenderState({ baseLayer: c }),
              (f = new as(c.framebufferWidth, c.framebufferHeight, {
                format: Wn,
                type: ss,
                encoding: e.outputEncoding,
                stencilBuffer: m.stencil,
              }));
          } else {
            let O = null,
              H = null,
              I = null;
            m.depth &&
              ((I = m.stencil ? 35056 : 33190),
              (O = m.stencil ? bo : Kr),
              (H = m.stencil ? so : Wr));
            const E = { colorFormat: 32856, depthFormat: I, scaleFactor: o };
            (d = new XRWebGLBinding(r, t)),
              (l = d.createProjectionLayer(E)),
              r.updateRenderState({ layers: [l] }),
              (f = new as(l.textureWidth, l.textureHeight, {
                format: Wn,
                type: ss,
                depthTexture: new tO(
                  l.textureWidth,
                  l.textureHeight,
                  H,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  O
                ),
                stencilBuffer: m.stencil,
                encoding: e.outputEncoding,
                samples: m.antialias ? 4 : 0,
              }));
            const k = e.properties.get(f);
            k.__ignoreDepthValues = l.ignoreDepthValues;
          }
          (f.isXRRenderTarget = !0),
            this.setFoveation(1),
            (s = null),
            (p = await r.requestReferenceSpace(a)),
            R.setContext(r),
            R.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      });
    function z(A) {
      for (let O = 0; O < A.removed.length; O++) {
        const H = A.removed[O],
          I = y.indexOf(H);
        I >= 0 && ((y[I] = null), v[I].disconnect(H));
      }
      for (let O = 0; O < A.added.length; O++) {
        const H = A.added[O];
        let I = y.indexOf(H);
        if (I === -1) {
          for (let k = 0; k < v.length; k++)
            if (k >= y.length) {
              y.push(H), (I = k);
              break;
            } else if (y[k] === null) {
              (y[k] = H), (I = k);
              break;
            }
          if (I === -1) break;
        }
        const E = v[I];
        E && E.connect(H);
      }
    }
    const B = new Q(),
      G = new Q();
    function ie(A, O, H) {
      B.setFromMatrixPosition(O.matrixWorld),
        G.setFromMatrixPosition(H.matrixWorld);
      const I = B.distanceTo(G),
        E = O.projectionMatrix.elements,
        k = H.projectionMatrix.elements,
        $ = E[14] / (E[10] - 1),
        Y = E[14] / (E[10] + 1),
        X = (E[9] + 1) / E[5],
        ee = (E[9] - 1) / E[5],
        he = (E[8] - 1) / E[0],
        pe = (k[8] + 1) / k[0],
        Z = $ * he,
        K = $ * pe,
        ce = I / (-he + pe),
        ue = ce * -he;
      O.matrixWorld.decompose(A.position, A.quaternion, A.scale),
        A.translateX(ue),
        A.translateZ(ce),
        A.matrixWorld.compose(A.position, A.quaternion, A.scale),
        A.matrixWorldInverse.copy(A.matrixWorld).invert();
      const oe = $ + ce,
        le = Y + ce,
        ge = Z - ue,
        Re = K + (I - ue),
        Me = ((X * Y) / le) * oe,
        L = ((ee * Y) / le) * oe;
      A.projectionMatrix.makePerspective(ge, Re, Me, L, oe, le);
    }
    function re(A, O) {
      O === null
        ? A.matrixWorld.copy(A.matrix)
        : A.matrixWorld.multiplyMatrices(O.matrixWorld, A.matrix),
        A.matrixWorldInverse.copy(A.matrixWorld).invert();
    }
    (this.updateCamera = function (A) {
      if (r === null) return;
      (w.near = S.near = b.near = A.near),
        (w.far = S.far = b.far = A.far),
        (P !== w.near || F !== w.far) &&
          (r.updateRenderState({ depthNear: w.near, depthFar: w.far }),
          (P = w.near),
          (F = w.far));
      const O = A.parent,
        H = w.cameras;
      re(w, O);
      for (let E = 0; E < H.length; E++) re(H[E], O);
      w.matrixWorld.decompose(w.position, w.quaternion, w.scale),
        A.matrix.copy(w.matrix),
        A.matrix.decompose(A.position, A.quaternion, A.scale);
      const I = A.children;
      for (let E = 0, k = I.length; E < k; E++) I[E].updateMatrixWorld(!0);
      H.length === 2
        ? ie(w, b, S)
        : w.projectionMatrix.copy(b.projectionMatrix);
    }),
      (this.getCamera = function () {
        return w;
      }),
      (this.getFoveation = function () {
        if (l !== null) return l.fixedFoveation;
        if (c !== null) return c.fixedFoveation;
      }),
      (this.setFoveation = function (A) {
        l !== null && (l.fixedFoveation = A),
          c !== null && c.fixedFoveation !== void 0 && (c.fixedFoveation = A);
      }),
      (this.getPlanes = function () {
        return _;
      });
    let j = null;
    function C(A, O) {
      if (((u = O.getViewerPose(s || p)), (h = O), u !== null)) {
        const H = u.views;
        c !== null &&
          (e.setRenderTargetFramebuffer(f, c.framebuffer),
          e.setRenderTarget(f));
        let I = !1;
        H.length !== w.cameras.length && ((w.cameras.length = 0), (I = !0));
        for (let E = 0; E < H.length; E++) {
          const k = H[E];
          let $ = null;
          if (c !== null) $ = c.getViewport(k);
          else {
            const X = d.getViewSubImage(l, k);
            ($ = X.viewport),
              E === 0 &&
                (e.setRenderTargetTextures(
                  f,
                  X.colorTexture,
                  l.ignoreDepthValues ? void 0 : X.depthStencilTexture
                ),
                e.setRenderTarget(f));
          }
          let Y = T[E];
          Y === void 0 &&
            ((Y = new ln()),
            Y.layers.enable(E),
            (Y.viewport = new ht()),
            (T[E] = Y)),
            Y.matrix.fromArray(k.transform.matrix),
            Y.projectionMatrix.fromArray(k.projectionMatrix),
            Y.viewport.set($.x, $.y, $.width, $.height),
            E === 0 && w.matrix.copy(Y.matrix),
            I === !0 && w.cameras.push(Y);
        }
      }
      for (let H = 0; H < v.length; H++) {
        const I = y[H],
          E = v[H];
        I !== null && E !== void 0 && E.update(I, O, s || p);
      }
      if ((j && j(A, O), O.detectedPlanes)) {
        i.dispatchEvent({ type: "planesdetected", data: O.detectedPlanes });
        let H = null;
        for (const I of _)
          O.detectedPlanes.has(I) || (H === null && (H = []), H.push(I));
        if (H !== null)
          for (const I of H)
            _.delete(I),
              x.delete(I),
              i.dispatchEvent({ type: "planeremoved", data: I });
        for (const I of O.detectedPlanes)
          if (!_.has(I))
            _.add(I),
              x.set(I, O.lastChangedTime),
              i.dispatchEvent({ type: "planeadded", data: I });
          else {
            const E = x.get(I);
            I.lastChangedTime > E &&
              (x.set(I, I.lastChangedTime),
              i.dispatchEvent({ type: "planechanged", data: I }));
          }
      }
      h = null;
    }
    const R = new Gb();
    R.setAnimationLoop(C),
      (this.setAnimationLoop = function (A) {
        j = A;
      }),
      (this.dispose = function () {});
  }
}
function iO(n, e) {
  function t(g, f) {
    f.color.getRGB(g.fogColor.value, Hb(n)),
      f.isFog
        ? ((g.fogNear.value = f.near), (g.fogFar.value = f.far))
        : f.isFogExp2 && (g.fogDensity.value = f.density);
  }
  function i(g, f, v, y, _) {
    f.isMeshBasicMaterial || f.isMeshLambertMaterial
      ? r(g, f)
      : f.isMeshToonMaterial
      ? (r(g, f), d(g, f))
      : f.isMeshPhongMaterial
      ? (r(g, f), u(g, f))
      : f.isMeshStandardMaterial
      ? (r(g, f), l(g, f), f.isMeshPhysicalMaterial && c(g, f, _))
      : f.isMeshMatcapMaterial
      ? (r(g, f), h(g, f))
      : f.isMeshDepthMaterial
      ? r(g, f)
      : f.isMeshDistanceMaterial
      ? (r(g, f), m(g, f))
      : f.isMeshNormalMaterial
      ? r(g, f)
      : f.isLineBasicMaterial
      ? (o(g, f), f.isLineDashedMaterial && p(g, f))
      : f.isPointsMaterial
      ? a(g, f, v, y)
      : f.isSpriteMaterial
      ? s(g, f)
      : f.isShadowMaterial
      ? (g.color.value.copy(f.color), (g.opacity.value = f.opacity))
      : f.isShaderMaterial && (f.uniformsNeedUpdate = !1);
  }
  function r(g, f) {
    (g.opacity.value = f.opacity),
      f.color && g.diffuse.value.copy(f.color),
      f.emissive &&
        g.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),
      f.map && (g.map.value = f.map),
      f.alphaMap && (g.alphaMap.value = f.alphaMap),
      f.bumpMap &&
        ((g.bumpMap.value = f.bumpMap),
        (g.bumpScale.value = f.bumpScale),
        f.side === Xn && (g.bumpScale.value *= -1)),
      f.displacementMap &&
        ((g.displacementMap.value = f.displacementMap),
        (g.displacementScale.value = f.displacementScale),
        (g.displacementBias.value = f.displacementBias)),
      f.emissiveMap && (g.emissiveMap.value = f.emissiveMap),
      f.normalMap &&
        ((g.normalMap.value = f.normalMap),
        g.normalScale.value.copy(f.normalScale),
        f.side === Xn && g.normalScale.value.negate()),
      f.specularMap && (g.specularMap.value = f.specularMap),
      f.alphaTest > 0 && (g.alphaTest.value = f.alphaTest);
    const v = e.get(f).envMap;
    if (
      (v &&
        ((g.envMap.value = v),
        (g.flipEnvMap.value =
          v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1),
        (g.reflectivity.value = f.reflectivity),
        (g.ior.value = f.ior),
        (g.refractionRatio.value = f.refractionRatio)),
      f.lightMap)
    ) {
      g.lightMap.value = f.lightMap;
      const x = n.physicallyCorrectLights !== !0 ? Math.PI : 1;
      g.lightMapIntensity.value = f.lightMapIntensity * x;
    }
    f.aoMap &&
      ((g.aoMap.value = f.aoMap), (g.aoMapIntensity.value = f.aoMapIntensity));
    let y;
    f.map
      ? (y = f.map)
      : f.specularMap
      ? (y = f.specularMap)
      : f.displacementMap
      ? (y = f.displacementMap)
      : f.normalMap
      ? (y = f.normalMap)
      : f.bumpMap
      ? (y = f.bumpMap)
      : f.roughnessMap
      ? (y = f.roughnessMap)
      : f.metalnessMap
      ? (y = f.metalnessMap)
      : f.alphaMap
      ? (y = f.alphaMap)
      : f.emissiveMap
      ? (y = f.emissiveMap)
      : f.clearcoatMap
      ? (y = f.clearcoatMap)
      : f.clearcoatNormalMap
      ? (y = f.clearcoatNormalMap)
      : f.clearcoatRoughnessMap
      ? (y = f.clearcoatRoughnessMap)
      : f.iridescenceMap
      ? (y = f.iridescenceMap)
      : f.iridescenceThicknessMap
      ? (y = f.iridescenceThicknessMap)
      : f.specularIntensityMap
      ? (y = f.specularIntensityMap)
      : f.specularColorMap
      ? (y = f.specularColorMap)
      : f.transmissionMap
      ? (y = f.transmissionMap)
      : f.thicknessMap
      ? (y = f.thicknessMap)
      : f.sheenColorMap
      ? (y = f.sheenColorMap)
      : f.sheenRoughnessMap && (y = f.sheenRoughnessMap),
      y !== void 0 &&
        (y.isWebGLRenderTarget && (y = y.texture),
        y.matrixAutoUpdate === !0 && y.updateMatrix(),
        g.uvTransform.value.copy(y.matrix));
    let _;
    f.aoMap ? (_ = f.aoMap) : f.lightMap && (_ = f.lightMap),
      _ !== void 0 &&
        (_.isWebGLRenderTarget && (_ = _.texture),
        _.matrixAutoUpdate === !0 && _.updateMatrix(),
        g.uv2Transform.value.copy(_.matrix));
  }
  function o(g, f) {
    g.diffuse.value.copy(f.color), (g.opacity.value = f.opacity);
  }
  function p(g, f) {
    (g.dashSize.value = f.dashSize),
      (g.totalSize.value = f.dashSize + f.gapSize),
      (g.scale.value = f.scale);
  }
  function a(g, f, v, y) {
    g.diffuse.value.copy(f.color),
      (g.opacity.value = f.opacity),
      (g.size.value = f.size * v),
      (g.scale.value = y * 0.5),
      f.map && (g.map.value = f.map),
      f.alphaMap && (g.alphaMap.value = f.alphaMap),
      f.alphaTest > 0 && (g.alphaTest.value = f.alphaTest);
    let _;
    f.map ? (_ = f.map) : f.alphaMap && (_ = f.alphaMap),
      _ !== void 0 &&
        (_.matrixAutoUpdate === !0 && _.updateMatrix(),
        g.uvTransform.value.copy(_.matrix));
  }
  function s(g, f) {
    g.diffuse.value.copy(f.color),
      (g.opacity.value = f.opacity),
      (g.rotation.value = f.rotation),
      f.map && (g.map.value = f.map),
      f.alphaMap && (g.alphaMap.value = f.alphaMap),
      f.alphaTest > 0 && (g.alphaTest.value = f.alphaTest);
    let v;
    f.map ? (v = f.map) : f.alphaMap && (v = f.alphaMap),
      v !== void 0 &&
        (v.matrixAutoUpdate === !0 && v.updateMatrix(),
        g.uvTransform.value.copy(v.matrix));
  }
  function u(g, f) {
    g.specular.value.copy(f.specular),
      (g.shininess.value = Math.max(f.shininess, 1e-4));
  }
  function d(g, f) {
    f.gradientMap && (g.gradientMap.value = f.gradientMap);
  }
  function l(g, f) {
    (g.roughness.value = f.roughness),
      (g.metalness.value = f.metalness),
      f.roughnessMap && (g.roughnessMap.value = f.roughnessMap),
      f.metalnessMap && (g.metalnessMap.value = f.metalnessMap),
      e.get(f).envMap && (g.envMapIntensity.value = f.envMapIntensity);
  }
  function c(g, f, v) {
    (g.ior.value = f.ior),
      f.sheen > 0 &&
        (g.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),
        (g.sheenRoughness.value = f.sheenRoughness),
        f.sheenColorMap && (g.sheenColorMap.value = f.sheenColorMap),
        f.sheenRoughnessMap &&
          (g.sheenRoughnessMap.value = f.sheenRoughnessMap)),
      f.clearcoat > 0 &&
        ((g.clearcoat.value = f.clearcoat),
        (g.clearcoatRoughness.value = f.clearcoatRoughness),
        f.clearcoatMap && (g.clearcoatMap.value = f.clearcoatMap),
        f.clearcoatRoughnessMap &&
          (g.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap),
        f.clearcoatNormalMap &&
          (g.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),
          (g.clearcoatNormalMap.value = f.clearcoatNormalMap),
          f.side === Xn && g.clearcoatNormalScale.value.negate())),
      f.iridescence > 0 &&
        ((g.iridescence.value = f.iridescence),
        (g.iridescenceIOR.value = f.iridescenceIOR),
        (g.iridescenceThicknessMinimum.value = f.iridescenceThicknessRange[0]),
        (g.iridescenceThicknessMaximum.value = f.iridescenceThicknessRange[1]),
        f.iridescenceMap && (g.iridescenceMap.value = f.iridescenceMap),
        f.iridescenceThicknessMap &&
          (g.iridescenceThicknessMap.value = f.iridescenceThicknessMap)),
      f.transmission > 0 &&
        ((g.transmission.value = f.transmission),
        (g.transmissionSamplerMap.value = v.texture),
        g.transmissionSamplerSize.value.set(v.width, v.height),
        f.transmissionMap && (g.transmissionMap.value = f.transmissionMap),
        (g.thickness.value = f.thickness),
        f.thicknessMap && (g.thicknessMap.value = f.thicknessMap),
        (g.attenuationDistance.value = f.attenuationDistance),
        g.attenuationColor.value.copy(f.attenuationColor)),
      (g.specularIntensity.value = f.specularIntensity),
      g.specularColor.value.copy(f.specularColor),
      f.specularIntensityMap &&
        (g.specularIntensityMap.value = f.specularIntensityMap),
      f.specularColorMap && (g.specularColorMap.value = f.specularColorMap);
  }
  function h(g, f) {
    f.matcap && (g.matcap.value = f.matcap);
  }
  function m(g, f) {
    g.referencePosition.value.copy(f.referencePosition),
      (g.nearDistance.value = f.nearDistance),
      (g.farDistance.value = f.farDistance);
  }
  return { refreshFogUniforms: t, refreshMaterialUniforms: i };
}
function rO(n, e, t, i) {
  let r = {},
    o = {},
    p = [];
  const a = t.isWebGL2 ? n.getParameter(35375) : 0;
  function s(y, _) {
    const x = _.program;
    i.uniformBlockBinding(y, x);
  }
  function u(y, _) {
    let x = r[y.id];
    x === void 0 &&
      (m(y), (x = d(y)), (r[y.id] = x), y.addEventListener("dispose", f));
    const b = _.program;
    i.updateUBOMapping(y, b);
    const S = e.render.frame;
    o[y.id] !== S && (c(y), (o[y.id] = S));
  }
  function d(y) {
    const _ = l();
    y.__bindingPointIndex = _;
    const x = n.createBuffer(),
      b = y.__size,
      S = y.usage;
    return (
      n.bindBuffer(35345, x),
      n.bufferData(35345, b, S),
      n.bindBuffer(35345, null),
      n.bindBufferBase(35345, _, x),
      x
    );
  }
  function l() {
    for (let y = 0; y < a; y++) if (p.indexOf(y) === -1) return p.push(y), y;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function c(y) {
    const _ = r[y.id],
      x = y.uniforms,
      b = y.__cache;
    n.bindBuffer(35345, _);
    for (let S = 0, T = x.length; S < T; S++) {
      const w = x[S];
      if (h(w, S, b) === !0) {
        const P = w.__offset,
          F = Array.isArray(w.value) ? w.value : [w.value];
        let V = 0;
        for (let J = 0; J < F.length; J++) {
          const z = F[J],
            B = g(z);
          typeof z == "number"
            ? ((w.__data[0] = z), n.bufferSubData(35345, P + V, w.__data))
            : z.isMatrix3
            ? ((w.__data[0] = z.elements[0]),
              (w.__data[1] = z.elements[1]),
              (w.__data[2] = z.elements[2]),
              (w.__data[3] = z.elements[0]),
              (w.__data[4] = z.elements[3]),
              (w.__data[5] = z.elements[4]),
              (w.__data[6] = z.elements[5]),
              (w.__data[7] = z.elements[0]),
              (w.__data[8] = z.elements[6]),
              (w.__data[9] = z.elements[7]),
              (w.__data[10] = z.elements[8]),
              (w.__data[11] = z.elements[0]))
            : (z.toArray(w.__data, V),
              (V += B.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        n.bufferSubData(35345, P, w.__data);
      }
    }
    n.bindBuffer(35345, null);
  }
  function h(y, _, x) {
    const b = y.value;
    if (x[_] === void 0) {
      if (typeof b == "number") x[_] = b;
      else {
        const S = Array.isArray(b) ? b : [b],
          T = [];
        for (let w = 0; w < S.length; w++) T.push(S[w].clone());
        x[_] = T;
      }
      return !0;
    } else if (typeof b == "number") {
      if (x[_] !== b) return (x[_] = b), !0;
    } else {
      const S = Array.isArray(x[_]) ? x[_] : [x[_]],
        T = Array.isArray(b) ? b : [b];
      for (let w = 0; w < S.length; w++) {
        const P = S[w];
        if (P.equals(T[w]) === !1) return P.copy(T[w]), !0;
      }
    }
    return !1;
  }
  function m(y) {
    const _ = y.uniforms;
    let x = 0;
    const b = 16;
    let S = 0;
    for (let T = 0, w = _.length; T < w; T++) {
      const P = _[T],
        F = { boundary: 0, storage: 0 },
        V = Array.isArray(P.value) ? P.value : [P.value];
      for (let J = 0, z = V.length; J < z; J++) {
        const B = V[J],
          G = g(B);
        (F.boundary += G.boundary), (F.storage += G.storage);
      }
      if (
        ((P.__data = new Float32Array(
          F.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (P.__offset = x),
        T > 0)
      ) {
        S = x % b;
        const J = b - S;
        S !== 0 && J - F.boundary < 0 && ((x += b - S), (P.__offset = x));
      }
      x += F.storage;
    }
    return (
      (S = x % b), S > 0 && (x += b - S), (y.__size = x), (y.__cache = {}), this
    );
  }
  function g(y) {
    const _ = { boundary: 0, storage: 0 };
    return (
      typeof y == "number"
        ? ((_.boundary = 4), (_.storage = 4))
        : y.isVector2
        ? ((_.boundary = 8), (_.storage = 8))
        : y.isVector3 || y.isColor
        ? ((_.boundary = 16), (_.storage = 12))
        : y.isVector4
        ? ((_.boundary = 16), (_.storage = 16))
        : y.isMatrix3
        ? ((_.boundary = 48), (_.storage = 48))
        : y.isMatrix4
        ? ((_.boundary = 64), (_.storage = 64))
        : y.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            y
          ),
      _
    );
  }
  function f(y) {
    const _ = y.target;
    _.removeEventListener("dispose", f);
    const x = p.indexOf(_.__bindingPointIndex);
    p.splice(x, 1), n.deleteBuffer(r[_.id]), delete r[_.id], delete o[_.id];
  }
  function v() {
    for (const y in r) n.deleteBuffer(r[y]);
    (p = []), (r = {}), (o = {});
  }
  return { bind: s, update: u, dispose: v };
}
function sO() {
  const n = ll("canvas");
  return (n.style.display = "block"), n;
}
function qb(n = {}) {
  this.isWebGLRenderer = !0;
  const e = n.canvas !== void 0 ? n.canvas : sO(),
    t = n.context !== void 0 ? n.context : null,
    i = n.depth !== void 0 ? n.depth : !0,
    r = n.stencil !== void 0 ? n.stencil : !0,
    o = n.antialias !== void 0 ? n.antialias : !1,
    p = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0,
    a = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1,
    s = n.powerPreference !== void 0 ? n.powerPreference : "default",
    u =
      n.failIfMajorPerformanceCaveat !== void 0
        ? n.failIfMajorPerformanceCaveat
        : !1;
  let d;
  t !== null
    ? (d = t.getContextAttributes().alpha)
    : (d = n.alpha !== void 0 ? n.alpha : !1);
  let l = null,
    c = null;
  const h = [],
    m = [];
  (this.domElement = e),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.outputEncoding = os),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = Bi),
    (this.toneMappingExposure = 1);
  const g = this;
  let f = !1,
    v = 0,
    y = 0,
    _ = null,
    x = -1,
    b = null;
  const S = new ht(),
    T = new ht();
  let w = null,
    P = e.width,
    F = e.height,
    V = 1,
    J = null,
    z = null;
  const B = new ht(0, 0, P, F),
    G = new ht(0, 0, P, F);
  let ie = !1;
  const re = new sm();
  let j = !1,
    C = !1,
    R = null;
  const A = new Xe(),
    O = new ze(),
    H = new Q(),
    I = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function E() {
    return _ === null ? V : 1;
  }
  let k = t;
  function $(N, ae) {
    for (let me = 0; me < N.length; me++) {
      const se = N[me],
        ve = e.getContext(se, ae);
      if (ve !== null) return ve;
    }
    return null;
  }
  try {
    const N = {
      alpha: !0,
      depth: i,
      stencil: r,
      antialias: o,
      premultipliedAlpha: p,
      preserveDrawingBuffer: a,
      powerPreference: s,
      failIfMajorPerformanceCaveat: u,
    };
    if (
      ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${em}`),
      e.addEventListener("webglcontextlost", Le, !1),
      e.addEventListener("webglcontextrestored", De, !1),
      e.addEventListener("webglcontextcreationerror", He, !1),
      k === null)
    ) {
      const ae = ["webgl2", "webgl", "experimental-webgl"];
      if ((g.isWebGL1Renderer === !0 && ae.shift(), (k = $(ae, N)), k === null))
        throw $(ae)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.");
    }
    k.getShaderPrecisionFormat === void 0 &&
      (k.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (N) {
    throw (console.error("THREE.WebGLRenderer: " + N.message), N);
  }
  let Y,
    X,
    ee,
    he,
    pe,
    Z,
    K,
    ce,
    ue,
    oe,
    le,
    ge,
    Re,
    Me,
    L,
    D,
    ne,
    de,
    ye,
    _e,
    Pe,
    U,
    te,
    we;
  function Se() {
    (Y = new gA(k)),
      (X = new uA(k, Y, n)),
      Y.init(X),
      (U = new JP(k, Y, X)),
      (ee = new qP(k, Y, X)),
      (he = new _A()),
      (pe = new FP()),
      (Z = new ZP(k, Y, ee, pe, X, U, he)),
      (K = new fA(g)),
      (ce = new mA(g)),
      (ue = new AM(k, X)),
      (te = new lA(k, Y, ue, X)),
      (oe = new vA(k, ue, he, te)),
      (le = new wA(k, oe, ue, he)),
      (ye = new SA(k, X, Z)),
      (D = new hA(pe)),
      (ge = new kP(g, K, ce, Y, X, te, D)),
      (Re = new iO(g, pe)),
      (Me = new BP()),
      (L = new WP(Y, X)),
      (de = new aA(g, K, ce, ee, le, d, p)),
      (ne = new KP(g, le, X)),
      (we = new rO(k, he, X, ee)),
      (_e = new cA(k, Y, he, X)),
      (Pe = new yA(k, Y, he, X)),
      (he.programs = ge.programs),
      (g.capabilities = X),
      (g.extensions = Y),
      (g.properties = pe),
      (g.renderLists = Me),
      (g.shadowMap = ne),
      (g.state = ee),
      (g.info = he);
  }
  Se();
  const Ee = new nO(g, k);
  (this.xr = Ee),
    (this.getContext = function () {
      return k;
    }),
    (this.getContextAttributes = function () {
      return k.getContextAttributes();
    }),
    (this.forceContextLoss = function () {
      const N = Y.get("WEBGL_lose_context");
      N && N.loseContext();
    }),
    (this.forceContextRestore = function () {
      const N = Y.get("WEBGL_lose_context");
      N && N.restoreContext();
    }),
    (this.getPixelRatio = function () {
      return V;
    }),
    (this.setPixelRatio = function (N) {
      N !== void 0 && ((V = N), this.setSize(P, F, !1));
    }),
    (this.getSize = function (N) {
      return N.set(P, F);
    }),
    (this.setSize = function (N, ae, me) {
      if (Ee.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting."
        );
        return;
      }
      (P = N),
        (F = ae),
        (e.width = Math.floor(N * V)),
        (e.height = Math.floor(ae * V)),
        me !== !1 && ((e.style.width = N + "px"), (e.style.height = ae + "px")),
        this.setViewport(0, 0, N, ae);
    }),
    (this.getDrawingBufferSize = function (N) {
      return N.set(P * V, F * V).floor();
    }),
    (this.setDrawingBufferSize = function (N, ae, me) {
      (P = N),
        (F = ae),
        (V = me),
        (e.width = Math.floor(N * me)),
        (e.height = Math.floor(ae * me)),
        this.setViewport(0, 0, N, ae);
    }),
    (this.getCurrentViewport = function (N) {
      return N.copy(S);
    }),
    (this.getViewport = function (N) {
      return N.copy(B);
    }),
    (this.setViewport = function (N, ae, me, se) {
      N.isVector4 ? B.set(N.x, N.y, N.z, N.w) : B.set(N, ae, me, se),
        ee.viewport(S.copy(B).multiplyScalar(V).floor());
    }),
    (this.getScissor = function (N) {
      return N.copy(G);
    }),
    (this.setScissor = function (N, ae, me, se) {
      N.isVector4 ? G.set(N.x, N.y, N.z, N.w) : G.set(N, ae, me, se),
        ee.scissor(T.copy(G).multiplyScalar(V).floor());
    }),
    (this.getScissorTest = function () {
      return ie;
    }),
    (this.setScissorTest = function (N) {
      ee.setScissorTest((ie = N));
    }),
    (this.setOpaqueSort = function (N) {
      J = N;
    }),
    (this.setTransparentSort = function (N) {
      z = N;
    }),
    (this.getClearColor = function (N) {
      return N.copy(de.getClearColor());
    }),
    (this.setClearColor = function () {
      de.setClearColor.apply(de, arguments);
    }),
    (this.getClearAlpha = function () {
      return de.getClearAlpha();
    }),
    (this.setClearAlpha = function () {
      de.setClearAlpha.apply(de, arguments);
    }),
    (this.clear = function (N = !0, ae = !0, me = !0) {
      let se = 0;
      N && (se |= 16384), ae && (se |= 256), me && (se |= 1024), k.clear(se);
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1);
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }),
    (this.dispose = function () {
      e.removeEventListener("webglcontextlost", Le, !1),
        e.removeEventListener("webglcontextrestored", De, !1),
        e.removeEventListener("webglcontextcreationerror", He, !1),
        Me.dispose(),
        L.dispose(),
        pe.dispose(),
        K.dispose(),
        ce.dispose(),
        le.dispose(),
        te.dispose(),
        we.dispose(),
        ge.dispose(),
        Ee.dispose(),
        Ee.removeEventListener("sessionstart", Ae),
        Ee.removeEventListener("sessionend", Ie),
        R && (R.dispose(), (R = null)),
        et.stop();
    });
  function Le(N) {
    N.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      (f = !0);
  }
  function De() {
    console.log("THREE.WebGLRenderer: Context Restored."), (f = !1);
    const N = he.autoReset,
      ae = ne.enabled,
      me = ne.autoUpdate,
      se = ne.needsUpdate,
      ve = ne.type;
    Se(),
      (he.autoReset = N),
      (ne.enabled = ae),
      (ne.autoUpdate = me),
      (ne.needsUpdate = se),
      (ne.type = ve);
  }
  function He(N) {
    console.error(
      "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
      N.statusMessage
    );
  }
  function We(N) {
    const ae = N.target;
    ae.removeEventListener("dispose", We), it(ae);
  }
  function it(N) {
    q(N), pe.remove(N);
  }
  function q(N) {
    const ae = pe.get(N).programs;
    ae !== void 0 &&
      (ae.forEach(function (me) {
        ge.releaseProgram(me);
      }),
      N.isShaderMaterial && ge.releaseShaderCache(N));
  }
  (this.renderBufferDirect = function (N, ae, me, se, ve, ke) {
    ae === null && (ae = I);
    const Ue = ve.isMesh && ve.matrixWorld.determinant() < 0,
      Ge = yS(N, ae, me, se, ve);
    ee.setMaterial(se, Ue);
    let $e = me.index,
      rt = 1;
    se.wireframe === !0 && (($e = oe.getWireframeAttribute(me)), (rt = 2));
    const Ze = me.drawRange,
      Je = me.attributes.position;
    let Et = Ze.start * rt,
      Sn = (Ze.start + Ze.count) * rt;
    ke !== null &&
      ((Et = Math.max(Et, ke.start * rt)),
      (Sn = Math.min(Sn, (ke.start + ke.count) * rt))),
      $e !== null
        ? ((Et = Math.max(Et, 0)), (Sn = Math.min(Sn, $e.count)))
        : Je != null && ((Et = Math.max(Et, 0)), (Sn = Math.min(Sn, Je.count)));
    const Ti = Sn - Et;
    if (Ti < 0 || Ti === 1 / 0) return;
    te.setup(ve, se, Ge, me, $e);
    let Mr,
      At = _e;
    if (
      ($e !== null && ((Mr = ue.get($e)), (At = Pe), At.setIndex(Mr)),
      ve.isMesh)
    )
      se.wireframe === !0
        ? (ee.setLineWidth(se.wireframeLinewidth * E()), At.setMode(1))
        : At.setMode(4);
    else if (ve.isLine) {
      let Qe = se.linewidth;
      Qe === void 0 && (Qe = 1),
        ee.setLineWidth(Qe * E()),
        ve.isLineSegments
          ? At.setMode(1)
          : ve.isLineLoop
          ? At.setMode(2)
          : At.setMode(3);
    } else ve.isPoints ? At.setMode(0) : ve.isSprite && At.setMode(4);
    if (ve.isInstancedMesh) At.renderInstances(Et, Ti, ve.count);
    else if (me.isInstancedBufferGeometry) {
      const Qe = me._maxInstanceCount !== void 0 ? me._maxInstanceCount : 1 / 0,
        dh = Math.min(me.instanceCount, Qe);
      At.renderInstances(Et, Ti, dh);
    } else At.render(Et, Ti);
  }),
    (this.compile = function (N, ae) {
      function me(se, ve, ke) {
        se.transparent === !0 && se.side === ec
          ? ((se.side = Xn),
            (se.needsUpdate = !0),
            Nn(se, ve, ke),
            (se.side = _r),
            (se.needsUpdate = !0),
            Nn(se, ve, ke),
            (se.side = ec))
          : Nn(se, ve, ke);
      }
      (c = L.get(N)),
        c.init(),
        m.push(c),
        N.traverseVisible(function (se) {
          se.isLight &&
            se.layers.test(ae.layers) &&
            (c.pushLight(se), se.castShadow && c.pushShadow(se));
        }),
        c.setupLights(g.physicallyCorrectLights),
        N.traverse(function (se) {
          const ve = se.material;
          if (ve)
            if (Array.isArray(ve))
              for (let ke = 0; ke < ve.length; ke++) {
                const Ue = ve[ke];
                me(Ue, N, se);
              }
            else me(ve, N, se);
        }),
        m.pop(),
        (c = null);
    });
  let fe = null;
  function xe(N) {
    fe && fe(N);
  }
  function Ae() {
    et.stop();
  }
  function Ie() {
    et.start();
  }
  const et = new Gb();
  et.setAnimationLoop(xe),
    typeof self < "u" && et.setContext(self),
    (this.setAnimationLoop = function (N) {
      (fe = N), Ee.setAnimationLoop(N), N === null ? et.stop() : et.start();
    }),
    Ee.addEventListener("sessionstart", Ae),
    Ee.addEventListener("sessionend", Ie),
    (this.render = function (N, ae) {
      if (ae !== void 0 && ae.isCamera !== !0) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
        return;
      }
      if (f === !0) return;
      N.matrixWorldAutoUpdate === !0 && N.updateMatrixWorld(),
        ae.parent === null &&
          ae.matrixWorldAutoUpdate === !0 &&
          ae.updateMatrixWorld(),
        Ee.enabled === !0 &&
          Ee.isPresenting === !0 &&
          (Ee.cameraAutoUpdate === !0 && Ee.updateCamera(ae),
          (ae = Ee.getCamera())),
        N.isScene === !0 && N.onBeforeRender(g, N, ae, _),
        (c = L.get(N, m.length)),
        c.init(),
        m.push(c),
        A.multiplyMatrices(ae.projectionMatrix, ae.matrixWorldInverse),
        re.setFromProjectionMatrix(A),
        (C = this.localClippingEnabled),
        (j = D.init(this.clippingPlanes, C, ae)),
        (l = Me.get(N, h.length)),
        l.init(),
        h.push(l),
        Ct(N, ae, 0, g.sortObjects),
        l.finish(),
        g.sortObjects === !0 && l.sort(J, z),
        j === !0 && D.beginShadows();
      const me = c.state.shadowsArray;
      if (
        (ne.render(me, N, ae),
        j === !0 && D.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        de.render(l, N),
        c.setupLights(g.physicallyCorrectLights),
        ae.isArrayCamera)
      ) {
        const se = ae.cameras;
        for (let ve = 0, ke = se.length; ve < ke; ve++) {
          const Ue = se[ve];
          Xt(l, N, Ue, Ue.viewport);
        }
      } else Xt(l, N, ae);
      _ !== null &&
        (Z.updateMultisampleRenderTarget(_), Z.updateRenderTargetMipmap(_)),
        N.isScene === !0 && N.onAfterRender(g, N, ae),
        te.resetDefaultState(),
        (x = -1),
        (b = null),
        m.pop(),
        m.length > 0 ? (c = m[m.length - 1]) : (c = null),
        h.pop(),
        h.length > 0 ? (l = h[h.length - 1]) : (l = null);
    });
  function Ct(N, ae, me, se) {
    if (N.visible === !1) return;
    if (N.layers.test(ae.layers)) {
      if (N.isGroup) me = N.renderOrder;
      else if (N.isLOD) N.autoUpdate === !0 && N.update(ae);
      else if (N.isLight) c.pushLight(N), N.castShadow && c.pushShadow(N);
      else if (N.isSprite) {
        if (!N.frustumCulled || re.intersectsSprite(N)) {
          se && H.setFromMatrixPosition(N.matrixWorld).applyMatrix4(A);
          const Ue = le.update(N),
            Ge = N.material;
          Ge.visible && l.push(N, Ue, Ge, me, H.z, null);
        }
      } else if (
        (N.isMesh || N.isLine || N.isPoints) &&
        (N.isSkinnedMesh &&
          N.skeleton.frame !== he.render.frame &&
          (N.skeleton.update(), (N.skeleton.frame = he.render.frame)),
        !N.frustumCulled || re.intersectsObject(N))
      ) {
        se && H.setFromMatrixPosition(N.matrixWorld).applyMatrix4(A);
        const Ue = le.update(N),
          Ge = N.material;
        if (Array.isArray(Ge)) {
          const $e = Ue.groups;
          for (let rt = 0, Ze = $e.length; rt < Ze; rt++) {
            const Je = $e[rt],
              Et = Ge[Je.materialIndex];
            Et && Et.visible && l.push(N, Ue, Et, me, H.z, Je);
          }
        } else Ge.visible && l.push(N, Ue, Ge, me, H.z, null);
      }
    }
    const ke = N.children;
    for (let Ue = 0, Ge = ke.length; Ue < Ge; Ue++) Ct(ke[Ue], ae, me, se);
  }
  function Xt(N, ae, me, se) {
    const ve = N.opaque,
      ke = N.transmissive,
      Ue = N.transparent;
    c.setupLightsView(me),
      ke.length > 0 && Cr(ve, ae, me),
      se && ee.viewport(S.copy(se)),
      ve.length > 0 && yt(ve, ae, me),
      ke.length > 0 && yt(ke, ae, me),
      Ue.length > 0 && yt(Ue, ae, me),
      ee.buffers.depth.setTest(!0),
      ee.buffers.depth.setMask(!0),
      ee.buffers.color.setMask(!0),
      ee.setPolygonOffset(!1);
  }
  function Cr(N, ae, me) {
    const se = X.isWebGL2;
    R === null &&
      (R = new as(1, 1, {
        generateMipmaps: !0,
        type: Y.has("EXT_color_buffer_half_float") ? rl : ss,
        minFilter: rs,
        samples: se && o === !0 ? 4 : 0,
      })),
      g.getDrawingBufferSize(O),
      se ? R.setSize(O.x, O.y) : R.setSize(xu(O.x), xu(O.y));
    const ve = g.getRenderTarget();
    g.setRenderTarget(R), g.clear();
    const ke = g.toneMapping;
    (g.toneMapping = Bi),
      yt(N, ae, me),
      (g.toneMapping = ke),
      Z.updateMultisampleRenderTarget(R),
      Z.updateRenderTargetMipmap(R),
      g.setRenderTarget(ve);
  }
  function yt(N, ae, me) {
    const se = ae.isScene === !0 ? ae.overrideMaterial : null;
    for (let ve = 0, ke = N.length; ve < ke; ve++) {
      const Ue = N[ve],
        Ge = Ue.object,
        $e = Ue.geometry,
        rt = se === null ? Ue.material : se,
        Ze = Ue.group;
      Ge.layers.test(me.layers) && wi(Ge, ae, me, $e, rt, Ze);
    }
  }
  function wi(N, ae, me, se, ve, ke) {
    N.onBeforeRender(g, ae, me, se, ve, ke),
      N.modelViewMatrix.multiplyMatrices(me.matrixWorldInverse, N.matrixWorld),
      N.normalMatrix.getNormalMatrix(N.modelViewMatrix),
      ve.onBeforeRender(g, ae, me, se, N, ke),
      ve.transparent === !0 && ve.side === ec
        ? ((ve.side = Xn),
          (ve.needsUpdate = !0),
          g.renderBufferDirect(me, ae, se, ve, N, ke),
          (ve.side = _r),
          (ve.needsUpdate = !0),
          g.renderBufferDirect(me, ae, se, ve, N, ke),
          (ve.side = ec))
        : g.renderBufferDirect(me, ae, se, ve, N, ke),
      N.onAfterRender(g, ae, me, se, ve, ke);
  }
  function Nn(N, ae, me) {
    ae.isScene !== !0 && (ae = I);
    const se = pe.get(N),
      ve = c.state.lights,
      ke = c.state.shadowsArray,
      Ue = ve.state.version,
      Ge = ge.getParameters(N, ve.state, ke, ae, me),
      $e = ge.getProgramCacheKey(Ge);
    let rt = se.programs;
    (se.environment = N.isMeshStandardMaterial ? ae.environment : null),
      (se.fog = ae.fog),
      (se.envMap = (N.isMeshStandardMaterial ? ce : K).get(
        N.envMap || se.environment
      )),
      rt === void 0 &&
        (N.addEventListener("dispose", We),
        (rt = new Map()),
        (se.programs = rt));
    let Ze = rt.get($e);
    if (Ze !== void 0) {
      if (se.currentProgram === Ze && se.lightsStateVersion === Ue)
        return Qm(N, Ge), Ze;
    } else
      (Ge.uniforms = ge.getUniforms(N)),
        N.onBuild(me, Ge, g),
        N.onBeforeCompile(Ge, g),
        (Ze = ge.acquireProgram(Ge, $e)),
        rt.set($e, Ze),
        (se.uniforms = Ge.uniforms);
    const Je = se.uniforms;
    ((!N.isShaderMaterial && !N.isRawShaderMaterial) || N.clipping === !0) &&
      (Je.clippingPlanes = D.uniform),
      Qm(N, Ge),
      (se.needsLights = xS(N)),
      (se.lightsStateVersion = Ue),
      se.needsLights &&
        ((Je.ambientLightColor.value = ve.state.ambient),
        (Je.lightProbe.value = ve.state.probe),
        (Je.directionalLights.value = ve.state.directional),
        (Je.directionalLightShadows.value = ve.state.directionalShadow),
        (Je.spotLights.value = ve.state.spot),
        (Je.spotLightShadows.value = ve.state.spotShadow),
        (Je.rectAreaLights.value = ve.state.rectArea),
        (Je.ltc_1.value = ve.state.rectAreaLTC1),
        (Je.ltc_2.value = ve.state.rectAreaLTC2),
        (Je.pointLights.value = ve.state.point),
        (Je.pointLightShadows.value = ve.state.pointShadow),
        (Je.hemisphereLights.value = ve.state.hemi),
        (Je.directionalShadowMap.value = ve.state.directionalShadowMap),
        (Je.directionalShadowMatrix.value = ve.state.directionalShadowMatrix),
        (Je.spotShadowMap.value = ve.state.spotShadowMap),
        (Je.spotLightMatrix.value = ve.state.spotLightMatrix),
        (Je.spotLightMap.value = ve.state.spotLightMap),
        (Je.pointShadowMap.value = ve.state.pointShadowMap),
        (Je.pointShadowMatrix.value = ve.state.pointShadowMatrix));
    const Et = Ze.getUniforms(),
      Sn = Vc.seqWithValue(Et.seq, Je);
    return (se.currentProgram = Ze), (se.uniformsList = Sn), Ze;
  }
  function Qm(N, ae) {
    const me = pe.get(N);
    (me.outputEncoding = ae.outputEncoding),
      (me.instancing = ae.instancing),
      (me.skinning = ae.skinning),
      (me.morphTargets = ae.morphTargets),
      (me.morphNormals = ae.morphNormals),
      (me.morphColors = ae.morphColors),
      (me.morphTargetsCount = ae.morphTargetsCount),
      (me.numClippingPlanes = ae.numClippingPlanes),
      (me.numIntersection = ae.numClipIntersection),
      (me.vertexAlphas = ae.vertexAlphas),
      (me.vertexTangents = ae.vertexTangents),
      (me.toneMapping = ae.toneMapping);
  }
  function yS(N, ae, me, se, ve) {
    ae.isScene !== !0 && (ae = I), Z.resetTextureUnits();
    const ke = ae.fog,
      Ue = se.isMeshStandardMaterial ? ae.environment : null,
      Ge =
        _ === null
          ? g.outputEncoding
          : _.isXRRenderTarget === !0
          ? _.texture.encoding
          : os,
      $e = (se.isMeshStandardMaterial ? ce : K).get(se.envMap || Ue),
      rt =
        se.vertexColors === !0 &&
        !!me.attributes.color &&
        me.attributes.color.itemSize === 4,
      Ze = !!se.normalMap && !!me.attributes.tangent,
      Je = !!me.morphAttributes.position,
      Et = !!me.morphAttributes.normal,
      Sn = !!me.morphAttributes.color,
      Ti = se.toneMapped ? g.toneMapping : Bi,
      Mr =
        me.morphAttributes.position ||
        me.morphAttributes.normal ||
        me.morphAttributes.color,
      At = Mr !== void 0 ? Mr.length : 0,
      Qe = pe.get(se),
      dh = c.state.lights;
    if (j === !0 && (C === !0 || N !== b)) {
      const wn = N === b && se.id === x;
      D.setState(se, N, wn);
    }
    let Ft = !1;
    se.version === Qe.__version
      ? ((Qe.needsLights && Qe.lightsStateVersion !== dh.state.version) ||
          Qe.outputEncoding !== Ge ||
          (ve.isInstancedMesh && Qe.instancing === !1) ||
          (!ve.isInstancedMesh && Qe.instancing === !0) ||
          (ve.isSkinnedMesh && Qe.skinning === !1) ||
          (!ve.isSkinnedMesh && Qe.skinning === !0) ||
          Qe.envMap !== $e ||
          (se.fog === !0 && Qe.fog !== ke) ||
          (Qe.numClippingPlanes !== void 0 &&
            (Qe.numClippingPlanes !== D.numPlanes ||
              Qe.numIntersection !== D.numIntersection)) ||
          Qe.vertexAlphas !== rt ||
          Qe.vertexTangents !== Ze ||
          Qe.morphTargets !== Je ||
          Qe.morphNormals !== Et ||
          Qe.morphColors !== Sn ||
          Qe.toneMapping !== Ti ||
          (X.isWebGL2 === !0 && Qe.morphTargetsCount !== At)) &&
        (Ft = !0)
      : ((Ft = !0), (Qe.__version = se.version));
    let Er = Qe.currentProgram;
    Ft === !0 && (Er = Nn(se, ae, ve));
    let eg = !1,
      Ko = !1,
      ph = !1;
    const tn = Er.getUniforms(),
      Ar = Qe.uniforms;
    if (
      (ee.useProgram(Er.program) && ((eg = !0), (Ko = !0), (ph = !0)),
      se.id !== x && ((x = se.id), (Ko = !0)),
      eg || b !== N)
    ) {
      if (
        (tn.setValue(k, "projectionMatrix", N.projectionMatrix),
        X.logarithmicDepthBuffer &&
          tn.setValue(k, "logDepthBufFC", 2 / (Math.log(N.far + 1) / Math.LN2)),
        b !== N && ((b = N), (Ko = !0), (ph = !0)),
        se.isShaderMaterial ||
          se.isMeshPhongMaterial ||
          se.isMeshToonMaterial ||
          se.isMeshStandardMaterial ||
          se.envMap)
      ) {
        const wn = tn.map.cameraPosition;
        wn !== void 0 && wn.setValue(k, H.setFromMatrixPosition(N.matrixWorld));
      }
      (se.isMeshPhongMaterial ||
        se.isMeshToonMaterial ||
        se.isMeshLambertMaterial ||
        se.isMeshBasicMaterial ||
        se.isMeshStandardMaterial ||
        se.isShaderMaterial) &&
        tn.setValue(k, "isOrthographic", N.isOrthographicCamera === !0),
        (se.isMeshPhongMaterial ||
          se.isMeshToonMaterial ||
          se.isMeshLambertMaterial ||
          se.isMeshBasicMaterial ||
          se.isMeshStandardMaterial ||
          se.isShaderMaterial ||
          se.isShadowMaterial ||
          ve.isSkinnedMesh) &&
          tn.setValue(k, "viewMatrix", N.matrixWorldInverse);
    }
    if (ve.isSkinnedMesh) {
      tn.setOptional(k, ve, "bindMatrix"),
        tn.setOptional(k, ve, "bindMatrixInverse");
      const wn = ve.skeleton;
      wn &&
        (X.floatVertexTextures
          ? (wn.boneTexture === null && wn.computeBoneTexture(),
            tn.setValue(k, "boneTexture", wn.boneTexture, Z),
            tn.setValue(k, "boneTextureSize", wn.boneTextureSize))
          : console.warn(
              "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
            ));
    }
    const mh = me.morphAttributes;
    if (
      ((mh.position !== void 0 ||
        mh.normal !== void 0 ||
        (mh.color !== void 0 && X.isWebGL2 === !0)) &&
        ye.update(ve, me, se, Er),
      (Ko || Qe.receiveShadow !== ve.receiveShadow) &&
        ((Qe.receiveShadow = ve.receiveShadow),
        tn.setValue(k, "receiveShadow", ve.receiveShadow)),
      se.isMeshGouraudMaterial &&
        se.envMap !== null &&
        ((Ar.envMap.value = $e),
        (Ar.flipEnvMap.value =
          $e.isCubeTexture && $e.isRenderTargetTexture === !1 ? -1 : 1)),
      Ko &&
        (tn.setValue(k, "toneMappingExposure", g.toneMappingExposure),
        Qe.needsLights && _S(Ar, ph),
        ke && se.fog === !0 && Re.refreshFogUniforms(Ar, ke),
        Re.refreshMaterialUniforms(Ar, se, V, F, R),
        Vc.upload(k, Qe.uniformsList, Ar, Z)),
      se.isShaderMaterial &&
        se.uniformsNeedUpdate === !0 &&
        (Vc.upload(k, Qe.uniformsList, Ar, Z), (se.uniformsNeedUpdate = !1)),
      se.isSpriteMaterial && tn.setValue(k, "center", ve.center),
      tn.setValue(k, "modelViewMatrix", ve.modelViewMatrix),
      tn.setValue(k, "normalMatrix", ve.normalMatrix),
      tn.setValue(k, "modelMatrix", ve.matrixWorld),
      se.isShaderMaterial || se.isRawShaderMaterial)
    ) {
      const wn = se.uniformsGroups;
      for (let gh = 0, bS = wn.length; gh < bS; gh++)
        if (X.isWebGL2) {
          const tg = wn[gh];
          we.update(tg, Er), we.bind(tg, Er);
        } else
          console.warn(
            "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
          );
    }
    return Er;
  }
  function _S(N, ae) {
    (N.ambientLightColor.needsUpdate = ae),
      (N.lightProbe.needsUpdate = ae),
      (N.directionalLights.needsUpdate = ae),
      (N.directionalLightShadows.needsUpdate = ae),
      (N.pointLights.needsUpdate = ae),
      (N.pointLightShadows.needsUpdate = ae),
      (N.spotLights.needsUpdate = ae),
      (N.spotLightShadows.needsUpdate = ae),
      (N.rectAreaLights.needsUpdate = ae),
      (N.hemisphereLights.needsUpdate = ae);
  }
  function xS(N) {
    return (
      N.isMeshLambertMaterial ||
      N.isMeshToonMaterial ||
      N.isMeshPhongMaterial ||
      N.isMeshStandardMaterial ||
      N.isShadowMaterial ||
      (N.isShaderMaterial && N.lights === !0)
    );
  }
  (this.getActiveCubeFace = function () {
    return v;
  }),
    (this.getActiveMipmapLevel = function () {
      return y;
    }),
    (this.getRenderTarget = function () {
      return _;
    }),
    (this.setRenderTargetTextures = function (N, ae, me) {
      (pe.get(N.texture).__webglTexture = ae),
        (pe.get(N.depthTexture).__webglTexture = me);
      const se = pe.get(N);
      (se.__hasExternalTextures = !0),
        se.__hasExternalTextures &&
          ((se.__autoAllocateDepthBuffer = me === void 0),
          se.__autoAllocateDepthBuffer ||
            (Y.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (se.__useRenderToTexture = !1))));
    }),
    (this.setRenderTargetFramebuffer = function (N, ae) {
      const me = pe.get(N);
      (me.__webglFramebuffer = ae),
        (me.__useDefaultFramebuffer = ae === void 0);
    }),
    (this.setRenderTarget = function (N, ae = 0, me = 0) {
      (_ = N), (v = ae), (y = me);
      let se = !0,
        ve = null,
        ke = !1,
        Ue = !1;
      if (N) {
        const $e = pe.get(N);
        $e.__useDefaultFramebuffer !== void 0
          ? (ee.bindFramebuffer(36160, null), (se = !1))
          : $e.__webglFramebuffer === void 0
          ? Z.setupRenderTarget(N)
          : $e.__hasExternalTextures &&
            Z.rebindTextures(
              N,
              pe.get(N.texture).__webglTexture,
              pe.get(N.depthTexture).__webglTexture
            );
        const rt = N.texture;
        (rt.isData3DTexture ||
          rt.isDataArrayTexture ||
          rt.isCompressedArrayTexture) &&
          (Ue = !0);
        const Ze = pe.get(N).__webglFramebuffer;
        N.isWebGLCubeRenderTarget
          ? ((ve = Ze[ae]), (ke = !0))
          : X.isWebGL2 && N.samples > 0 && Z.useMultisampledRTT(N) === !1
          ? (ve = pe.get(N).__webglMultisampledFramebuffer)
          : (ve = Ze),
          S.copy(N.viewport),
          T.copy(N.scissor),
          (w = N.scissorTest);
      } else
        S.copy(B).multiplyScalar(V).floor(),
          T.copy(G).multiplyScalar(V).floor(),
          (w = ie);
      if (
        (ee.bindFramebuffer(36160, ve) &&
          X.drawBuffers &&
          se &&
          ee.drawBuffers(N, ve),
        ee.viewport(S),
        ee.scissor(T),
        ee.setScissorTest(w),
        ke)
      ) {
        const $e = pe.get(N.texture);
        k.framebufferTexture2D(36160, 36064, 34069 + ae, $e.__webglTexture, me);
      } else if (Ue) {
        const $e = pe.get(N.texture),
          rt = ae || 0;
        k.framebufferTextureLayer(36160, 36064, $e.__webglTexture, me || 0, rt);
      }
      x = -1;
    }),
    (this.readRenderTargetPixels = function (N, ae, me, se, ve, ke, Ue) {
      if (!(N && N.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
        return;
      }
      let Ge = pe.get(N).__webglFramebuffer;
      if ((N.isWebGLCubeRenderTarget && Ue !== void 0 && (Ge = Ge[Ue]), Ge)) {
        ee.bindFramebuffer(36160, Ge);
        try {
          const $e = N.texture,
            rt = $e.format,
            Ze = $e.type;
          if (rt !== Wn && U.convert(rt) !== k.getParameter(35739)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            );
            return;
          }
          const Je =
            Ze === rl &&
            (Y.has("EXT_color_buffer_half_float") ||
              (X.isWebGL2 && Y.has("EXT_color_buffer_float")));
          if (
            Ze !== ss &&
            U.convert(Ze) !== k.getParameter(35738) &&
            !(
              Ze === or &&
              (X.isWebGL2 ||
                Y.has("OES_texture_float") ||
                Y.has("WEBGL_color_buffer_float"))
            ) &&
            !Je
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
            return;
          }
          ae >= 0 &&
            ae <= N.width - se &&
            me >= 0 &&
            me <= N.height - ve &&
            k.readPixels(ae, me, se, ve, U.convert(rt), U.convert(Ze), ke);
        } finally {
          const $e = _ !== null ? pe.get(_).__webglFramebuffer : null;
          ee.bindFramebuffer(36160, $e);
        }
      }
    }),
    (this.copyFramebufferToTexture = function (N, ae, me = 0) {
      const se = Math.pow(2, -me),
        ve = Math.floor(ae.image.width * se),
        ke = Math.floor(ae.image.height * se);
      Z.setTexture2D(ae, 0),
        k.copyTexSubImage2D(3553, me, 0, 0, N.x, N.y, ve, ke),
        ee.unbindTexture();
    }),
    (this.copyTextureToTexture = function (N, ae, me, se = 0) {
      const ve = ae.image.width,
        ke = ae.image.height,
        Ue = U.convert(me.format),
        Ge = U.convert(me.type);
      Z.setTexture2D(me, 0),
        k.pixelStorei(37440, me.flipY),
        k.pixelStorei(37441, me.premultiplyAlpha),
        k.pixelStorei(3317, me.unpackAlignment),
        ae.isDataTexture
          ? k.texSubImage2D(3553, se, N.x, N.y, ve, ke, Ue, Ge, ae.image.data)
          : ae.isCompressedTexture
          ? k.compressedTexSubImage2D(
              3553,
              se,
              N.x,
              N.y,
              ae.mipmaps[0].width,
              ae.mipmaps[0].height,
              Ue,
              ae.mipmaps[0].data
            )
          : k.texSubImage2D(3553, se, N.x, N.y, Ue, Ge, ae.image),
        se === 0 && me.generateMipmaps && k.generateMipmap(3553),
        ee.unbindTexture();
    }),
    (this.copyTextureToTexture3D = function (N, ae, me, se, ve = 0) {
      if (g.isWebGL1Renderer) {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
        );
        return;
      }
      const ke = N.max.x - N.min.x + 1,
        Ue = N.max.y - N.min.y + 1,
        Ge = N.max.z - N.min.z + 1,
        $e = U.convert(se.format),
        rt = U.convert(se.type);
      let Ze;
      if (se.isData3DTexture) Z.setTexture3D(se, 0), (Ze = 32879);
      else if (se.isDataArrayTexture) Z.setTexture2DArray(se, 0), (Ze = 35866);
      else {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
        );
        return;
      }
      k.pixelStorei(37440, se.flipY),
        k.pixelStorei(37441, se.premultiplyAlpha),
        k.pixelStorei(3317, se.unpackAlignment);
      const Je = k.getParameter(3314),
        Et = k.getParameter(32878),
        Sn = k.getParameter(3316),
        Ti = k.getParameter(3315),
        Mr = k.getParameter(32877),
        At = me.isCompressedTexture ? me.mipmaps[0] : me.image;
      k.pixelStorei(3314, At.width),
        k.pixelStorei(32878, At.height),
        k.pixelStorei(3316, N.min.x),
        k.pixelStorei(3315, N.min.y),
        k.pixelStorei(32877, N.min.z),
        me.isDataTexture || me.isData3DTexture
          ? k.texSubImage3D(
              Ze,
              ve,
              ae.x,
              ae.y,
              ae.z,
              ke,
              Ue,
              Ge,
              $e,
              rt,
              At.data
            )
          : me.isCompressedArrayTexture
          ? (console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
            ),
            k.compressedTexSubImage3D(
              Ze,
              ve,
              ae.x,
              ae.y,
              ae.z,
              ke,
              Ue,
              Ge,
              $e,
              At.data
            ))
          : k.texSubImage3D(Ze, ve, ae.x, ae.y, ae.z, ke, Ue, Ge, $e, rt, At),
        k.pixelStorei(3314, Je),
        k.pixelStorei(32878, Et),
        k.pixelStorei(3316, Sn),
        k.pixelStorei(3315, Ti),
        k.pixelStorei(32877, Mr),
        ve === 0 && se.generateMipmaps && k.generateMipmap(Ze),
        ee.unbindTexture();
    }),
    (this.initTexture = function (N) {
      N.isCubeTexture
        ? Z.setTextureCube(N, 0)
        : N.isData3DTexture
        ? Z.setTexture3D(N, 0)
        : N.isDataArrayTexture || N.isCompressedArrayTexture
        ? Z.setTexture2DArray(N, 0)
        : Z.setTexture2D(N, 0),
        ee.unbindTexture();
    }),
    (this.resetState = function () {
      (v = 0), (y = 0), (_ = null), ee.reset(), te.reset();
    }),
    typeof __THREE_DEVTOOLS__ < "u" &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
class oO extends qb {}
oO.prototype.isWebGL1Renderer = !0;
class aO extends St {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
  get autoUpdate() {
    return (
      console.warn(
        "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
      ),
      this.matrixWorldAutoUpdate
    );
  }
  set autoUpdate(e) {
    console.warn(
      "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
    ),
      (this.matrixWorldAutoUpdate = e);
  }
}
class lO {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = jd),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = oi());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let r = 0, o = this.stride; r < o; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = oi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = oi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const rn = new Q();
class cm {
  constructor(e, t, i, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      rn.fromBufferAttribute(this, t),
        rn.applyMatrix4(e),
        this.setXYZ(t, rn.x, rn.y, rn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      rn.fromBufferAttribute(this, t),
        rn.applyNormalMatrix(e),
        this.setXYZ(t, rn.x, rn.y, rn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      rn.fromBufferAttribute(this, t),
        rn.transformDirection(e),
        this.setXYZ(t, rn.x, rn.y, rn.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = ct(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = ct(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = ct(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = ct(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Fi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Fi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Fi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Fi(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = ct(t, this.array)), (i = ct(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = ct(t, this.array)),
        (i = ct(i, this.array)),
        (r = ct(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = ct(t, this.array)),
        (i = ct(i, this.array)),
        (r = ct(r, this.array)),
        (o = ct(o, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = o),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[r + o]);
      }
      return new Gt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new cm(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) t.push(this.data.array[r + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
const b0 = new Q(),
  S0 = new ht(),
  w0 = new ht(),
  cO = new Q(),
  T0 = new Xe();
class uO extends vn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new Xe()),
      (this.bindMatrixInverse = new Xe());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    );
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new ht(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  boneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    S0.fromBufferAttribute(r.attributes.skinIndex, e),
      w0.fromBufferAttribute(r.attributes.skinWeight, e),
      b0.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const p = w0.getComponent(o);
      if (p !== 0) {
        const a = S0.getComponent(o);
        T0.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(cO.copy(b0).applyMatrix4(T0), p);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Zb extends St {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class hO extends jt {
  constructor(e = null, t = 1, i = 1, r, o, p, a, s, u = zt, d = zt, l, c) {
    super(null, p, a, s, u, d, r, o, l, c),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const C0 = new Xe(),
  fO = new Xe();
class um {
  constructor(e = [], t = []) {
    (this.uuid = oi()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new Xe());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new Xe();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let o = 0, p = e.length; o < p; o++) {
      const a = e[o] ? e[o].matrixWorld : fO;
      C0.multiplyMatrices(a, t[o]), C0.toArray(i, o * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new um(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Rb(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new hO(t, e, e, Wn, or);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const o = e.bones[i];
      let p = t[o];
      p === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", o),
        (p = new Zb())),
        this.bones.push(p),
        this.boneInverses.push(new Xe().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, o = t.length; r < o; r++) {
      const p = t[r];
      e.bones.push(p.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class M0 extends Gt {
  constructor(e, t, i, r = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const E0 = new Xe(),
  A0 = new Xe(),
  _c = [],
  dO = new Xe(),
  ha = new vn();
class pO extends vn {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new M0(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.frustumCulled = !1);
    for (let r = 0; r < i; r++) this.setMatrixAt(r, dO);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((ha.geometry = this.geometry),
      (ha.material = this.material),
      ha.material !== void 0)
    )
      for (let o = 0; o < r; o++) {
        this.getMatrixAt(o, E0),
          A0.multiplyMatrices(i, E0),
          (ha.matrixWorld = A0),
          ha.raycast(e, _c);
        for (let p = 0, a = _c.length; p < a; p++) {
          const s = _c[p];
          (s.instanceId = o), (s.object = this), t.push(s);
        }
        _c.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new M0(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ba extends Ln {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new je(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const P0 = new Q(),
  O0 = new Q(),
  L0 = new Xe(),
  xf = new rm(),
  xc = new Ro();
class hm extends St {
  constructor(e = new Rn(), t = new Ba()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, o = t.count; r < o; r++)
        P0.fromBufferAttribute(t, r - 1),
          O0.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += P0.distanceTo(O0));
      e.setAttribute("lineDistance", new an(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      o = e.params.Line.threshold,
      p = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      xc.copy(i.boundingSphere),
      xc.applyMatrix4(r),
      (xc.radius += o),
      e.ray.intersectsSphere(xc) === !1)
    )
      return;
    L0.copy(r).invert(), xf.copy(e.ray).applyMatrix4(L0);
    const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      s = a * a,
      u = new Q(),
      d = new Q(),
      l = new Q(),
      c = new Q(),
      h = this.isLineSegments ? 2 : 1,
      m = i.index,
      f = i.attributes.position;
    if (m !== null) {
      const v = Math.max(0, p.start),
        y = Math.min(m.count, p.start + p.count);
      for (let _ = v, x = y - 1; _ < x; _ += h) {
        const b = m.getX(_),
          S = m.getX(_ + 1);
        if (
          (u.fromBufferAttribute(f, b),
          d.fromBufferAttribute(f, S),
          xf.distanceSqToSegment(u, d, c, l) > s)
        )
          continue;
        c.applyMatrix4(this.matrixWorld);
        const w = e.ray.origin.distanceTo(c);
        w < e.near ||
          w > e.far ||
          t.push({
            distance: w,
            point: l.clone().applyMatrix4(this.matrixWorld),
            index: _,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const v = Math.max(0, p.start),
        y = Math.min(f.count, p.start + p.count);
      for (let _ = v, x = y - 1; _ < x; _ += h) {
        if (
          (u.fromBufferAttribute(f, _),
          d.fromBufferAttribute(f, _ + 1),
          xf.distanceSqToSegment(u, d, c, l) > s)
        )
          continue;
        c.applyMatrix4(this.matrixWorld);
        const S = e.ray.origin.distanceTo(c);
        S < e.near ||
          S > e.far ||
          t.push({
            distance: S,
            point: l.clone().applyMatrix4(this.matrixWorld),
            index: _,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, p = r.length; o < p; o++) {
          const a = r[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
}
const D0 = new Q(),
  R0 = new Q();
class Gd extends hm {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, o = t.count; r < o; r += 2)
        D0.fromBufferAttribute(t, r),
          R0.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + D0.distanceTo(R0));
      e.setAttribute("lineDistance", new an(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class mO extends hm {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Ks extends Ln {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new je(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const I0 = new Xe(),
  $d = new rm(),
  bc = new Ro(),
  Sc = new Q();
class Wc extends St {
  constructor(e = new Rn(), t = new Ks()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      o = e.params.Points.threshold,
      p = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      bc.copy(i.boundingSphere),
      bc.applyMatrix4(r),
      (bc.radius += o),
      e.ray.intersectsSphere(bc) === !1)
    )
      return;
    I0.copy(r).invert(), $d.copy(e.ray).applyMatrix4(I0);
    const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      s = a * a,
      u = i.index,
      l = i.attributes.position;
    if (u !== null) {
      const c = Math.max(0, p.start),
        h = Math.min(u.count, p.start + p.count);
      for (let m = c, g = h; m < g; m++) {
        const f = u.getX(m);
        Sc.fromBufferAttribute(l, f), k0(Sc, f, s, r, e, t, this);
      }
    } else {
      const c = Math.max(0, p.start),
        h = Math.min(l.count, p.start + p.count);
      for (let m = c, g = h; m < g; m++)
        Sc.fromBufferAttribute(l, m), k0(Sc, m, s, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, p = r.length; o < p; o++) {
          const a = r[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
}
function k0(n, e, t, i, r, o, p) {
  const a = $d.distanceSqToPoint(n);
  if (a < t) {
    const s = new Q();
    $d.closestPointToPoint(n, s), s.applyMatrix4(i);
    const u = r.ray.origin.distanceTo(s);
    if (u < r.near || u > r.far) return;
    o.push({
      distance: u,
      distanceToRay: Math.sqrt(a),
      point: s,
      index: e,
      face: null,
      object: p,
    });
  }
}
class gO extends jt {
  constructor(e, t, i, r, o, p, a, s, u) {
    super(e, t, i, r, o, p, a, s, u),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class fm extends Ln {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new je(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = nm),
      (this.normalScale = new ze(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class ds extends fm {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new ze(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Jt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new je(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new je(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new je(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class vO extends Ln {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new je(16777215)),
      (this.specular = new je(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = nm),
      (this.normalScale = new ze(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = tm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
function qi(n, e, t) {
  return Jb(n)
    ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length))
    : n.slice(e, t);
}
function wc(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function Jb(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function yO(n) {
  function e(r, o) {
    return n[r] - n[o];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function F0(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let o = 0, p = 0; p !== i; ++o) {
    const a = t[o] * e;
    for (let s = 0; s !== e; ++s) r[p++] = n[a + s];
  }
  return r;
}
function Qb(n, e, t, i) {
  let r = 1,
    o = n[0];
  for (; o !== void 0 && o[i] === void 0; ) o = n[r++];
  if (o === void 0) return;
  let p = o[i];
  if (p !== void 0)
    if (Array.isArray(p))
      do
        (p = o[i]),
          p !== void 0 && (e.push(o.time), t.push.apply(t, p)),
          (o = n[r++]);
      while (o !== void 0);
    else if (p.toArray !== void 0)
      do
        (p = o[i]),
          p !== void 0 && (e.push(o.time), p.toArray(t, t.length)),
          (o = n[r++]);
      while (o !== void 0);
    else
      do (p = o[i]), p !== void 0 && (e.push(o.time), t.push(p)), (o = n[r++]);
      while (o !== void 0);
}
class wl {
  constructor(e, t, i, r) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      o = t[i - 1];
    e: {
      t: {
        let p;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < o) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((o = r), (r = t[++i]), e < r)) break t;
            }
            p = t.length;
            break n;
          }
          if (!(e >= o)) {
            const a = t[1];
            e < a && ((i = 2), (o = a));
            for (let s = i - 2; ; ) {
              if (o === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === s) break;
              if (((r = o), (o = t[--i - 1]), e >= o)) break t;
            }
            (p = i), (i = 0);
            break n;
          }
          break e;
        }
        for (; i < p; ) {
          const a = (i + p) >>> 1;
          e < t[a] ? (p = a) : (i = a + 1);
        }
        if (((r = t[i]), (o = t[i - 1]), o === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, o, r);
    }
    return this.interpolate_(i, o, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      o = e * r;
    for (let p = 0; p !== r; ++p) t[p] = i[o + p];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class _O extends wl {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Bv, endingEnd: Bv });
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let o = e - 2,
      p = e + 1,
      a = r[o],
      s = r[p];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case zv:
          (o = e), (a = 2 * t - i);
          break;
        case Uv:
          (o = r.length - 2), (a = t + r[o] - r[o + 1]);
          break;
        default:
          (o = e), (a = i);
      }
    if (s === void 0)
      switch (this.getSettings_().endingEnd) {
        case zv:
          (p = e), (s = 2 * i - t);
          break;
        case Uv:
          (p = 1), (s = i + r[1] - r[0]);
          break;
        default:
          (p = e - 1), (s = t);
      }
    const u = (i - t) * 0.5,
      d = this.valueSize;
    (this._weightPrev = u / (t - a)),
      (this._weightNext = u / (s - i)),
      (this._offsetPrev = o * d),
      (this._offsetNext = p * d);
  }
  interpolate_(e, t, i, r) {
    const o = this.resultBuffer,
      p = this.sampleValues,
      a = this.valueSize,
      s = e * a,
      u = s - a,
      d = this._offsetPrev,
      l = this._offsetNext,
      c = this._weightPrev,
      h = this._weightNext,
      m = (i - t) / (r - t),
      g = m * m,
      f = g * m,
      v = -c * f + 2 * c * g - c * m,
      y = (1 + c) * f + (-1.5 - 2 * c) * g + (-0.5 + c) * m + 1,
      _ = (-1 - h) * f + (1.5 + h) * g + 0.5 * m,
      x = h * f - h * g;
    for (let b = 0; b !== a; ++b)
      o[b] = v * p[d + b] + y * p[u + b] + _ * p[s + b] + x * p[l + b];
    return o;
  }
}
class xO extends wl {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const o = this.resultBuffer,
      p = this.sampleValues,
      a = this.valueSize,
      s = e * a,
      u = s - a,
      d = (i - t) / (r - t),
      l = 1 - d;
    for (let c = 0; c !== a; ++c) o[c] = p[u + c] * l + p[s + c] * d;
    return o;
  }
}
class bO extends wl {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Si {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = wc(t, this.TimeBufferType)),
      (this.values = wc(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: wc(e.times, Array),
        values: wc(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new bO(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new xO(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new _O(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case sl:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case So:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Xh:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return sl;
      case this.InterpolantFactoryMethodLinear:
        return So;
      case this.InterpolantFactoryMethodSmooth:
        return Xh;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let o = 0,
      p = r - 1;
    for (; o !== r && i[o] < e; ) ++o;
    for (; p !== -1 && i[p] > t; ) --p;
    if ((++p, o !== 0 || p !== r)) {
      o >= p && ((p = Math.max(p, 1)), (o = p - 1));
      const a = this.getValueSize();
      (this.times = qi(i, o, p)), (this.values = qi(this.values, o * a, p * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      o = i.length;
    o === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let p = null;
    for (let a = 0; a !== o; a++) {
      const s = i[a];
      if (typeof s == "number" && isNaN(s)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          s
        ),
          (e = !1);
        break;
      }
      if (p !== null && p > s) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, p),
          (e = !1);
        break;
      }
      p = s;
    }
    if (r !== void 0 && Jb(r))
      for (let a = 0, s = r.length; a !== s; ++a) {
        const u = r[a];
        if (isNaN(u)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            u
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = qi(this.times),
      t = qi(this.values),
      i = this.getValueSize(),
      r = this.getInterpolation() === Xh,
      o = e.length - 1;
    let p = 1;
    for (let a = 1; a < o; ++a) {
      let s = !1;
      const u = e[a],
        d = e[a + 1];
      if (u !== d && (a !== 1 || u !== e[0]))
        if (r) s = !0;
        else {
          const l = a * i,
            c = l - i,
            h = l + i;
          for (let m = 0; m !== i; ++m) {
            const g = t[l + m];
            if (g !== t[c + m] || g !== t[h + m]) {
              s = !0;
              break;
            }
          }
        }
      if (s) {
        if (a !== p) {
          e[p] = e[a];
          const l = a * i,
            c = p * i;
          for (let h = 0; h !== i; ++h) t[c + h] = t[l + h];
        }
        ++p;
      }
    }
    if (o > 0) {
      e[p] = e[o];
      for (let a = o * i, s = p * i, u = 0; u !== i; ++u) t[s + u] = t[a + u];
      ++p;
    }
    return (
      p !== e.length
        ? ((this.times = qi(e, 0, p)), (this.values = qi(t, 0, p * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = qi(this.times, 0),
      t = qi(this.values, 0),
      i = this.constructor,
      r = new i(this.name, e, t);
    return (r.createInterpolant = this.createInterpolant), r;
  }
}
Si.prototype.TimeBufferType = Float32Array;
Si.prototype.ValueBufferType = Float32Array;
Si.prototype.DefaultInterpolation = So;
class ko extends Si {}
ko.prototype.ValueTypeName = "bool";
ko.prototype.ValueBufferType = Array;
ko.prototype.DefaultInterpolation = sl;
ko.prototype.InterpolantFactoryMethodLinear = void 0;
ko.prototype.InterpolantFactoryMethodSmooth = void 0;
class e1 extends Si {}
e1.prototype.ValueTypeName = "color";
class cl extends Si {}
cl.prototype.ValueTypeName = "number";
class SO extends wl {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const o = this.resultBuffer,
      p = this.sampleValues,
      a = this.valueSize,
      s = (i - t) / (r - t);
    let u = e * a;
    for (let d = u + a; u !== d; u += 4) xi.slerpFlat(o, 0, p, u - a, p, u, s);
    return o;
  }
}
class cs extends Si {
  InterpolantFactoryMethodLinear(e) {
    return new SO(this.times, this.values, this.getValueSize(), e);
  }
}
cs.prototype.ValueTypeName = "quaternion";
cs.prototype.DefaultInterpolation = So;
cs.prototype.InterpolantFactoryMethodSmooth = void 0;
class Fo extends Si {}
Fo.prototype.ValueTypeName = "string";
Fo.prototype.ValueBufferType = Array;
Fo.prototype.DefaultInterpolation = sl;
Fo.prototype.InterpolantFactoryMethodLinear = void 0;
Fo.prototype.InterpolantFactoryMethodSmooth = void 0;
class ul extends Si {}
ul.prototype.ValueTypeName = "vector";
class wO {
  constructor(e, t = -1, i, r = HC) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = oi()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let p = 0, a = i.length; p !== a; ++p) t.push(CO(i[p]).scale(r));
    const o = new this(e.name, e.duration, t, e.blendMode);
    return (o.uuid = e.uuid), o;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let o = 0, p = i.length; o !== p; ++o) t.push(Si.toJSON(i[o]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const o = t.length,
      p = [];
    for (let a = 0; a < o; a++) {
      let s = [],
        u = [];
      s.push((a + o - 1) % o, a, (a + 1) % o), u.push(0, 1, 0);
      const d = yO(s);
      (s = F0(s, 1, d)),
        (u = F0(u, 1, d)),
        !r && s[0] === 0 && (s.push(o), u.push(u[0])),
        p.push(
          new cl(".morphTargetInfluences[" + t[a].name + "]", s, u).scale(1 / i)
        );
    }
    return new this(e, -1, p);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      o = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, s = e.length; a < s; a++) {
      const u = e[a],
        d = u.name.match(o);
      if (d && d.length > 1) {
        const l = d[1];
        let c = r[l];
        c || (r[l] = c = []), c.push(u);
      }
    }
    const p = [];
    for (const a in r)
      p.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return p;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (l, c, h, m, g) {
        if (h.length !== 0) {
          const f = [],
            v = [];
          Qb(h, f, v, m), f.length !== 0 && g.push(new l(c, f, v));
        }
      },
      r = [],
      o = e.name || "default",
      p = e.fps || 30,
      a = e.blendMode;
    let s = e.length || -1;
    const u = e.hierarchy || [];
    for (let l = 0; l < u.length; l++) {
      const c = u[l].keys;
      if (!(!c || c.length === 0))
        if (c[0].morphTargets) {
          const h = {};
          let m;
          for (m = 0; m < c.length; m++)
            if (c[m].morphTargets)
              for (let g = 0; g < c[m].morphTargets.length; g++)
                h[c[m].morphTargets[g]] = -1;
          for (const g in h) {
            const f = [],
              v = [];
            for (let y = 0; y !== c[m].morphTargets.length; ++y) {
              const _ = c[m];
              f.push(_.time), v.push(_.morphTarget === g ? 1 : 0);
            }
            r.push(new cl(".morphTargetInfluence[" + g + "]", f, v));
          }
          s = h.length * p;
        } else {
          const h = ".bones[" + t[l].name + "]";
          i(ul, h + ".position", c, "pos", r),
            i(cs, h + ".quaternion", c, "rot", r),
            i(ul, h + ".scale", c, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(o, s, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const o = this.tracks[i];
      t = Math.max(t, o.times[o.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function TO(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return cl;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return ul;
    case "color":
      return e1;
    case "quaternion":
      return cs;
    case "bool":
    case "boolean":
      return ko;
    case "string":
      return Fo;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function CO(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = TO(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    Qb(n.keys, t, i, "value"), (n.times = t), (n.values = i);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const To = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class MO {
  constructor(e, t, i) {
    const r = this;
    let o = !1,
      p = 0,
      a = 0,
      s;
    const u = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (d) {
        a++, o === !1 && r.onStart !== void 0 && r.onStart(d, p, a), (o = !0);
      }),
      (this.itemEnd = function (d) {
        p++,
          r.onProgress !== void 0 && r.onProgress(d, p, a),
          p === a && ((o = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (d) {
        r.onError !== void 0 && r.onError(d);
      }),
      (this.resolveURL = function (d) {
        return s ? s(d) : d;
      }),
      (this.setURLModifier = function (d) {
        return (s = d), this;
      }),
      (this.addHandler = function (d, l) {
        return u.push(d, l), this;
      }),
      (this.removeHandler = function (d) {
        const l = u.indexOf(d);
        return l !== -1 && u.splice(l, 2), this;
      }),
      (this.getHandler = function (d) {
        for (let l = 0, c = u.length; l < c; l += 2) {
          const h = u[l],
            m = u[l + 1];
          if ((h.global && (h.lastIndex = 0), h.test(d))) return m;
        }
        return null;
      });
  }
}
const EO = new MO();
class ps {
  constructor(e) {
    (this.manager = e !== void 0 ? e : EO),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, o) {
      i.load(e, r, t, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
const Oi = {};
class AO extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class hl extends ps {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = To.get(e);
    if (o !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(o), this.manager.itemEnd(e);
        }, 0),
        o
      );
    if (Oi[e] !== void 0) {
      Oi[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    (Oi[e] = []), Oi[e].push({ onLoad: t, onProgress: i, onError: r });
    const p = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      s = this.responseType;
    fetch(p)
      .then((u) => {
        if (u.status === 200 || u.status === 0) {
          if (
            (u.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              u.body === void 0 ||
              u.body.getReader === void 0)
          )
            return u;
          const d = Oi[e],
            l = u.body.getReader(),
            c = u.headers.get("Content-Length") || u.headers.get("X-File-Size"),
            h = c ? parseInt(c) : 0,
            m = h !== 0;
          let g = 0;
          const f = new ReadableStream({
            start(v) {
              y();
              function y() {
                l.read().then(({ done: _, value: x }) => {
                  if (_) v.close();
                  else {
                    g += x.byteLength;
                    const b = new ProgressEvent("progress", {
                      lengthComputable: m,
                      loaded: g,
                      total: h,
                    });
                    for (let S = 0, T = d.length; S < T; S++) {
                      const w = d[S];
                      w.onProgress && w.onProgress(b);
                    }
                    v.enqueue(x), y();
                  }
                });
              }
            },
          });
          return new Response(f);
        } else
          throw new AO(
            `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,
            u
          );
      })
      .then((u) => {
        switch (s) {
          case "arraybuffer":
            return u.arrayBuffer();
          case "blob":
            return u.blob();
          case "document":
            return u.text().then((d) => new DOMParser().parseFromString(d, a));
          case "json":
            return u.json();
          default:
            if (a === void 0) return u.text();
            {
              const l = /charset="?([^;"\s]*)"?/i.exec(a),
                c = l && l[1] ? l[1].toLowerCase() : void 0,
                h = new TextDecoder(c);
              return u.arrayBuffer().then((m) => h.decode(m));
            }
        }
      })
      .then((u) => {
        To.add(e, u);
        const d = Oi[e];
        delete Oi[e];
        for (let l = 0, c = d.length; l < c; l++) {
          const h = d[l];
          h.onLoad && h.onLoad(u);
        }
      })
      .catch((u) => {
        const d = Oi[e];
        if (d === void 0) throw (this.manager.itemError(e), u);
        delete Oi[e];
        for (let l = 0, c = d.length; l < c; l++) {
          const h = d[l];
          h.onError && h.onError(u);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class PO extends ps {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      p = To.get(e);
    if (p !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          t && t(p), o.manager.itemEnd(e);
        }, 0),
        p
      );
    const a = ll("img");
    function s() {
      d(), To.add(e, this), t && t(this), o.manager.itemEnd(e);
    }
    function u(l) {
      d(), r && r(l), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function d() {
      a.removeEventListener("load", s, !1),
        a.removeEventListener("error", u, !1);
    }
    return (
      a.addEventListener("load", s, !1),
      a.addEventListener("error", u, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class OO extends ps {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const o = new jt(),
      p = new PO(this.manager);
    return (
      p.setCrossOrigin(this.crossOrigin),
      p.setPath(this.path),
      p.load(
        e,
        function (a) {
          (o.image = a), (o.needsUpdate = !0), t !== void 0 && t(o);
        },
        i,
        r
      ),
      o
    );
  }
}
class $u extends St {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new je(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
const bf = new Xe(),
  N0 = new Q(),
  B0 = new Q();
class dm {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new ze(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Xe()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new sm()),
      (this._frameExtents = new ze(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new ht(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    N0.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(N0),
      B0.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(B0),
      t.updateMatrixWorld(),
      bf.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(bf),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(bf);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class LO extends dm {
  constructor() {
    super(new ln(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = al * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      o = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || o !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = o), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class DO extends $u {
  constructor(e, t, i = 0, r = Math.PI / 3, o = 0, p = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(St.DefaultUp),
      this.updateMatrix(),
      (this.target = new St()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = o),
      (this.decay = p),
      (this.map = null),
      (this.shadow = new LO());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const z0 = new Xe(),
  fa = new Q(),
  Sf = new Q();
class RO extends dm {
  constructor() {
    super(new ln(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new ze(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new ht(2, 1, 1, 1),
        new ht(0, 1, 1, 1),
        new ht(3, 1, 1, 1),
        new ht(1, 1, 1, 1),
        new ht(3, 0, 1, 1),
        new ht(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Q(1, 0, 0),
        new Q(-1, 0, 0),
        new Q(0, 0, 1),
        new Q(0, 0, -1),
        new Q(0, 1, 0),
        new Q(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Q(0, 1, 0),
        new Q(0, 1, 0),
        new Q(0, 1, 0),
        new Q(0, 1, 0),
        new Q(0, 0, 1),
        new Q(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      o = e.distance || i.far;
    o !== i.far && ((i.far = o), i.updateProjectionMatrix()),
      fa.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(fa),
      Sf.copy(i.position),
      Sf.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(Sf),
      i.updateMatrixWorld(),
      r.makeTranslation(-fa.x, -fa.y, -fa.z),
      z0.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(z0);
  }
}
class t1 extends $u {
  constructor(e, t, i = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new RO());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class IO extends dm {
  constructor() {
    super(new am(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class kO extends $u {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(St.DefaultUp),
      this.updateMatrix(),
      (this.target = new St()),
      (this.shadow = new IO());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class FO extends $u {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class Zr {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class NO extends ps {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      p = To.get(e);
    if (p !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          t && t(p), o.manager.itemEnd(e);
        }, 0),
        p
      );
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (s) {
          return s.blob();
        })
        .then(function (s) {
          return createImageBitmap(
            s,
            Object.assign(o.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (s) {
          To.add(e, s), t && t(s), o.manager.itemEnd(e);
        })
        .catch(function (s) {
          r && r(s), o.manager.itemError(e), o.manager.itemEnd(e);
        }),
      o.manager.itemStart(e);
  }
}
const pm = "\\[\\]\\.:\\/",
  BO = new RegExp("[" + pm + "]", "g"),
  mm = "[^" + pm + "]",
  zO = "[^" + pm.replace("\\.", "") + "]",
  UO = /((?:WC+[\/:])*)/.source.replace("WC", mm),
  jO = /(WCOD+)?/.source.replace("WCOD", zO),
  HO = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", mm),
  VO = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", mm),
  WO = new RegExp("^" + UO + jO + HO + VO + "$"),
  GO = ["material", "materials", "bones", "map"];
class $O {
  constructor(e, t, i) {
    const r = i || at.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, o = i.length; r !== o; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class at {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || at.parseTrackName(t)),
      (this.node = at.findNode(e, this.parsedPath.nodeName) || e),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new at.Composite(e, t, i)
      : new at(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(BO, "");
  }
  static parseTrackName(e) {
    const t = WO.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const o = i.nodeName.substring(r + 1);
      GO.indexOf(o) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = o));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (o) {
          for (let p = 0; p < o.length; p++) {
            const a = o[p];
            if (a.name === t || a.uuid === t) return a;
            const s = i(a.children);
            if (s) return s;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, o = i.length; r !== o; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, o = i.length; r !== o; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, o = i.length; r !== o; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, o = i.length; r !== o; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let o = t.propertyIndex;
    if (
      (e ||
        ((e = at.findNode(this.rootNode, t.nodeName) || this.rootNode),
        (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (i) {
      let u = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let d = 0; d < e.length; d++)
            if (e[d].name === u) {
              u = d;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (u !== void 0) {
        if (e[u] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[u];
      }
    }
    const p = e[r];
    if (p === void 0) {
      const u = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          u +
          "." +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let s = this.BindingType.Direct;
    if (o !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[o] !== void 0 &&
          (o = e.morphTargetDictionary[o]);
      }
      (s = this.BindingType.ArrayElement),
        (this.resolvedProperty = p),
        (this.propertyIndex = o);
    } else
      p.fromArray !== void 0 && p.toArray !== void 0
        ? ((s = this.BindingType.HasFromToArray), (this.resolvedProperty = p))
        : Array.isArray(p)
        ? ((s = this.BindingType.EntireArray), (this.resolvedProperty = p))
        : (this.propertyName = r);
    (this.getValue = this.GetterByBindingType[s]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[s][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
at.Composite = $O;
at.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
at.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
at.prototype.GetterByBindingType = [
  at.prototype._getValue_direct,
  at.prototype._getValue_array,
  at.prototype._getValue_arrayElement,
  at.prototype._getValue_toArray,
];
at.prototype.SetterByBindingTypeAndVersioning = [
  [
    at.prototype._setValue_direct,
    at.prototype._setValue_direct_setNeedsUpdate,
    at.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    at.prototype._setValue_array,
    at.prototype._setValue_array_setNeedsUpdate,
    at.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    at.prototype._setValue_arrayElement,
    at.prototype._setValue_arrayElement_setNeedsUpdate,
    at.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    at.prototype._setValue_fromArray,
    at.prototype._setValue_fromArray_setNeedsUpdate,
    at.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class U0 {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(Jt(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: em } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = em));
const j0 = { type: "change" },
  wf = { type: "start" },
  H0 = { type: "end" };
class XO extends fs {
  constructor(e, t) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new Q()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: ys.ROTATE,
        MIDDLE: ys.DOLLY,
        RIGHT: ys.PAN,
      }),
      (this.touches = { ONE: _s.ROTATE, TWO: _s.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return a.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return a.theta;
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }),
      (this.listenToKeyEvents = function (U) {
        U.addEventListener("keydown", Me), (this._domElementKeyEvents = U);
      }),
      (this.saveState = function () {
        i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object.zoom);
      }),
      (this.reset = function () {
        i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          (i.object.zoom = i.zoom0),
          i.object.updateProjectionMatrix(),
          i.dispatchEvent(j0),
          i.update(),
          (o = r.NONE);
      }),
      (this.update = (function () {
        const U = new Q(),
          te = new xi().setFromUnitVectors(e.up, new Q(0, 1, 0)),
          we = te.clone().invert(),
          Se = new Q(),
          Ee = new xi(),
          Le = 2 * Math.PI;
        return function () {
          const He = i.object.position;
          U.copy(He).sub(i.target),
            U.applyQuaternion(te),
            a.setFromVector3(U),
            i.autoRotate && o === r.NONE && P(T()),
            i.enableDamping
              ? ((a.theta += s.theta * i.dampingFactor),
                (a.phi += s.phi * i.dampingFactor))
              : ((a.theta += s.theta), (a.phi += s.phi));
          let We = i.minAzimuthAngle,
            it = i.maxAzimuthAngle;
          return (
            isFinite(We) &&
              isFinite(it) &&
              (We < -Math.PI ? (We += Le) : We > Math.PI && (We -= Le),
              it < -Math.PI ? (it += Le) : it > Math.PI && (it -= Le),
              We <= it
                ? (a.theta = Math.max(We, Math.min(it, a.theta)))
                : (a.theta =
                    a.theta > (We + it) / 2
                      ? Math.max(We, a.theta)
                      : Math.min(it, a.theta))),
            (a.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, a.phi)
            )),
            a.makeSafe(),
            (a.radius *= u),
            (a.radius = Math.max(
              i.minDistance,
              Math.min(i.maxDistance, a.radius)
            )),
            i.enableDamping === !0
              ? i.target.addScaledVector(d, i.dampingFactor)
              : i.target.add(d),
            U.setFromSpherical(a),
            U.applyQuaternion(we),
            He.copy(i.target).add(U),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((s.theta *= 1 - i.dampingFactor),
                (s.phi *= 1 - i.dampingFactor),
                d.multiplyScalar(1 - i.dampingFactor))
              : (s.set(0, 0, 0), d.set(0, 0, 0)),
            (u = 1),
            l ||
            Se.distanceToSquared(i.object.position) > p ||
            8 * (1 - Ee.dot(i.object.quaternion)) > p
              ? (i.dispatchEvent(j0),
                Se.copy(i.object.position),
                Ee.copy(i.object.quaternion),
                (l = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.dispose = function () {
        i.domElement.removeEventListener("contextmenu", ne),
          i.domElement.removeEventListener("pointerdown", K),
          i.domElement.removeEventListener("pointercancel", oe),
          i.domElement.removeEventListener("wheel", Re),
          i.domElement.removeEventListener("pointermove", ce),
          i.domElement.removeEventListener("pointerup", ue),
          i._domElementKeyEvents !== null &&
            i._domElementKeyEvents.removeEventListener("keydown", Me);
      });
    const i = this,
      r = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let o = r.NONE;
    const p = 1e-6,
      a = new U0(),
      s = new U0();
    let u = 1;
    const d = new Q();
    let l = !1;
    const c = new ze(),
      h = new ze(),
      m = new ze(),
      g = new ze(),
      f = new ze(),
      v = new ze(),
      y = new ze(),
      _ = new ze(),
      x = new ze(),
      b = [],
      S = {};
    function T() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
    }
    function w() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function P(U) {
      s.theta -= U;
    }
    function F(U) {
      s.phi -= U;
    }
    const V = (function () {
        const U = new Q();
        return function (we, Se) {
          U.setFromMatrixColumn(Se, 0), U.multiplyScalar(-we), d.add(U);
        };
      })(),
      J = (function () {
        const U = new Q();
        return function (we, Se) {
          i.screenSpacePanning === !0
            ? U.setFromMatrixColumn(Se, 1)
            : (U.setFromMatrixColumn(Se, 0), U.crossVectors(i.object.up, U)),
            U.multiplyScalar(we),
            d.add(U);
        };
      })(),
      z = (function () {
        const U = new Q();
        return function (we, Se) {
          const Ee = i.domElement;
          if (i.object.isPerspectiveCamera) {
            const Le = i.object.position;
            U.copy(Le).sub(i.target);
            let De = U.length();
            (De *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              V((2 * we * De) / Ee.clientHeight, i.object.matrix),
              J((2 * Se * De) / Ee.clientHeight, i.object.matrix);
          } else
            i.object.isOrthographicCamera
              ? (V(
                  (we * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    Ee.clientWidth,
                  i.object.matrix
                ),
                J(
                  (Se * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    Ee.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1));
        };
      })();
    function B(U) {
      i.object.isPerspectiveCamera
        ? (u /= U)
        : i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom * U)
          )),
          i.object.updateProjectionMatrix(),
          (l = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function G(U) {
      i.object.isPerspectiveCamera
        ? (u *= U)
        : i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom / U)
          )),
          i.object.updateProjectionMatrix(),
          (l = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function ie(U) {
      c.set(U.clientX, U.clientY);
    }
    function re(U) {
      y.set(U.clientX, U.clientY);
    }
    function j(U) {
      g.set(U.clientX, U.clientY);
    }
    function C(U) {
      h.set(U.clientX, U.clientY),
        m.subVectors(h, c).multiplyScalar(i.rotateSpeed);
      const te = i.domElement;
      P((2 * Math.PI * m.x) / te.clientHeight),
        F((2 * Math.PI * m.y) / te.clientHeight),
        c.copy(h),
        i.update();
    }
    function R(U) {
      _.set(U.clientX, U.clientY),
        x.subVectors(_, y),
        x.y > 0 ? B(w()) : x.y < 0 && G(w()),
        y.copy(_),
        i.update();
    }
    function A(U) {
      f.set(U.clientX, U.clientY),
        v.subVectors(f, g).multiplyScalar(i.panSpeed),
        z(v.x, v.y),
        g.copy(f),
        i.update();
    }
    function O(U) {
      U.deltaY < 0 ? G(w()) : U.deltaY > 0 && B(w()), i.update();
    }
    function H(U) {
      let te = !1;
      switch (U.code) {
        case i.keys.UP:
          U.ctrlKey || U.metaKey || U.shiftKey
            ? F((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : z(0, i.keyPanSpeed),
            (te = !0);
          break;
        case i.keys.BOTTOM:
          U.ctrlKey || U.metaKey || U.shiftKey
            ? F((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : z(0, -i.keyPanSpeed),
            (te = !0);
          break;
        case i.keys.LEFT:
          U.ctrlKey || U.metaKey || U.shiftKey
            ? P((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : z(i.keyPanSpeed, 0),
            (te = !0);
          break;
        case i.keys.RIGHT:
          U.ctrlKey || U.metaKey || U.shiftKey
            ? P((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : z(-i.keyPanSpeed, 0),
            (te = !0);
          break;
      }
      te && (U.preventDefault(), i.update());
    }
    function I() {
      if (b.length === 1) c.set(b[0].pageX, b[0].pageY);
      else {
        const U = 0.5 * (b[0].pageX + b[1].pageX),
          te = 0.5 * (b[0].pageY + b[1].pageY);
        c.set(U, te);
      }
    }
    function E() {
      if (b.length === 1) g.set(b[0].pageX, b[0].pageY);
      else {
        const U = 0.5 * (b[0].pageX + b[1].pageX),
          te = 0.5 * (b[0].pageY + b[1].pageY);
        g.set(U, te);
      }
    }
    function k() {
      const U = b[0].pageX - b[1].pageX,
        te = b[0].pageY - b[1].pageY,
        we = Math.sqrt(U * U + te * te);
      y.set(0, we);
    }
    function $() {
      i.enableZoom && k(), i.enablePan && E();
    }
    function Y() {
      i.enableZoom && k(), i.enableRotate && I();
    }
    function X(U) {
      if (b.length == 1) h.set(U.pageX, U.pageY);
      else {
        const we = Pe(U),
          Se = 0.5 * (U.pageX + we.x),
          Ee = 0.5 * (U.pageY + we.y);
        h.set(Se, Ee);
      }
      m.subVectors(h, c).multiplyScalar(i.rotateSpeed);
      const te = i.domElement;
      P((2 * Math.PI * m.x) / te.clientHeight),
        F((2 * Math.PI * m.y) / te.clientHeight),
        c.copy(h);
    }
    function ee(U) {
      if (b.length === 1) f.set(U.pageX, U.pageY);
      else {
        const te = Pe(U),
          we = 0.5 * (U.pageX + te.x),
          Se = 0.5 * (U.pageY + te.y);
        f.set(we, Se);
      }
      v.subVectors(f, g).multiplyScalar(i.panSpeed), z(v.x, v.y), g.copy(f);
    }
    function he(U) {
      const te = Pe(U),
        we = U.pageX - te.x,
        Se = U.pageY - te.y,
        Ee = Math.sqrt(we * we + Se * Se);
      _.set(0, Ee),
        x.set(0, Math.pow(_.y / y.y, i.zoomSpeed)),
        B(x.y),
        y.copy(_);
    }
    function pe(U) {
      i.enableZoom && he(U), i.enablePan && ee(U);
    }
    function Z(U) {
      i.enableZoom && he(U), i.enableRotate && X(U);
    }
    function K(U) {
      i.enabled !== !1 &&
        (b.length === 0 &&
          (i.domElement.setPointerCapture(U.pointerId),
          i.domElement.addEventListener("pointermove", ce),
          i.domElement.addEventListener("pointerup", ue)),
        de(U),
        U.pointerType === "touch" ? L(U) : le(U));
    }
    function ce(U) {
      i.enabled !== !1 && (U.pointerType === "touch" ? D(U) : ge(U));
    }
    function ue(U) {
      ye(U),
        b.length === 0 &&
          (i.domElement.releasePointerCapture(U.pointerId),
          i.domElement.removeEventListener("pointermove", ce),
          i.domElement.removeEventListener("pointerup", ue)),
        i.dispatchEvent(H0),
        (o = r.NONE);
    }
    function oe(U) {
      ye(U);
    }
    function le(U) {
      let te;
      switch (U.button) {
        case 0:
          te = i.mouseButtons.LEFT;
          break;
        case 1:
          te = i.mouseButtons.MIDDLE;
          break;
        case 2:
          te = i.mouseButtons.RIGHT;
          break;
        default:
          te = -1;
      }
      switch (te) {
        case ys.DOLLY:
          if (i.enableZoom === !1) return;
          re(U), (o = r.DOLLY);
          break;
        case ys.ROTATE:
          if (U.ctrlKey || U.metaKey || U.shiftKey) {
            if (i.enablePan === !1) return;
            j(U), (o = r.PAN);
          } else {
            if (i.enableRotate === !1) return;
            ie(U), (o = r.ROTATE);
          }
          break;
        case ys.PAN:
          if (U.ctrlKey || U.metaKey || U.shiftKey) {
            if (i.enableRotate === !1) return;
            ie(U), (o = r.ROTATE);
          } else {
            if (i.enablePan === !1) return;
            j(U), (o = r.PAN);
          }
          break;
        default:
          o = r.NONE;
      }
      o !== r.NONE && i.dispatchEvent(wf);
    }
    function ge(U) {
      switch (o) {
        case r.ROTATE:
          if (i.enableRotate === !1) return;
          C(U);
          break;
        case r.DOLLY:
          if (i.enableZoom === !1) return;
          R(U);
          break;
        case r.PAN:
          if (i.enablePan === !1) return;
          A(U);
          break;
      }
    }
    function Re(U) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        o !== r.NONE ||
        (U.preventDefault(), i.dispatchEvent(wf), O(U), i.dispatchEvent(H0));
    }
    function Me(U) {
      i.enabled === !1 || i.enablePan === !1 || H(U);
    }
    function L(U) {
      switch ((_e(U), b.length)) {
        case 1:
          switch (i.touches.ONE) {
            case _s.ROTATE:
              if (i.enableRotate === !1) return;
              I(), (o = r.TOUCH_ROTATE);
              break;
            case _s.PAN:
              if (i.enablePan === !1) return;
              E(), (o = r.TOUCH_PAN);
              break;
            default:
              o = r.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case _s.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              $(), (o = r.TOUCH_DOLLY_PAN);
              break;
            case _s.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              Y(), (o = r.TOUCH_DOLLY_ROTATE);
              break;
            default:
              o = r.NONE;
          }
          break;
        default:
          o = r.NONE;
      }
      o !== r.NONE && i.dispatchEvent(wf);
    }
    function D(U) {
      switch ((_e(U), o)) {
        case r.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          X(U), i.update();
          break;
        case r.TOUCH_PAN:
          if (i.enablePan === !1) return;
          ee(U), i.update();
          break;
        case r.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          pe(U), i.update();
          break;
        case r.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          Z(U), i.update();
          break;
        default:
          o = r.NONE;
      }
    }
    function ne(U) {
      i.enabled !== !1 && U.preventDefault();
    }
    function de(U) {
      b.push(U);
    }
    function ye(U) {
      delete S[U.pointerId];
      for (let te = 0; te < b.length; te++)
        if (b[te].pointerId == U.pointerId) {
          b.splice(te, 1);
          return;
        }
    }
    function _e(U) {
      let te = S[U.pointerId];
      te === void 0 && ((te = new ze()), (S[U.pointerId] = te)),
        te.set(U.pageX, U.pageY);
    }
    function Pe(U) {
      const te = U.pointerId === b[0].pointerId ? b[1] : b[0];
      return S[te.pointerId];
    }
    i.domElement.addEventListener("contextmenu", ne),
      i.domElement.addEventListener("pointerdown", K),
      i.domElement.addEventListener("pointercancel", oe),
      i.domElement.addEventListener("wheel", Re, { passive: !1 }),
      this.update();
  }
}
var Br = ((n) => (
    (n[(n.CREATED = 0)] = "CREATED"),
    (n[(n.MOUNTED = 1)] = "MOUNTED"),
    (n[(n.BEFORE_UPDATE = 2)] = "BEFORE_UPDATE"),
    (n[(n.UPDATED = 3)] = "UPDATED"),
    (n[(n.BEFORE_DESTROY = 4)] = "BEFORE_DESTROY"),
    (n[(n.DESTROYED = 5)] = "DESTROYED"),
    n
  ))(Br || {}),
  Xu = ((n) => ((n[(n.RENDER = 0)] = "RENDER"), (n[(n.ADD = 1)] = "ADD"), n))(
    Xu || {}
  );
class YO {
  constructor() {
    Fe(this, "sceneConfig");
    Fe(this, "lightConfig");
    Fe(this, "cameraConfig");
  }
}
class KO {
  constructor(e) {
    Fe(this, "el");
    Fe(this, "renderer");
    Fe(this, "state");
    Fe(this, "listeners");
    Fe(this, "scene", new aO());
    Fe(this, "lights");
    Fe(this, "camera");
    Fe(this, "meshes");
    Fe(this, "textures");
    Fe(this, "canvases");
    Fe(this, "loaders");
    Fe(this, "plugins");
    Fe(this, "controls");
    Fe(this, "emit", (e, ...t) => {
      e === Xu.RENDER && this.render();
    });
    Fe(this, "lifeCycleCallbacks", new Map());
    this.init(e);
  }
  init(e) {
    this.initState(e), this.initLights(), this.initCamera();
  }
  initState(e) {
    this.state = new Proxy(e, {});
  }
  initLights() {
    const e = new t1(16777215);
    e.position.set(400, 200, 300), this.scene.add(e);
    let t = new FO(10066329);
    this.scene.add(t);
  }
  initCamera() {
    (this.camera = new ln(45, 1, 1, 2e4)),
      this.camera.position.set(0, 0, 200),
      this.camera.lookAt(this.scene.position);
  }
  addLoaders(e) {
    return (
      (this.loaders = e.map((t) => new t(this.state, this.emit).init())), this
    );
  }
  addPlugins() {
    return this;
  }
  addControls() {
    return this;
  }
  onCreated(e) {
    return this.lifeCycleCallbacks.set(Br.CREATED, e), this;
  }
  onMounted(e) {
    return this.lifeCycleCallbacks.set(Br.MOUNTED, e), this;
  }
  onBeforeUpdate(e) {
    return this.lifeCycleCallbacks.set(Br.BEFORE_UPDATE, e), this;
  }
  onUpdated(e) {
    return this.lifeCycleCallbacks.set(Br.UPDATED, e), this;
  }
  onBeforeDestroy(e) {
    return this.lifeCycleCallbacks.set(Br.BEFORE_DESTROY, e), this;
  }
  onDestroyed(e) {
    return this.lifeCycleCallbacks.set(Br.DESTROYED, e), this;
  }
  async load(e, t) {
    const i = this.loaders.find((p) => p.format === e.format),
      { meshes: r, meshTextures: o } = await i.load(e, this.scene, t);
    return this.render(), { meshes: r, meshTextures: o };
  }
  mount(e, { width: t, height: i }) {
    typeof e == "string"
      ? (this.el = document.getElementById(e))
      : (this.el = e),
      (this.renderer = new qb({ canvas: this.el, antialias: !0 })),
      this.renderer.setSize(t, i),
      this.renderer.setClearColor("#f6f6f6", 1),
      new XO(this.camera, this.renderer.domElement).addEventListener(
        "change",
        this.render.bind(this)
      ),
      this.render();
  }
  render() {
    this.renderer.render(this.scene, this.camera);
  }
  destroy() {}
}
const Tf = new WeakMap();
class qO extends ps {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, i, r) {
    const o = new hl(this.manager);
    o.setPath(this.path),
      o.setResponseType("arraybuffer"),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        (p) => {
          this.decodeDracoFile(p, t).catch(r);
        },
        i,
        r
      );
  }
  decodeDracoFile(e, t, i, r) {
    const o = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: r || this.defaultAttributeTypes,
      useUniqueIDs: !!i,
    };
    return this.decodeGeometry(e, o).then(t);
  }
  decodeGeometry(e, t) {
    const i = JSON.stringify(t);
    if (Tf.has(e)) {
      const s = Tf.get(e);
      if (s.key === i) return s.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let r;
    const o = this.workerNextTaskID++,
      p = e.byteLength,
      a = this._getWorker(o, p)
        .then(
          (s) => (
            (r = s),
            new Promise((u, d) => {
              (r._callbacks[o] = { resolve: u, reject: d }),
                r.postMessage(
                  { type: "decode", id: o, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((s) => this._createGeometry(s.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          r && o && this._releaseTask(r, o);
        }),
      Tf.set(e, { key: i, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new Rn();
    e.index && t.setIndex(new Gt(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const r = e.attributes[i],
        o = r.name,
        p = r.array,
        a = r.itemSize;
      t.setAttribute(o, new Gt(p, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const i = new hl(this.manager);
    return (
      i.setPath(this.decoderPath),
      i.setResponseType(t),
      i.setWithCredentials(this.withCredentials),
      new Promise((r, o) => {
        i.load(e, r, void 0, o);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((i) => {
        const r = i[0];
        e || (this.decoderConfig.wasmBinary = i[1]);
        const o = ZO.toString(),
          p = [
            "/* draco decoder */",
            r,
            "",
            "/* worker */",
            o.substring(o.indexOf("{") + 1, o.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([p]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        (r._callbacks = {}),
          (r._taskCosts = {}),
          (r._taskLoad = 0),
          r.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (r.onmessage = function (o) {
            const p = o.data;
            switch (p.type) {
              case "decode":
                r._callbacks[p.id].resolve(p);
                break;
              case "error":
                r._callbacks[p.id].reject(p);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + p.type + '"'
                );
            }
          }),
          this.workerPool.push(r);
      } else
        this.workerPool.sort(function (r, o) {
          return r._taskLoad > o._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return (i._taskCosts[e] = t), (i._taskLoad += t), i;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function ZO() {
  let n, e;
  onmessage = function (p) {
    const a = p.data;
    switch (a.type) {
      case "init":
        (n = a.decoderConfig),
          (e = new Promise(function (d) {
            (n.onModuleLoaded = function (l) {
              d({ draco: l });
            }),
              DracoDecoderModule(n);
          }));
        break;
      case "decode":
        const s = a.buffer,
          u = a.taskConfig;
        e.then((d) => {
          const l = d.draco,
            c = new l.Decoder(),
            h = new l.DecoderBuffer();
          h.Init(new Int8Array(s), s.byteLength);
          try {
            const m = t(l, c, h, u),
              g = m.attributes.map((f) => f.array.buffer);
            m.index && g.push(m.index.array.buffer),
              self.postMessage({ type: "decode", id: a.id, geometry: m }, g);
          } catch (m) {
            console.error(m),
              self.postMessage({ type: "error", id: a.id, error: m.message });
          } finally {
            l.destroy(h), l.destroy(c);
          }
        });
        break;
    }
  };
  function t(p, a, s, u) {
    const d = u.attributeIDs,
      l = u.attributeTypes;
    let c, h;
    const m = a.GetEncodedGeometryType(s);
    if (m === p.TRIANGULAR_MESH)
      (c = new p.Mesh()), (h = a.DecodeBufferToMesh(s, c));
    else if (m === p.POINT_CLOUD)
      (c = new p.PointCloud()), (h = a.DecodeBufferToPointCloud(s, c));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!h.ok() || c.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + h.error_msg());
    const g = { index: null, attributes: [] };
    for (const f in d) {
      const v = self[l[f]];
      let y, _;
      if (u.useUniqueIDs) (_ = d[f]), (y = a.GetAttributeByUniqueId(c, _));
      else {
        if (((_ = a.GetAttributeId(c, p[d[f]])), _ === -1)) continue;
        y = a.GetAttribute(c, _);
      }
      g.attributes.push(r(p, a, c, f, v, y));
    }
    return m === p.TRIANGULAR_MESH && (g.index = i(p, a, c)), p.destroy(c), g;
  }
  function i(p, a, s) {
    const d = s.num_faces() * 3,
      l = d * 4,
      c = p._malloc(l);
    a.GetTrianglesUInt32Array(s, l, c);
    const h = new Uint32Array(p.HEAPF32.buffer, c, d).slice();
    return p._free(c), { array: h, itemSize: 1 };
  }
  function r(p, a, s, u, d, l) {
    const c = l.num_components(),
      m = s.num_points() * c,
      g = m * d.BYTES_PER_ELEMENT,
      f = o(p, d),
      v = p._malloc(g);
    a.GetAttributeDataArrayForAllPoints(s, l, f, g, v);
    const y = new d(p.HEAPF32.buffer, v, m).slice();
    return p._free(v), { name: u, array: y, itemSize: c };
  }
  function o(p, a) {
    switch (a) {
      case Float32Array:
        return p.DT_FLOAT32;
      case Int8Array:
        return p.DT_INT8;
      case Int16Array:
        return p.DT_INT16;
      case Int32Array:
        return p.DT_INT32;
      case Uint8Array:
        return p.DT_UINT8;
      case Uint16Array:
        return p.DT_UINT16;
      case Uint32Array:
        return p.DT_UINT32;
    }
  }
}
class JO extends ps {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new iL(t);
      }),
      this.register(function (t) {
        return new uL(t);
      }),
      this.register(function (t) {
        return new hL(t);
      }),
      this.register(function (t) {
        return new sL(t);
      }),
      this.register(function (t) {
        return new oL(t);
      }),
      this.register(function (t) {
        return new aL(t);
      }),
      this.register(function (t) {
        return new lL(t);
      }),
      this.register(function (t) {
        return new nL(t);
      }),
      this.register(function (t) {
        return new cL(t);
      }),
      this.register(function (t) {
        return new rL(t);
      }),
      this.register(function (t) {
        return new eL(t);
      }),
      this.register(function (t) {
        return new fL(t);
      }),
      this.register(function (t) {
        return new dL(t);
      });
  }
  load(e, t, i, r) {
    const o = this;
    let p;
    this.resourcePath !== ""
      ? (p = this.resourcePath)
      : this.path !== ""
      ? (p = this.path)
      : (p = Zr.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (u) {
        r ? r(u) : console.error(u),
          o.manager.itemError(e),
          o.manager.itemEnd(e);
      },
      s = new hl(this.manager);
    s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (u) {
          try {
            o.parse(
              u,
              p,
              function (d) {
                t(d), o.manager.itemEnd(e);
              },
              a
            );
          } catch (d) {
            a(d);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, r) {
    let o;
    const p = {},
      a = {};
    if (typeof e == "string") o = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Zr.decodeText(new Uint8Array(e, 0, 4)) === n1) {
        try {
          p[tt.KHR_BINARY_GLTF] = new pL(e);
        } catch (d) {
          r && r(d);
          return;
        }
        o = JSON.parse(p[tt.KHR_BINARY_GLTF].content);
      } else o = JSON.parse(Zr.decodeText(new Uint8Array(e)));
    else o = e;
    if (o.asset === void 0 || o.asset.version[0] < 2) {
      r &&
        r(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const s = new EL(o, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    s.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const d = this.pluginCallbacks[u](s);
      (a[d.name] = d), (p[d.name] = !0);
    }
    if (o.extensionsUsed)
      for (let u = 0; u < o.extensionsUsed.length; ++u) {
        const d = o.extensionsUsed[u],
          l = o.extensionsRequired || [];
        switch (d) {
          case tt.KHR_MATERIALS_UNLIT:
            p[d] = new tL();
            break;
          case tt.KHR_DRACO_MESH_COMPRESSION:
            p[d] = new mL(o, this.dracoLoader);
            break;
          case tt.KHR_TEXTURE_TRANSFORM:
            p[d] = new gL();
            break;
          case tt.KHR_MESH_QUANTIZATION:
            p[d] = new vL();
            break;
          default:
            l.indexOf(d) >= 0 &&
              a[d] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".');
        }
      }
    s.setExtensions(p), s.setPlugins(a), s.parse(i, r);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (r, o) {
      i.parse(e, t, r, o);
    });
  }
}
function QO() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const tt = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class eL {
  constructor(e) {
    (this.parser = e),
      (this.name = tt.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      o.extensions &&
        o.extensions[this.name] &&
        o.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, o.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let r = t.cache.get(i);
    if (r) return r;
    const o = t.json,
      s = (((o.extensions && o.extensions[this.name]) || {}).lights || [])[e];
    let u;
    const d = new je(16777215);
    s.color !== void 0 && d.fromArray(s.color);
    const l = s.range !== void 0 ? s.range : 0;
    switch (s.type) {
      case "directional":
        (u = new kO(d)), u.target.position.set(0, 0, -1), u.add(u.target);
        break;
      case "point":
        (u = new t1(d)), (u.distance = l);
        break;
      case "spot":
        (u = new DO(d)),
          (u.distance = l),
          (s.spot = s.spot || {}),
          (s.spot.innerConeAngle =
            s.spot.innerConeAngle !== void 0 ? s.spot.innerConeAngle : 0),
          (s.spot.outerConeAngle =
            s.spot.outerConeAngle !== void 0
              ? s.spot.outerConeAngle
              : Math.PI / 4),
          (u.angle = s.spot.outerConeAngle),
          (u.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle),
          u.target.position.set(0, 0, -1),
          u.add(u.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type);
    }
    return (
      u.position.set(0, 0, 0),
      (u.decay = 2),
      er(u, s),
      s.intensity !== void 0 && (u.intensity = s.intensity),
      (u.name = t.createUniqueName(s.name || "light_" + e)),
      (r = Promise.resolve(u)),
      t.cache.add(i, r),
      r
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      o = i.json.nodes[e],
      a = ((o.extensions && o.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (s) {
          return i._getNodeRef(t.cache, a, s);
        });
  }
}
class tL {
  constructor() {
    this.name = tt.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Gr;
  }
  extendParams(e, t, i) {
    const r = [];
    (e.color = new je(1, 1, 1)), (e.opacity = 1);
    const o = t.pbrMetallicRoughness;
    if (o) {
      if (Array.isArray(o.baseColorFactor)) {
        const p = o.baseColorFactor;
        e.color.fromArray(p), (e.opacity = p[3]);
      }
      o.baseColorTexture !== void 0 &&
        r.push(i.assignTexture(e, "map", o.baseColorTexture, ot));
    }
    return Promise.all(r);
  }
}
class nL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const o = r.extensions[this.name].emissiveStrength;
    return o !== void 0 && (t.emissiveIntensity = o), Promise.resolve();
  }
}
class iL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : ds;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const o = [],
      p = r.extensions[this.name];
    if (
      (p.clearcoatFactor !== void 0 && (t.clearcoat = p.clearcoatFactor),
      p.clearcoatTexture !== void 0 &&
        o.push(i.assignTexture(t, "clearcoatMap", p.clearcoatTexture)),
      p.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = p.clearcoatRoughnessFactor),
      p.clearcoatRoughnessTexture !== void 0 &&
        o.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            p.clearcoatRoughnessTexture
          )
        ),
      p.clearcoatNormalTexture !== void 0 &&
        (o.push(
          i.assignTexture(t, "clearcoatNormalMap", p.clearcoatNormalTexture)
        ),
        p.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = p.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ze(a, a);
    }
    return Promise.all(o);
  }
}
class rL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : ds;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const o = [],
      p = r.extensions[this.name];
    return (
      p.iridescenceFactor !== void 0 && (t.iridescence = p.iridescenceFactor),
      p.iridescenceTexture !== void 0 &&
        o.push(i.assignTexture(t, "iridescenceMap", p.iridescenceTexture)),
      p.iridescenceIor !== void 0 && (t.iridescenceIOR = p.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      p.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = p.iridescenceThicknessMinimum),
      p.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = p.iridescenceThicknessMaximum),
      p.iridescenceThicknessTexture !== void 0 &&
        o.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            p.iridescenceThicknessTexture
          )
        ),
      Promise.all(o)
    );
  }
}
class sL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : ds;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const o = [];
    (t.sheenColor = new je(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const p = r.extensions[this.name];
    return (
      p.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(p.sheenColorFactor),
      p.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = p.sheenRoughnessFactor),
      p.sheenColorTexture !== void 0 &&
        o.push(i.assignTexture(t, "sheenColorMap", p.sheenColorTexture, ot)),
      p.sheenRoughnessTexture !== void 0 &&
        o.push(
          i.assignTexture(t, "sheenRoughnessMap", p.sheenRoughnessTexture)
        ),
      Promise.all(o)
    );
  }
}
class oL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : ds;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const o = [],
      p = r.extensions[this.name];
    return (
      p.transmissionFactor !== void 0 &&
        (t.transmission = p.transmissionFactor),
      p.transmissionTexture !== void 0 &&
        o.push(i.assignTexture(t, "transmissionMap", p.transmissionTexture)),
      Promise.all(o)
    );
  }
}
class aL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : ds;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const o = [],
      p = r.extensions[this.name];
    (t.thickness = p.thicknessFactor !== void 0 ? p.thicknessFactor : 0),
      p.thicknessTexture !== void 0 &&
        o.push(i.assignTexture(t, "thicknessMap", p.thicknessTexture)),
      (t.attenuationDistance = p.attenuationDistance || 1 / 0);
    const a = p.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new je(a[0], a[1], a[2])), Promise.all(o);
  }
}
class lL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : ds;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const o = r.extensions[this.name];
    return (t.ior = o.ior !== void 0 ? o.ior : 1.5), Promise.resolve();
  }
}
class cL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : ds;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const o = [],
      p = r.extensions[this.name];
    (t.specularIntensity = p.specularFactor !== void 0 ? p.specularFactor : 1),
      p.specularTexture !== void 0 &&
        o.push(i.assignTexture(t, "specularIntensityMap", p.specularTexture));
    const a = p.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new je(a[0], a[1], a[2])),
      p.specularColorTexture !== void 0 &&
        o.push(
          i.assignTexture(t, "specularColorMap", p.specularColorTexture, ot)
        ),
      Promise.all(o)
    );
  }
}
class uL {
  constructor(e) {
    (this.parser = e), (this.name = tt.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name]) return null;
    const o = r.extensions[this.name],
      p = t.options.ktx2Loader;
    if (!p) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, o.source, p);
  }
}
class hL {
  constructor(e) {
    (this.parser = e),
      (this.name = tt.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      o = r.textures[e];
    if (!o.extensions || !o.extensions[t]) return null;
    const p = o.extensions[t],
      a = r.images[p.source];
    let s = i.textureLoader;
    if (a.uri) {
      const u = i.options.manager.getHandler(a.uri);
      u !== null && (s = u);
    }
    return this.detectSupport().then(function (u) {
      if (u) return i.loadTextureImage(e, p.source, s);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class fL {
  constructor(e) {
    (this.name = tt.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        o = this.parser.getDependency("buffer", r.buffer),
        p = this.parser.options.meshoptDecoder;
      if (!p || !p.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return o.then(function (a) {
        const s = r.byteOffset || 0,
          u = r.byteLength || 0,
          d = r.count,
          l = r.byteStride,
          c = new Uint8Array(a, s, u);
        return p.decodeGltfBufferAsync
          ? p
              .decodeGltfBufferAsync(d, l, c, r.mode, r.filter)
              .then(function (h) {
                return h.buffer;
              })
          : p.ready.then(function () {
              const h = new ArrayBuffer(d * l);
              return (
                p.decodeGltfBuffer(
                  new Uint8Array(h),
                  d,
                  l,
                  c,
                  r.mode,
                  r.filter
                ),
                h
              );
            });
      });
    } else return null;
  }
}
class dL {
  constructor(e) {
    (this.name = tt.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const r = t.meshes[i.mesh];
    for (const u of r.primitives)
      if (
        u.mode !== Un.TRIANGLES &&
        u.mode !== Un.TRIANGLE_STRIP &&
        u.mode !== Un.TRIANGLE_FAN &&
        u.mode !== void 0
      )
        return null;
    const p = i.extensions[this.name].attributes,
      a = [],
      s = {};
    for (const u in p)
      a.push(
        this.parser
          .getDependency("accessor", p[u])
          .then((d) => ((s[u] = d), s[u]))
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((u) => {
          const d = u.pop(),
            l = d.isGroup ? d.children : [d],
            c = u[0].count,
            h = [];
          for (const m of l) {
            const g = new Xe(),
              f = new Q(),
              v = new xi(),
              y = new Q(1, 1, 1),
              _ = new pO(m.geometry, m.material, c);
            for (let x = 0; x < c; x++)
              s.TRANSLATION && f.fromBufferAttribute(s.TRANSLATION, x),
                s.ROTATION && v.fromBufferAttribute(s.ROTATION, x),
                s.SCALE && y.fromBufferAttribute(s.SCALE, x),
                _.setMatrixAt(x, g.compose(f, v, y));
            for (const x in s)
              x !== "TRANSLATION" &&
                x !== "ROTATION" &&
                x !== "SCALE" &&
                m.geometry.setAttribute(x, s[x]);
            St.prototype.copy.call(_, m),
              (_.frustumCulled = !1),
              this.parser.assignFinalMaterial(_),
              h.push(_);
          }
          return d.isGroup ? (d.clear(), d.add(...h), d) : h[0];
        }));
  }
}
const n1 = "glTF",
  da = 12,
  V0 = { JSON: 1313821514, BIN: 5130562 };
class pL {
  constructor(e) {
    (this.name = tt.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, da);
    if (
      ((this.header = {
        magic: Zr.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== n1)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - da,
      r = new DataView(e, da);
    let o = 0;
    for (; o < i; ) {
      const p = r.getUint32(o, !0);
      o += 4;
      const a = r.getUint32(o, !0);
      if (((o += 4), a === V0.JSON)) {
        const s = new Uint8Array(e, da + o, p);
        this.content = Zr.decodeText(s);
      } else if (a === V0.BIN) {
        const s = da + o;
        this.body = e.slice(s, s + p);
      }
      o += p;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class mL {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = tt.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json,
      r = this.dracoLoader,
      o = e.extensions[this.name].bufferView,
      p = e.extensions[this.name].attributes,
      a = {},
      s = {},
      u = {};
    for (const d in p) {
      const l = Xd[d] || d.toLowerCase();
      a[l] = p[d];
    }
    for (const d in e.attributes) {
      const l = Xd[d] || d.toLowerCase();
      if (p[d] !== void 0) {
        const c = i.accessors[e.attributes[d]],
          h = oo[c.componentType];
        (u[l] = h.name), (s[l] = c.normalized === !0);
      }
    }
    return t.getDependency("bufferView", o).then(function (d) {
      return new Promise(function (l) {
        r.decodeDracoFile(
          d,
          function (c) {
            for (const h in c.attributes) {
              const m = c.attributes[h],
                g = s[h];
              g !== void 0 && (m.normalized = g);
            }
            l(c);
          },
          a,
          u
        );
      });
    });
  }
}
class gL {
  constructor() {
    this.name = tt.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      t.texCoord !== void 0 &&
        console.warn(
          'THREE.GLTFLoader: Custom UV sets in "' +
            this.name +
            '" extension not yet supported.'
        ),
      (t.offset === void 0 && t.rotation === void 0 && t.scale === void 0) ||
        ((e = e.clone()),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class vL {
  constructor() {
    this.name = tt.KHR_MESH_QUANTIZATION;
  }
}
class i1 extends wl {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      o = e * r * 3 + r;
    for (let p = 0; p !== r; p++) t[p] = i[o + p];
    return t;
  }
  interpolate_(e, t, i, r) {
    const o = this.resultBuffer,
      p = this.sampleValues,
      a = this.valueSize,
      s = a * 2,
      u = a * 3,
      d = r - t,
      l = (i - t) / d,
      c = l * l,
      h = c * l,
      m = e * u,
      g = m - u,
      f = -2 * h + 3 * c,
      v = h - c,
      y = 1 - f,
      _ = v - c + l;
    for (let x = 0; x !== a; x++) {
      const b = p[g + x + a],
        S = p[g + x + s] * d,
        T = p[m + x + a],
        w = p[m + x] * d;
      o[x] = y * b + _ * S + f * T + v * w;
    }
    return o;
  }
}
const yL = new xi();
class _L extends i1 {
  interpolate_(e, t, i, r) {
    const o = super.interpolate_(e, t, i, r);
    return yL.fromArray(o).normalize().toArray(o), o;
  }
}
const Un = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  oo = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  W0 = { 9728: zt, 9729: mn, 9984: Ud, 9985: Ob, 9986: jc, 9987: rs },
  G0 = { 33071: Vn, 33648: _u, 10497: xo },
  Cf = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  Xd = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  Zi = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  xL = { CUBICSPLINE: void 0, LINEAR: So, STEP: sl },
  Mf = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function bL(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new fm({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: _r,
      })),
    n.DefaultMaterial
  );
}
function pa(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function er(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function SL(n, e, t) {
  let i = !1,
    r = !1,
    o = !1;
  for (let u = 0, d = e.length; u < d; u++) {
    const l = e[u];
    if (
      (l.POSITION !== void 0 && (i = !0),
      l.NORMAL !== void 0 && (r = !0),
      l.COLOR_0 !== void 0 && (o = !0),
      i && r && o)
    )
      break;
  }
  if (!i && !r && !o) return Promise.resolve(n);
  const p = [],
    a = [],
    s = [];
  for (let u = 0, d = e.length; u < d; u++) {
    const l = e[u];
    if (i) {
      const c =
        l.POSITION !== void 0
          ? t.getDependency("accessor", l.POSITION)
          : n.attributes.position;
      p.push(c);
    }
    if (r) {
      const c =
        l.NORMAL !== void 0
          ? t.getDependency("accessor", l.NORMAL)
          : n.attributes.normal;
      a.push(c);
    }
    if (o) {
      const c =
        l.COLOR_0 !== void 0
          ? t.getDependency("accessor", l.COLOR_0)
          : n.attributes.color;
      s.push(c);
    }
  }
  return Promise.all([Promise.all(p), Promise.all(a), Promise.all(s)]).then(
    function (u) {
      const d = u[0],
        l = u[1],
        c = u[2];
      return (
        i && (n.morphAttributes.position = d),
        r && (n.morphAttributes.normal = l),
        o && (n.morphAttributes.color = c),
        (n.morphTargetsRelative = !0),
        n
      );
    }
  );
}
function wL(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let i = 0, r = t.length; i < r; i++)
        n.morphTargetDictionary[t[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function TL(n) {
  const e = n.extensions && n.extensions[tt.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return (
    e
      ? (t = "draco:" + e.bufferView + ":" + e.indices + ":" + $0(e.attributes))
      : (t = n.indices + ":" + $0(n.attributes) + ":" + n.mode),
    t
  );
}
function $0(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
  return e;
}
function Yd(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function CL(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const ML = new Xe();
class EL {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new QO()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      r = !1,
      o = -1;
    typeof navigator < "u" &&
      ((i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (r = navigator.userAgent.indexOf("Firefox") > -1),
      (o = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || i || (r && o < 98)
        ? (this.textureLoader = new OO(this.options.manager))
        : (this.textureLoader = new NO(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new hl(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      r = this.json,
      o = this.extensions;
    this.cache.removeAll(),
      this._invokeAll(function (p) {
        return p._markDefs && p._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (p) {
          return p.beforeRoot && p.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (p) {
          const a = {
            scene: p[0][r.scene || 0],
            scenes: p[0],
            animations: p[1],
            cameras: p[2],
            asset: r.asset,
            parser: i,
            userData: {},
          };
          pa(o, a, r),
            er(a, r),
            Promise.all(
              i._invokeAll(function (s) {
                return s.afterRoot && s.afterRoot(a);
              })
            ).then(function () {
              e(a);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let r = 0, o = t.length; r < o; r++) {
      const p = t[r].joints;
      for (let a = 0, s = p.length; a < s; a++) e[p[a]].isBone = !0;
    }
    for (let r = 0, o = e.length; r < o; r++) {
      const p = e[r];
      p.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, p.mesh),
        p.skin !== void 0 && (i[p.mesh].isSkinnedMesh = !0)),
        p.camera !== void 0 && this._addNodeRef(this.cameraCache, p.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const r = i.clone(),
      o = (p, a) => {
        const s = this.associations.get(p);
        s != null && this.associations.set(a, s);
        for (const [u, d] of p.children.entries()) o(d, a.children[u]);
      };
    return o(i, r), (r.name += "_instance_" + e.uses[t]++), r;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      if (r) return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const o = e(t[r]);
      o && i.push(o);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this._invokeOne(function (o) {
            return o.loadNode && o.loadNode(t);
          });
          break;
        case "mesh":
          r = this._invokeOne(function (o) {
            return o.loadMesh && o.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function (o) {
            return o.loadBufferView && o.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function (o) {
            return o.loadMaterial && o.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function (o) {
            return o.loadTexture && o.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function (o) {
            return o.loadAnimation && o.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          if (
            ((r = this._invokeOne(function (o) {
              return o != this && o.getDependency && o.getDependency(e, t);
            })),
            !r)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        r.map(function (o, p) {
          return i.getDependency(e, p);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[tt.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function (o, p) {
      i.load(Zr.resolveURL(t.uri, r.path), o, void 0, function () {
        p(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (i) {
      const r = t.byteLength || 0,
        o = t.byteOffset || 0;
      return i.slice(o, o + r);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const p = Cf[r.type],
        a = oo[r.componentType],
        s = r.normalized === !0,
        u = new a(r.count * p);
      return Promise.resolve(new Gt(u, p, s));
    }
    const o = [];
    return (
      r.bufferView !== void 0
        ? o.push(this.getDependency("bufferView", r.bufferView))
        : o.push(null),
      r.sparse !== void 0 &&
        (o.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        o.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
      Promise.all(o).then(function (p) {
        const a = p[0],
          s = Cf[r.type],
          u = oo[r.componentType],
          d = u.BYTES_PER_ELEMENT,
          l = d * s,
          c = r.byteOffset || 0,
          h =
            r.bufferView !== void 0
              ? i.bufferViews[r.bufferView].byteStride
              : void 0,
          m = r.normalized === !0;
        let g, f;
        if (h && h !== l) {
          const v = Math.floor(c / h),
            y =
              "InterleavedBuffer:" +
              r.bufferView +
              ":" +
              r.componentType +
              ":" +
              v +
              ":" +
              r.count;
          let _ = t.cache.get(y);
          _ ||
            ((g = new u(a, v * h, (r.count * h) / d)),
            (_ = new lO(g, h / d)),
            t.cache.add(y, _)),
            (f = new cm(_, s, (c % h) / d, m));
        } else a === null ? (g = new u(r.count * s)) : (g = new u(a, c, r.count * s)), (f = new Gt(g, s, m));
        if (r.sparse !== void 0) {
          const v = Cf.SCALAR,
            y = oo[r.sparse.indices.componentType],
            _ = r.sparse.indices.byteOffset || 0,
            x = r.sparse.values.byteOffset || 0,
            b = new y(p[1], _, r.sparse.count * v),
            S = new u(p[2], x, r.sparse.count * s);
          a !== null && (f = new Gt(f.array.slice(), f.itemSize, f.normalized));
          for (let T = 0, w = b.length; T < w; T++) {
            const P = b[T];
            if (
              (f.setX(P, S[T * s]),
              s >= 2 && f.setY(P, S[T * s + 1]),
              s >= 3 && f.setZ(P, S[T * s + 2]),
              s >= 4 && f.setW(P, S[T * s + 3]),
              s >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return f;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      o = t.textures[e].source,
      p = t.images[o];
    let a = this.textureLoader;
    if (p.uri) {
      const s = i.manager.getHandler(p.uri);
      s !== null && (a = s);
    }
    return this.loadTextureImage(e, o, a);
  }
  loadTextureImage(e, t, i) {
    const r = this,
      o = this.json,
      p = o.textures[e],
      a = o.images[t],
      s = (a.uri || a.bufferView) + ":" + p.sampler;
    if (this.textureCache[s]) return this.textureCache[s];
    const u = this.loadImageSource(t, i)
      .then(function (d) {
        (d.flipY = !1), (d.name = p.name || a.name || "");
        const c = (o.samplers || {})[p.sampler] || {};
        return (
          (d.magFilter = W0[c.magFilter] || mn),
          (d.minFilter = W0[c.minFilter] || rs),
          (d.wrapS = G0[c.wrapS] || xo),
          (d.wrapT = G0[c.wrapT] || xo),
          r.associations.set(d, { textures: e }),
          d
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[s] = u), u;
  }
  loadImageSource(e, t) {
    const i = this,
      r = this.json,
      o = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((l) => l.clone());
    const p = r.images[e],
      a = self.URL || self.webkitURL;
    let s = p.uri || "",
      u = !1;
    if (p.bufferView !== void 0)
      s = i.getDependency("bufferView", p.bufferView).then(function (l) {
        u = !0;
        const c = new Blob([l], { type: p.mimeType });
        return (s = a.createObjectURL(c)), s;
      });
    else if (p.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const d = Promise.resolve(s)
      .then(function (l) {
        return new Promise(function (c, h) {
          let m = c;
          t.isImageBitmapLoader === !0 &&
            (m = function (g) {
              const f = new jt(g);
              (f.needsUpdate = !0), c(f);
            }),
            t.load(Zr.resolveURL(l, o.path), m, void 0, h);
        });
      })
      .then(function (l) {
        return (
          u === !0 && a.revokeObjectURL(s),
          (l.userData.mimeType = p.mimeType || CL(p.uri)),
          l
        );
      })
      .catch(function (l) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", s), l);
      });
    return (this.sourceCache[e] = d), d;
  }
  assignTexture(e, t, i, r) {
    const o = this;
    return this.getDependency("texture", i.index).then(function (p) {
      if (!p) return null;
      if (
        (i.texCoord !== void 0 &&
          i.texCoord != 0 &&
          !(t === "aoMap" && i.texCoord == 1) &&
          console.warn(
            "THREE.GLTFLoader: Custom UV set " +
              i.texCoord +
              " for texture " +
              t +
              " not yet supported."
          ),
        o.extensions[tt.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          i.extensions !== void 0
            ? i.extensions[tt.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const s = o.associations.get(p);
          (p = o.extensions[tt.KHR_TEXTURE_TRANSFORM].extendTexture(p, a)),
            o.associations.set(p, s);
        }
      }
      return r !== void 0 && (p.encoding = r), (e[t] = p), p;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const r = t.attributes.tangent === void 0,
      o = t.attributes.color !== void 0,
      p = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let s = this.cache.get(a);
      s ||
        ((s = new Ks()),
        Ln.prototype.copy.call(s, i),
        s.color.copy(i.color),
        (s.map = i.map),
        (s.sizeAttenuation = !1),
        this.cache.add(a, s)),
        (i = s);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let s = this.cache.get(a);
      s ||
        ((s = new Ba()),
        Ln.prototype.copy.call(s, i),
        s.color.copy(i.color),
        this.cache.add(a, s)),
        (i = s);
    }
    if (r || o || p) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      r && (a += "derivative-tangents:"),
        o && (a += "vertex-colors:"),
        p && (a += "flat-shading:");
      let s = this.cache.get(a);
      s ||
        ((s = i.clone()),
        o && (s.vertexColors = !0),
        p && (s.flatShading = !0),
        r &&
          (s.normalScale && (s.normalScale.y *= -1),
          s.clearcoatNormalScale && (s.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, s),
        this.associations.set(s, this.associations.get(i))),
        (i = s);
    }
    i.aoMap &&
      t.attributes.uv2 === void 0 &&
      t.attributes.uv !== void 0 &&
      t.setAttribute("uv2", t.attributes.uv),
      (e.material = i);
  }
  getMaterialType() {
    return fm;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      o = i.materials[e];
    let p;
    const a = {},
      s = o.extensions || {},
      u = [];
    if (s[tt.KHR_MATERIALS_UNLIT]) {
      const l = r[tt.KHR_MATERIALS_UNLIT];
      (p = l.getMaterialType()), u.push(l.extendParams(a, o, t));
    } else {
      const l = o.pbrMetallicRoughness || {};
      if (
        ((a.color = new je(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(l.baseColorFactor))
      ) {
        const c = l.baseColorFactor;
        a.color.fromArray(c), (a.opacity = c[3]);
      }
      l.baseColorTexture !== void 0 &&
        u.push(t.assignTexture(a, "map", l.baseColorTexture, ot)),
        (a.metalness = l.metallicFactor !== void 0 ? l.metallicFactor : 1),
        (a.roughness = l.roughnessFactor !== void 0 ? l.roughnessFactor : 1),
        l.metallicRoughnessTexture !== void 0 &&
          (u.push(
            t.assignTexture(a, "metalnessMap", l.metallicRoughnessTexture)
          ),
          u.push(
            t.assignTexture(a, "roughnessMap", l.metallicRoughnessTexture)
          )),
        (p = this._invokeOne(function (c) {
          return c.getMaterialType && c.getMaterialType(e);
        })),
        u.push(
          Promise.all(
            this._invokeAll(function (c) {
              return c.extendMaterialParams && c.extendMaterialParams(e, a);
            })
          )
        );
    }
    o.doubleSided === !0 && (a.side = Vu);
    const d = o.alphaMode || Mf.OPAQUE;
    if (
      (d === Mf.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          d === Mf.MASK &&
            (a.alphaTest = o.alphaCutoff !== void 0 ? o.alphaCutoff : 0.5)),
      o.normalTexture !== void 0 &&
        p !== Gr &&
        (u.push(t.assignTexture(a, "normalMap", o.normalTexture)),
        (a.normalScale = new ze(1, 1)),
        o.normalTexture.scale !== void 0))
    ) {
      const l = o.normalTexture.scale;
      a.normalScale.set(l, l);
    }
    return (
      o.occlusionTexture !== void 0 &&
        p !== Gr &&
        (u.push(t.assignTexture(a, "aoMap", o.occlusionTexture)),
        o.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = o.occlusionTexture.strength)),
      o.emissiveFactor !== void 0 &&
        p !== Gr &&
        (a.emissive = new je().fromArray(o.emissiveFactor)),
      o.emissiveTexture !== void 0 &&
        p !== Gr &&
        u.push(t.assignTexture(a, "emissiveMap", o.emissiveTexture, ot)),
      Promise.all(u).then(function () {
        const l = new p(a);
        return (
          o.name && (l.name = o.name),
          er(l, o),
          t.associations.set(l, { materials: e }),
          o.extensions && pa(r, l, o),
          l
        );
      })
    );
  }
  createUniqueName(e) {
    const t = at.sanitizeNodeName(e || "");
    let i = t;
    for (let r = 1; this.nodeNamesUsed[i]; ++r) i = t + "_" + r;
    return (this.nodeNamesUsed[i] = !0), i;
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      r = this.primitiveCache;
    function o(a) {
      return i[tt.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (s) {
          return X0(s, a, t);
        });
    }
    const p = [];
    for (let a = 0, s = e.length; a < s; a++) {
      const u = e[a],
        d = TL(u),
        l = r[d];
      if (l) p.push(l.promise);
      else {
        let c;
        u.extensions && u.extensions[tt.KHR_DRACO_MESH_COMPRESSION]
          ? (c = o(u))
          : (c = X0(new Rn(), u, t)),
          (r[d] = { primitive: u, promise: c }),
          p.push(c);
      }
    }
    return Promise.all(p);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      o = i.meshes[e],
      p = o.primitives,
      a = [];
    for (let s = 0, u = p.length; s < u; s++) {
      const d =
        p[s].material === void 0
          ? bL(this.cache)
          : this.getDependency("material", p[s].material);
      a.push(d);
    }
    return (
      a.push(t.loadGeometries(p)),
      Promise.all(a).then(function (s) {
        const u = s.slice(0, s.length - 1),
          d = s[s.length - 1],
          l = [];
        for (let h = 0, m = d.length; h < m; h++) {
          const g = d[h],
            f = p[h];
          let v;
          const y = u[h];
          if (
            f.mode === Un.TRIANGLES ||
            f.mode === Un.TRIANGLE_STRIP ||
            f.mode === Un.TRIANGLE_FAN ||
            f.mode === void 0
          )
            (v = o.isSkinnedMesh === !0 ? new uO(g, y) : new vn(g, y)),
              v.isSkinnedMesh === !0 &&
                !v.geometry.attributes.skinWeight.normalized &&
                v.normalizeSkinWeights(),
              f.mode === Un.TRIANGLE_STRIP
                ? (v.geometry = Y0(v.geometry, VC))
                : f.mode === Un.TRIANGLE_FAN &&
                  (v.geometry = Y0(v.geometry, Db));
          else if (f.mode === Un.LINES) v = new Gd(g, y);
          else if (f.mode === Un.LINE_STRIP) v = new hm(g, y);
          else if (f.mode === Un.LINE_LOOP) v = new mO(g, y);
          else if (f.mode === Un.POINTS) v = new Wc(g, y);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + f.mode
            );
          Object.keys(v.geometry.morphAttributes).length > 0 && wL(v, o),
            (v.name = t.createUniqueName(o.name || "mesh_" + e)),
            er(v, o),
            f.extensions && pa(r, v, f),
            t.assignFinalMaterial(v),
            l.push(v);
        }
        for (let h = 0, m = l.length; h < m; h++)
          t.associations.set(l[h], { meshes: e, primitives: h });
        if (l.length === 1) return l[0];
        const c = new ar();
        t.associations.set(c, { meshes: e });
        for (let h = 0, m = l.length; h < m; h++) c.add(l[h]);
        return c;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      r = i[i.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (t = new ln(
            aM.radToDeg(r.yfov),
            r.aspectRatio || 1,
            r.znear || 1,
            r.zfar || 2e6
          ))
        : i.type === "orthographic" &&
          (t = new am(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      er(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = [];
    for (let r = 0, o = t.joints.length; r < o; r++)
      i.push(this.getDependency("node", t.joints[r]));
    return (
      t.inverseBindMatrices !== void 0
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (r) {
        const o = r.pop(),
          p = r,
          a = [],
          s = [];
        for (let u = 0, d = p.length; u < d; u++) {
          const l = p[u];
          if (l) {
            a.push(l);
            const c = new Xe();
            o !== null && c.fromArray(o.array, u * 16), s.push(c);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[u]
            );
        }
        return new um(a, s);
      })
    );
  }
  loadAnimation(e) {
    const i = this.json.animations[e],
      r = [],
      o = [],
      p = [],
      a = [],
      s = [];
    for (let u = 0, d = i.channels.length; u < d; u++) {
      const l = i.channels[u],
        c = i.samplers[l.sampler],
        h = l.target,
        m = h.node,
        g = i.parameters !== void 0 ? i.parameters[c.input] : c.input,
        f = i.parameters !== void 0 ? i.parameters[c.output] : c.output;
      r.push(this.getDependency("node", m)),
        o.push(this.getDependency("accessor", g)),
        p.push(this.getDependency("accessor", f)),
        a.push(c),
        s.push(h);
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(o),
      Promise.all(p),
      Promise.all(a),
      Promise.all(s),
    ]).then(function (u) {
      const d = u[0],
        l = u[1],
        c = u[2],
        h = u[3],
        m = u[4],
        g = [];
      for (let v = 0, y = d.length; v < y; v++) {
        const _ = d[v],
          x = l[v],
          b = c[v],
          S = h[v],
          T = m[v];
        if (_ === void 0) continue;
        _.updateMatrix();
        let w;
        switch (Zi[T.path]) {
          case Zi.weights:
            w = cl;
            break;
          case Zi.rotation:
            w = cs;
            break;
          case Zi.position:
          case Zi.scale:
          default:
            w = ul;
            break;
        }
        const P = _.name ? _.name : _.uuid,
          F = S.interpolation !== void 0 ? xL[S.interpolation] : So,
          V = [];
        Zi[T.path] === Zi.weights
          ? _.traverse(function (z) {
              z.morphTargetInfluences && V.push(z.name ? z.name : z.uuid);
            })
          : V.push(P);
        let J = b.array;
        if (b.normalized) {
          const z = Yd(J.constructor),
            B = new Float32Array(J.length);
          for (let G = 0, ie = J.length; G < ie; G++) B[G] = J[G] * z;
          J = B;
        }
        for (let z = 0, B = V.length; z < B; z++) {
          const G = new w(V[z] + "." + Zi[T.path], x.array, J, F);
          S.interpolation === "CUBICSPLINE" &&
            ((G.createInterpolant = function (re) {
              const j = this instanceof cs ? _L : i1;
              return new j(
                this.times,
                this.values,
                this.getValueSize() / 3,
                re
              );
            }),
            (G.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            g.push(G);
        }
      }
      const f = i.name ? i.name : "animation_" + e;
      return new wO(f, void 0, g);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e];
    return r.mesh === void 0
      ? null
      : i.getDependency("mesh", r.mesh).then(function (o) {
          const p = i._getNodeRef(i.meshCache, r.mesh, o);
          return (
            r.weights !== void 0 &&
              p.traverse(function (a) {
                if (a.isMesh)
                  for (let s = 0, u = r.weights.length; s < u; s++)
                    a.morphTargetInfluences[s] = r.weights[s];
              }),
            p
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      i = this.extensions,
      r = this,
      o = t.nodes[e],
      p = o.name ? r.createUniqueName(o.name) : "";
    return (function () {
      const a = [],
        s = r._invokeOne(function (c) {
          return c.createNodeMesh && c.createNodeMesh(e);
        });
      s && a.push(s),
        o.camera !== void 0 &&
          a.push(
            r.getDependency("camera", o.camera).then(function (c) {
              return r._getNodeRef(r.cameraCache, o.camera, c);
            })
          ),
        r
          ._invokeAll(function (c) {
            return c.createNodeAttachment && c.createNodeAttachment(e);
          })
          .forEach(function (c) {
            a.push(c);
          });
      const u = [],
        d = o.children || [];
      for (let c = 0, h = d.length; c < h; c++)
        u.push(r.getDependency("node", d[c]));
      const l =
        o.skin === void 0
          ? Promise.resolve(null)
          : r.getDependency("skin", o.skin);
      return Promise.all([Promise.all(a), Promise.all(u), l]);
    })().then(function (a) {
      const s = a[0],
        u = a[1],
        d = a[2];
      let l;
      if (
        (o.isBone === !0
          ? (l = new Zb())
          : s.length > 1
          ? (l = new ar())
          : s.length === 1
          ? (l = s[0])
          : (l = new St()),
        l !== s[0])
      )
        for (let c = 0, h = s.length; c < h; c++) l.add(s[c]);
      if (
        (o.name && ((l.userData.name = o.name), (l.name = p)),
        er(l, o),
        o.extensions && pa(i, l, o),
        o.matrix !== void 0)
      ) {
        const c = new Xe();
        c.fromArray(o.matrix), l.applyMatrix4(c);
      } else o.translation !== void 0 && l.position.fromArray(o.translation), o.rotation !== void 0 && l.quaternion.fromArray(o.rotation), o.scale !== void 0 && l.scale.fromArray(o.scale);
      r.associations.has(l) || r.associations.set(l, {}),
        (r.associations.get(l).nodes = e),
        d !== null &&
          l.traverse(function (c) {
            c.isSkinnedMesh && c.bind(d, ML);
          });
      for (let c = 0, h = u.length; c < h; c++) l.add(u[c]);
      return l;
    });
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      r = this,
      o = new ar();
    i.name && (o.name = r.createUniqueName(i.name)),
      er(o, i),
      i.extensions && pa(t, o, i);
    const p = i.nodes || [],
      a = [];
    for (let s = 0, u = p.length; s < u; s++)
      a.push(r.getDependency("node", p[s]));
    return Promise.all(a).then(function (s) {
      for (let d = 0, l = s.length; d < l; d++) o.add(s[d]);
      const u = (d) => {
        const l = new Map();
        for (const [c, h] of r.associations)
          (c instanceof Ln || c instanceof jt) && l.set(c, h);
        return (
          d.traverse((c) => {
            const h = r.associations.get(c);
            h != null && l.set(c, h);
          }),
          l
        );
      };
      return (r.associations = u(o)), o;
    });
  }
}
function AL(n, e, t) {
  const i = e.attributes,
    r = new Do();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION],
      s = a.min,
      u = a.max;
    if (s !== void 0 && u !== void 0) {
      if (
        (r.set(new Q(s[0], s[1], s[2]), new Q(u[0], u[1], u[2])), a.normalized)
      ) {
        const d = Yd(oo[a.componentType]);
        r.min.multiplyScalar(d), r.max.multiplyScalar(d);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const o = e.targets;
  if (o !== void 0) {
    const a = new Q(),
      s = new Q();
    for (let u = 0, d = o.length; u < d; u++) {
      const l = o[u];
      if (l.POSITION !== void 0) {
        const c = t.json.accessors[l.POSITION],
          h = c.min,
          m = c.max;
        if (h !== void 0 && m !== void 0) {
          if (
            (s.setX(Math.max(Math.abs(h[0]), Math.abs(m[0]))),
            s.setY(Math.max(Math.abs(h[1]), Math.abs(m[1]))),
            s.setZ(Math.max(Math.abs(h[2]), Math.abs(m[2]))),
            c.normalized)
          ) {
            const g = Yd(oo[c.componentType]);
            s.multiplyScalar(g);
          }
          a.max(s);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    r.expandByVector(a);
  }
  n.boundingBox = r;
  const p = new Ro();
  r.getCenter(p.center),
    (p.radius = r.min.distanceTo(r.max) / 2),
    (n.boundingSphere = p);
}
function X0(n, e, t) {
  const i = e.attributes,
    r = [];
  function o(p, a) {
    return t.getDependency("accessor", p).then(function (s) {
      n.setAttribute(a, s);
    });
  }
  for (const p in i) {
    const a = Xd[p] || p.toLowerCase();
    a in n.attributes || r.push(o(i[p], a));
  }
  if (e.indices !== void 0 && !n.index) {
    const p = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    r.push(p);
  }
  return (
    er(n, e),
    AL(n, e, t),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? SL(n, e.targets, t) : n;
    })
  );
}
function Y0(n, e) {
  let t = n.getIndex();
  if (t === null) {
    const p = [],
      a = n.getAttribute("position");
    if (a !== void 0) {
      for (let s = 0; s < a.count; s++) p.push(s);
      n.setIndex(p), (t = n.getIndex());
    } else
      return (
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ),
        n
      );
  }
  const i = t.count - 2,
    r = [];
  if (e === Db)
    for (let p = 1; p <= i; p++)
      r.push(t.getX(0)), r.push(t.getX(p)), r.push(t.getX(p + 1));
  else
    for (let p = 0; p < i; p++)
      p % 2 === 0
        ? (r.push(t.getX(p)), r.push(t.getX(p + 1)), r.push(t.getX(p + 2)))
        : (r.push(t.getX(p + 2)), r.push(t.getX(p + 1)), r.push(t.getX(p)));
  r.length / 3 !== i &&
    console.error(
      "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
    );
  const o = n.clone();
  return o.setIndex(r), o;
}
const PL = /^[og]\s*(.+)?/,
  OL = /^mtllib /,
  LL = /^usemtl /,
  DL = /^usemap /,
  K0 = /\s+/,
  q0 = new Q(),
  Ef = new Q(),
  Z0 = new Q(),
  J0 = new Q(),
  zn = new Q(),
  Tc = new je();
function RL() {
  const n = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function (e, t) {
      if (this.object && this.object.fromDeclaration === !1) {
        (this.object.name = e), (this.object.fromDeclaration = t !== !1);
        return;
      }
      const i =
        this.object && typeof this.object.currentMaterial == "function"
          ? this.object.currentMaterial()
          : void 0;
      if (
        (this.object &&
          typeof this.object._finalize == "function" &&
          this.object._finalize(!0),
        (this.object = {
          name: e || "",
          fromDeclaration: t !== !1,
          geometry: {
            vertices: [],
            normals: [],
            colors: [],
            uvs: [],
            hasUVIndices: !1,
          },
          materials: [],
          smooth: !0,
          startMaterial: function (r, o) {
            const p = this._finalize(!1);
            p &&
              (p.inherited || p.groupCount <= 0) &&
              this.materials.splice(p.index, 1);
            const a = {
              index: this.materials.length,
              name: r || "",
              mtllib: Array.isArray(o) && o.length > 0 ? o[o.length - 1] : "",
              smooth: p !== void 0 ? p.smooth : this.smooth,
              groupStart: p !== void 0 ? p.groupEnd : 0,
              groupEnd: -1,
              groupCount: -1,
              inherited: !1,
              clone: function (s) {
                const u = {
                  index: typeof s == "number" ? s : this.index,
                  name: this.name,
                  mtllib: this.mtllib,
                  smooth: this.smooth,
                  groupStart: 0,
                  groupEnd: -1,
                  groupCount: -1,
                  inherited: !1,
                };
                return (u.clone = this.clone.bind(u)), u;
              },
            };
            return this.materials.push(a), a;
          },
          currentMaterial: function () {
            if (this.materials.length > 0)
              return this.materials[this.materials.length - 1];
          },
          _finalize: function (r) {
            const o = this.currentMaterial();
            if (
              (o &&
                o.groupEnd === -1 &&
                ((o.groupEnd = this.geometry.vertices.length / 3),
                (o.groupCount = o.groupEnd - o.groupStart),
                (o.inherited = !1)),
              r && this.materials.length > 1)
            )
              for (let p = this.materials.length - 1; p >= 0; p--)
                this.materials[p].groupCount <= 0 &&
                  this.materials.splice(p, 1);
            return (
              r &&
                this.materials.length === 0 &&
                this.materials.push({ name: "", smooth: this.smooth }),
              o
            );
          },
        }),
        i && i.name && typeof i.clone == "function")
      ) {
        const r = i.clone(0);
        (r.inherited = !0), this.object.materials.push(r);
      }
      this.objects.push(this.object);
    },
    finalize: function () {
      this.object &&
        typeof this.object._finalize == "function" &&
        this.object._finalize(!0);
    },
    parseVertexIndex: function (e, t) {
      const i = parseInt(e, 10);
      return (i >= 0 ? i - 1 : i + t / 3) * 3;
    },
    parseNormalIndex: function (e, t) {
      const i = parseInt(e, 10);
      return (i >= 0 ? i - 1 : i + t / 3) * 3;
    },
    parseUVIndex: function (e, t) {
      const i = parseInt(e, 10);
      return (i >= 0 ? i - 1 : i + t / 2) * 2;
    },
    addVertex: function (e, t, i) {
      const r = this.vertices,
        o = this.object.geometry.vertices;
      o.push(r[e + 0], r[e + 1], r[e + 2]),
        o.push(r[t + 0], r[t + 1], r[t + 2]),
        o.push(r[i + 0], r[i + 1], r[i + 2]);
    },
    addVertexPoint: function (e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addVertexLine: function (e) {
      const t = this.vertices;
      this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
    },
    addNormal: function (e, t, i) {
      const r = this.normals,
        o = this.object.geometry.normals;
      o.push(r[e + 0], r[e + 1], r[e + 2]),
        o.push(r[t + 0], r[t + 1], r[t + 2]),
        o.push(r[i + 0], r[i + 1], r[i + 2]);
    },
    addFaceNormal: function (e, t, i) {
      const r = this.vertices,
        o = this.object.geometry.normals;
      q0.fromArray(r, e),
        Ef.fromArray(r, t),
        Z0.fromArray(r, i),
        zn.subVectors(Z0, Ef),
        J0.subVectors(q0, Ef),
        zn.cross(J0),
        zn.normalize(),
        o.push(zn.x, zn.y, zn.z),
        o.push(zn.x, zn.y, zn.z),
        o.push(zn.x, zn.y, zn.z);
    },
    addColor: function (e, t, i) {
      const r = this.colors,
        o = this.object.geometry.colors;
      r[e] !== void 0 && o.push(r[e + 0], r[e + 1], r[e + 2]),
        r[t] !== void 0 && o.push(r[t + 0], r[t + 1], r[t + 2]),
        r[i] !== void 0 && o.push(r[i + 0], r[i + 1], r[i + 2]);
    },
    addUV: function (e, t, i) {
      const r = this.uvs,
        o = this.object.geometry.uvs;
      o.push(r[e + 0], r[e + 1]),
        o.push(r[t + 0], r[t + 1]),
        o.push(r[i + 0], r[i + 1]);
    },
    addDefaultUV: function () {
      const e = this.object.geometry.uvs;
      e.push(0, 0), e.push(0, 0), e.push(0, 0);
    },
    addUVLine: function (e) {
      const t = this.uvs;
      this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
    },
    addFace: function (e, t, i, r, o, p, a, s, u) {
      const d = this.vertices.length;
      let l = this.parseVertexIndex(e, d),
        c = this.parseVertexIndex(t, d),
        h = this.parseVertexIndex(i, d);
      if (
        (this.addVertex(l, c, h),
        this.addColor(l, c, h),
        a !== void 0 && a !== "")
      ) {
        const m = this.normals.length;
        (l = this.parseNormalIndex(a, m)),
          (c = this.parseNormalIndex(s, m)),
          (h = this.parseNormalIndex(u, m)),
          this.addNormal(l, c, h);
      } else this.addFaceNormal(l, c, h);
      if (r !== void 0 && r !== "") {
        const m = this.uvs.length;
        (l = this.parseUVIndex(r, m)),
          (c = this.parseUVIndex(o, m)),
          (h = this.parseUVIndex(p, m)),
          this.addUV(l, c, h),
          (this.object.geometry.hasUVIndices = !0);
      } else this.addDefaultUV();
    },
    addPointGeometry: function (e) {
      this.object.geometry.type = "Points";
      const t = this.vertices.length;
      for (let i = 0, r = e.length; i < r; i++) {
        const o = this.parseVertexIndex(e[i], t);
        this.addVertexPoint(o), this.addColor(o);
      }
    },
    addLineGeometry: function (e, t) {
      this.object.geometry.type = "Line";
      const i = this.vertices.length,
        r = this.uvs.length;
      for (let o = 0, p = e.length; o < p; o++)
        this.addVertexLine(this.parseVertexIndex(e[o], i));
      for (let o = 0, p = t.length; o < p; o++)
        this.addUVLine(this.parseUVIndex(t[o], r));
    },
  };
  return n.startObject("", !1), n;
}
class IL extends ps {
  constructor(e) {
    super(e), (this.materials = null);
  }
  load(e, t, i, r) {
    const o = this,
      p = new hl(this.manager);
    p.setPath(this.path),
      p.setRequestHeader(this.requestHeader),
      p.setWithCredentials(this.withCredentials),
      p.load(
        e,
        function (a) {
          try {
            t(o.parse(a));
          } catch (s) {
            r ? r(s) : console.error(s), o.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  setMaterials(e) {
    return (this.materials = e), this;
  }
  parse(e) {
    const t = new RL();
    e.indexOf(`\r
`) !== -1 &&
      (e = e.replace(
        /\r\n/g,
        `
`
      )),
      e.indexOf(`\\
`) !== -1 && (e = e.replace(/\\\n/g, ""));
    const i = e.split(`
`);
    let r = [];
    for (let a = 0, s = i.length; a < s; a++) {
      const u = i[a].trimStart();
      if (u.length === 0) continue;
      const d = u.charAt(0);
      if (d !== "#")
        if (d === "v") {
          const l = u.split(K0);
          switch (l[0]) {
            case "v":
              t.vertices.push(
                parseFloat(l[1]),
                parseFloat(l[2]),
                parseFloat(l[3])
              ),
                l.length >= 7
                  ? (Tc.setRGB(
                      parseFloat(l[4]),
                      parseFloat(l[5]),
                      parseFloat(l[6])
                    ).convertSRGBToLinear(),
                    t.colors.push(Tc.r, Tc.g, Tc.b))
                  : t.colors.push(void 0, void 0, void 0);
              break;
            case "vn":
              t.normals.push(
                parseFloat(l[1]),
                parseFloat(l[2]),
                parseFloat(l[3])
              );
              break;
            case "vt":
              t.uvs.push(parseFloat(l[1]), parseFloat(l[2]));
              break;
          }
        } else if (d === "f") {
          const c = u.slice(1).trim().split(K0),
            h = [];
          for (let g = 0, f = c.length; g < f; g++) {
            const v = c[g];
            if (v.length > 0) {
              const y = v.split("/");
              h.push(y);
            }
          }
          const m = h[0];
          for (let g = 1, f = h.length - 1; g < f; g++) {
            const v = h[g],
              y = h[g + 1];
            t.addFace(m[0], v[0], y[0], m[1], v[1], y[1], m[2], v[2], y[2]);
          }
        } else if (d === "l") {
          const l = u.substring(1).trim().split(" ");
          let c = [];
          const h = [];
          if (u.indexOf("/") === -1) c = l;
          else
            for (let m = 0, g = l.length; m < g; m++) {
              const f = l[m].split("/");
              f[0] !== "" && c.push(f[0]), f[1] !== "" && h.push(f[1]);
            }
          t.addLineGeometry(c, h);
        } else if (d === "p") {
          const c = u.slice(1).trim().split(" ");
          t.addPointGeometry(c);
        } else if ((r = PL.exec(u)) !== null) {
          const l = (" " + r[0].slice(1).trim()).slice(1);
          t.startObject(l);
        } else if (LL.test(u))
          t.object.startMaterial(u.substring(7).trim(), t.materialLibraries);
        else if (OL.test(u)) t.materialLibraries.push(u.substring(7).trim());
        else if (DL.test(u))
          console.warn(
            'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
          );
        else if (d === "s") {
          if (((r = u.split(" ")), r.length > 1)) {
            const c = r[1].trim().toLowerCase();
            t.object.smooth = c !== "0" && c !== "off";
          } else t.object.smooth = !0;
          const l = t.object.currentMaterial();
          l && (l.smooth = t.object.smooth);
        } else {
          if (u === "\0") continue;
          console.warn('THREE.OBJLoader: Unexpected line: "' + u + '"');
        }
    }
    t.finalize();
    const o = new ar();
    if (
      ((o.materialLibraries = [].concat(t.materialLibraries)),
      !(
        t.objects.length === 1 && t.objects[0].geometry.vertices.length === 0
      ) === !0)
    )
      for (let a = 0, s = t.objects.length; a < s; a++) {
        const u = t.objects[a],
          d = u.geometry,
          l = u.materials,
          c = d.type === "Line",
          h = d.type === "Points";
        let m = !1;
        if (d.vertices.length === 0) continue;
        const g = new Rn();
        g.setAttribute("position", new an(d.vertices, 3)),
          d.normals.length > 0 &&
            g.setAttribute("normal", new an(d.normals, 3)),
          d.colors.length > 0 &&
            ((m = !0), g.setAttribute("color", new an(d.colors, 3))),
          d.hasUVIndices === !0 && g.setAttribute("uv", new an(d.uvs, 2));
        const f = [];
        for (let y = 0, _ = l.length; y < _; y++) {
          const x = l[y],
            b = x.name + "_" + x.smooth + "_" + m;
          let S = t.materials[b];
          if (this.materials !== null) {
            if (
              ((S = this.materials.create(x.name)),
              c && S && !(S instanceof Ba))
            ) {
              const T = new Ba();
              Ln.prototype.copy.call(T, S), T.color.copy(S.color), (S = T);
            } else if (h && S && !(S instanceof Ks)) {
              const T = new Ks({ size: 10, sizeAttenuation: !1 });
              Ln.prototype.copy.call(T, S),
                T.color.copy(S.color),
                (T.map = S.map),
                (S = T);
            }
          }
          S === void 0 &&
            (c
              ? (S = new Ba())
              : h
              ? (S = new Ks({ size: 1, sizeAttenuation: !1 }))
              : (S = new vO()),
            (S.name = x.name),
            (S.flatShading = !x.smooth),
            (S.vertexColors = m),
            (t.materials[b] = S)),
            f.push(S);
        }
        let v;
        if (f.length > 1) {
          for (let y = 0, _ = l.length; y < _; y++) {
            const x = l[y];
            g.addGroup(x.groupStart, x.groupCount, y);
          }
          c ? (v = new Gd(g, f)) : h ? (v = new Wc(g, f)) : (v = new vn(g, f));
        } else
          c
            ? (v = new Gd(g, f[0]))
            : h
            ? (v = new Wc(g, f[0]))
            : (v = new vn(g, f[0]));
        (v.name = u.name), o.add(v);
      }
    else if (t.vertices.length > 0) {
      const a = new Ks({ size: 1, sizeAttenuation: !1 }),
        s = new Rn();
      s.setAttribute("position", new an(t.vertices, 3)),
        t.colors.length > 0 &&
          t.colors[0] !== void 0 &&
          (s.setAttribute("color", new an(t.colors, 3)), (a.vertexColors = !0));
      const u = new Wc(s, a);
      o.add(u);
    }
    return o;
  }
}
class kL {
  constructor({ mesh: e, textures: t, emit: i }) {
    Fe(this, "id");
    Fe(this, "mesh");
    Fe(this, "textures");
    Fe(this, "emit");
    (this.mesh = e),
      (this.id = e.uuid),
      (this.emit = i),
      (this.textures = t),
      this.textures.forEach((r) => r.bindMesh(this.id));
  }
  async setMeshTextures() {
    if (Array.isArray(this.mesh.material)) {
      const e = await Promise.all(this.textures.map((t, i) => t.getTexture()));
      this.mesh.material.forEach((t, i) => {
        this.textures[Math.min(i, this.textures.length - 1)].bindMaterial(i),
          (t.map = e[Math.min(i, this.textures.length - 1)]);
      });
    } else
      (this.mesh.material.map = await this.textures[0].getTexture()),
        this.textures[0].bindMaterial(0);
  }
}
var gm = {};
const FL = {},
  NL = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: FL },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Af = TS(NL);
(function (n) {
  /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */ var e =
    e || { version: "5.3.0" };
  if (((n.fabric = e), typeof document < "u" && typeof window < "u"))
    document instanceof (typeof HTMLDocument < "u" ? HTMLDocument : Document)
      ? (e.document = document)
      : (e.document = document.implementation.createHTMLDocument("")),
      (e.window = window);
  else {
    var t = Af,
      i = new t.JSDOM(
        decodeURIComponent(
          "%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"
        ),
        { features: { FetchExternalResources: ["img"] }, resources: "usable" }
      ).window;
    (e.document = i.document),
      (e.jsdomImplForWrapper = Af.implForWrapper),
      (e.nodeCanvas = Af.Canvas),
      (e.window = i),
      (DOMParser = e.window.DOMParser);
  }
  (e.isTouchSupported =
    "ontouchstart" in e.window ||
    "ontouchstart" in e.document ||
    (e.window && e.window.navigator && e.window.navigator.maxTouchPoints > 0)),
    (e.isLikelyNode = typeof Buffer < "u" && typeof window > "u"),
    (e.SHARED_ATTRIBUTES = [
      "display",
      "transform",
      "fill",
      "fill-opacity",
      "fill-rule",
      "opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-linecap",
      "stroke-dashoffset",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "id",
      "paint-order",
      "vector-effect",
      "instantiated_by_use",
      "clip-path",
    ]),
    (e.DPI = 96),
    (e.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)"),
    (e.commaWsp = "(?:\\s+,?\\s*|,\\s*)"),
    (e.rePathCommand =
      /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi),
    (e.reNonWord = /[ \n\.,;!\?\-]/),
    (e.fontPaths = {}),
    (e.iMatrix = [1, 0, 0, 1, 0, 0]),
    (e.svgNS = "http://www.w3.org/2000/svg"),
    (e.perfLimitSizeTotal = 2097152),
    (e.maxCacheSideLimit = 4096),
    (e.minCacheSideLimit = 256),
    (e.charWidthsCache = {}),
    (e.textureSize = 2048),
    (e.disableStyleCopyPaste = !1),
    (e.enableGLFiltering = !0),
    (e.devicePixelRatio =
      e.window.devicePixelRatio ||
      e.window.webkitDevicePixelRatio ||
      e.window.mozDevicePixelRatio ||
      1),
    (e.browserShadowBlurConstant = 1),
    (e.arcToSegmentsCache = {}),
    (e.boundsOfCurveCache = {}),
    (e.cachesBoundsOfCurve = !0),
    (e.forceGLPutImageData = !1),
    (e.initFilterBackend = function () {
      if (
        e.enableGLFiltering &&
        e.isWebglSupported &&
        e.isWebglSupported(e.textureSize)
      )
        return (
          console.log("max texture size: " + e.maxTextureSize),
          new e.WebglFilterBackend({ tileSize: e.textureSize })
        );
      if (e.Canvas2dFilterBackend) return new e.Canvas2dFilterBackend();
    }),
    typeof document < "u" && typeof window < "u" && (window.fabric = e),
    (function () {
      function a(h, m) {
        if (this.__eventListeners[h]) {
          var g = this.__eventListeners[h];
          m ? (g[g.indexOf(m)] = !1) : e.util.array.fill(g, !1);
        }
      }
      function s(h, m) {
        if (
          (this.__eventListeners || (this.__eventListeners = {}),
          arguments.length === 1)
        )
          for (var g in h) this.on(g, h[g]);
        else
          this.__eventListeners[h] || (this.__eventListeners[h] = []),
            this.__eventListeners[h].push(m);
        return this;
      }
      function u(h, m) {
        var g = function () {
          m.apply(this, arguments), this.off(h, g);
        }.bind(this);
        this.on(h, g);
      }
      function d(h, m) {
        if (arguments.length === 1) for (var g in h) u.call(this, g, h[g]);
        else u.call(this, h, m);
        return this;
      }
      function l(h, m) {
        if (!this.__eventListeners) return this;
        if (arguments.length === 0)
          for (h in this.__eventListeners) a.call(this, h);
        else if (arguments.length === 1 && typeof arguments[0] == "object")
          for (var g in h) a.call(this, g, h[g]);
        else a.call(this, h, m);
        return this;
      }
      function c(h, m) {
        if (!this.__eventListeners) return this;
        var g = this.__eventListeners[h];
        if (!g) return this;
        for (var f = 0, v = g.length; f < v; f++)
          g[f] && g[f].call(this, m || {});
        return (
          (this.__eventListeners[h] = g.filter(function (y) {
            return y !== !1;
          })),
          this
        );
      }
      e.Observable = { fire: c, on: s, once: d, off: l };
    })(),
    (e.Collection = {
      _objects: [],
      add: function () {
        if (
          (this._objects.push.apply(this._objects, arguments),
          this._onObjectAdded)
        )
          for (var a = 0, s = arguments.length; a < s; a++)
            this._onObjectAdded(arguments[a]);
        return this.renderOnAddRemove && this.requestRenderAll(), this;
      },
      insertAt: function (a, s, u) {
        var d = this._objects;
        return (
          u ? (d[s] = a) : d.splice(s, 0, a),
          this._onObjectAdded && this._onObjectAdded(a),
          this.renderOnAddRemove && this.requestRenderAll(),
          this
        );
      },
      remove: function () {
        for (
          var a = this._objects, s, u = !1, d = 0, l = arguments.length;
          d < l;
          d++
        )
          (s = a.indexOf(arguments[d])),
            s !== -1 &&
              ((u = !0),
              a.splice(s, 1),
              this._onObjectRemoved && this._onObjectRemoved(arguments[d]));
        return this.renderOnAddRemove && u && this.requestRenderAll(), this;
      },
      forEachObject: function (a, s) {
        for (var u = this.getObjects(), d = 0, l = u.length; d < l; d++)
          a.call(s, u[d], d, u);
        return this;
      },
      getObjects: function (a) {
        return typeof a > "u"
          ? this._objects.concat()
          : this._objects.filter(function (s) {
              return s.type === a;
            });
      },
      item: function (a) {
        return this._objects[a];
      },
      isEmpty: function () {
        return this._objects.length === 0;
      },
      size: function () {
        return this._objects.length;
      },
      contains: function (a, s) {
        return this._objects.indexOf(a) > -1
          ? !0
          : s
          ? this._objects.some(function (u) {
              return typeof u.contains == "function" && u.contains(a, !0);
            })
          : !1;
      },
      complexity: function () {
        return this._objects.reduce(function (a, s) {
          return (a += s.complexity ? s.complexity() : 0), a;
        }, 0);
      },
    }),
    (e.CommonMethods = {
      _setOptions: function (a) {
        for (var s in a) this.set(s, a[s]);
      },
      _initGradient: function (a, s) {
        a &&
          a.colorStops &&
          !(a instanceof e.Gradient) &&
          this.set(s, new e.Gradient(a));
      },
      _initPattern: function (a, s, u) {
        a && a.source && !(a instanceof e.Pattern)
          ? this.set(s, new e.Pattern(a, u))
          : u && u();
      },
      _setObject: function (a) {
        for (var s in a) this._set(s, a[s]);
      },
      set: function (a, s) {
        return (
          typeof a == "object" ? this._setObject(a) : this._set(a, s), this
        );
      },
      _set: function (a, s) {
        this[a] = s;
      },
      toggle: function (a) {
        var s = this.get(a);
        return typeof s == "boolean" && this.set(a, !s), this;
      },
      get: function (a) {
        return this[a];
      },
    }),
    (function (a) {
      var s = Math.sqrt,
        u = Math.atan2,
        d = Math.pow,
        l = Math.PI / 180,
        c = Math.PI / 2;
      e.util = {
        cos: function (h) {
          if (h === 0) return 1;
          h < 0 && (h = -h);
          var m = h / c;
          switch (m) {
            case 1:
            case 3:
              return 0;
            case 2:
              return -1;
          }
          return Math.cos(h);
        },
        sin: function (h) {
          if (h === 0) return 0;
          var m = h / c,
            g = 1;
          switch ((h < 0 && (g = -1), m)) {
            case 1:
              return g;
            case 2:
              return 0;
            case 3:
              return -g;
          }
          return Math.sin(h);
        },
        removeFromArray: function (h, m) {
          var g = h.indexOf(m);
          return g !== -1 && h.splice(g, 1), h;
        },
        getRandomInt: function (h, m) {
          return Math.floor(Math.random() * (m - h + 1)) + h;
        },
        degreesToRadians: function (h) {
          return h * l;
        },
        radiansToDegrees: function (h) {
          return h / l;
        },
        rotatePoint: function (h, m, g) {
          var f = new e.Point(h.x - m.x, h.y - m.y),
            v = e.util.rotateVector(f, g);
          return new e.Point(v.x, v.y).addEquals(m);
        },
        rotateVector: function (h, m) {
          var g = e.util.sin(m),
            f = e.util.cos(m),
            v = h.x * f - h.y * g,
            y = h.x * g + h.y * f;
          return { x: v, y };
        },
        createVector: function (h, m) {
          return new e.Point(m.x - h.x, m.y - h.y);
        },
        calcAngleBetweenVectors: function (h, m) {
          return Math.acos(
            (h.x * m.x + h.y * m.y) /
              (Math.hypot(h.x, h.y) * Math.hypot(m.x, m.y))
          );
        },
        getHatVector: function (h) {
          return new e.Point(h.x, h.y).multiply(1 / Math.hypot(h.x, h.y));
        },
        getBisector: function (h, m, g) {
          var f = e.util.createVector(h, m),
            v = e.util.createVector(h, g),
            y = e.util.calcAngleBetweenVectors(f, v),
            _ = e.util.calcAngleBetweenVectors(e.util.rotateVector(f, y), v),
            x = (y * (_ === 0 ? 1 : -1)) / 2;
          return {
            vector: e.util.getHatVector(e.util.rotateVector(f, x)),
            angle: y,
          };
        },
        projectStrokeOnPoints: function (h, m, g) {
          var f = [],
            v = m.strokeWidth / 2,
            y = m.strokeUniform
              ? new e.Point(1 / m.scaleX, 1 / m.scaleY)
              : new e.Point(1, 1),
            _ = function (x) {
              var b = v / Math.hypot(x.x, x.y);
              return new e.Point(x.x * b * y.x, x.y * b * y.y);
            };
          return (
            h.length <= 1 ||
              h.forEach(function (x, b) {
                var S = new e.Point(x.x, x.y),
                  T,
                  w;
                b === 0
                  ? ((w = h[b + 1]),
                    (T = g
                      ? _(e.util.createVector(w, S)).addEquals(S)
                      : h[h.length - 1]))
                  : b === h.length - 1
                  ? ((T = h[b - 1]),
                    (w = g ? _(e.util.createVector(T, S)).addEquals(S) : h[0]))
                  : ((T = h[b - 1]), (w = h[b + 1]));
                var P = e.util.getBisector(S, T, w),
                  F = P.vector,
                  V = P.angle,
                  J,
                  z;
                if (
                  m.strokeLineJoin === "miter" &&
                  ((J = -v / Math.sin(V / 2)),
                  (z = new e.Point(F.x * J * y.x, F.y * J * y.y)),
                  Math.hypot(z.x, z.y) / v <= m.strokeMiterLimit)
                ) {
                  f.push(S.add(z)), f.push(S.subtract(z));
                  return;
                }
                (J = -v * Math.SQRT2),
                  (z = new e.Point(F.x * J * y.x, F.y * J * y.y)),
                  f.push(S.add(z)),
                  f.push(S.subtract(z));
              }),
            f
          );
        },
        transformPoint: function (h, m, g) {
          return g
            ? new e.Point(m[0] * h.x + m[2] * h.y, m[1] * h.x + m[3] * h.y)
            : new e.Point(
                m[0] * h.x + m[2] * h.y + m[4],
                m[1] * h.x + m[3] * h.y + m[5]
              );
        },
        makeBoundingBoxFromPoints: function (h, m) {
          if (m)
            for (var g = 0; g < h.length; g++)
              h[g] = e.util.transformPoint(h[g], m);
          var f = [h[0].x, h[1].x, h[2].x, h[3].x],
            v = e.util.array.min(f),
            y = e.util.array.max(f),
            _ = y - v,
            x = [h[0].y, h[1].y, h[2].y, h[3].y],
            b = e.util.array.min(x),
            S = e.util.array.max(x),
            T = S - b;
          return { left: v, top: b, width: _, height: T };
        },
        invertTransform: function (h) {
          var m = 1 / (h[0] * h[3] - h[1] * h[2]),
            g = [m * h[3], -m * h[1], -m * h[2], m * h[0]],
            f = e.util.transformPoint({ x: h[4], y: h[5] }, g, !0);
          return (g[4] = -f.x), (g[5] = -f.y), g;
        },
        toFixed: function (h, m) {
          return parseFloat(Number(h).toFixed(m));
        },
        parseUnit: function (h, m) {
          var g = /\D{0,2}$/.exec(h),
            f = parseFloat(h);
          switch ((m || (m = e.Text.DEFAULT_SVG_FONT_SIZE), g[0])) {
            case "mm":
              return (f * e.DPI) / 25.4;
            case "cm":
              return (f * e.DPI) / 2.54;
            case "in":
              return f * e.DPI;
            case "pt":
              return (f * e.DPI) / 72;
            case "pc":
              return ((f * e.DPI) / 72) * 12;
            case "em":
              return f * m;
            default:
              return f;
          }
        },
        falseFunction: function () {
          return !1;
        },
        getKlass: function (h, m) {
          return (
            (h = e.util.string.camelize(
              h.charAt(0).toUpperCase() + h.slice(1)
            )),
            e.util.resolveNamespace(m)[h]
          );
        },
        getSvgAttributes: function (h) {
          var m = ["instantiated_by_use", "style", "id", "class"];
          switch (h) {
            case "linearGradient":
              m = m.concat([
                "x1",
                "y1",
                "x2",
                "y2",
                "gradientUnits",
                "gradientTransform",
              ]);
              break;
            case "radialGradient":
              m = m.concat([
                "gradientUnits",
                "gradientTransform",
                "cx",
                "cy",
                "r",
                "fx",
                "fy",
                "fr",
              ]);
              break;
            case "stop":
              m = m.concat(["offset", "stop-color", "stop-opacity"]);
              break;
          }
          return m;
        },
        resolveNamespace: function (h) {
          if (!h) return e;
          var m = h.split("."),
            g = m.length,
            f,
            v = a || e.window;
          for (f = 0; f < g; ++f) v = v[m[f]];
          return v;
        },
        loadImage: function (h, m, g, f) {
          if (!h) {
            m && m.call(g, h);
            return;
          }
          var v = e.util.createImage(),
            y = function () {
              m && m.call(g, v, !1), (v = v.onload = v.onerror = null);
            };
          (v.onload = y),
            (v.onerror = function () {
              e.log("Error loading " + v.src),
                m && m.call(g, null, !0),
                (v = v.onload = v.onerror = null);
            }),
            h.indexOf("data") !== 0 &&
              f !== void 0 &&
              f !== null &&
              (v.crossOrigin = f),
            h.substring(0, 14) === "data:image/svg" &&
              ((v.onload = null), e.util.loadImageInDom(v, y)),
            (v.src = h);
        },
        loadImageInDom: function (h, m) {
          var g = e.document.createElement("div");
          (g.style.width = g.style.height = "1px"),
            (g.style.left = g.style.top = "-100%"),
            (g.style.position = "absolute"),
            g.appendChild(h),
            e.document.querySelector("body").appendChild(g),
            (h.onload = function () {
              m(), g.parentNode.removeChild(g), (g = null);
            });
        },
        enlivenObjects: function (h, m, g, f) {
          h = h || [];
          var v = [],
            y = 0,
            _ = h.length;
          function x() {
            ++y === _ &&
              m &&
              m(
                v.filter(function (b) {
                  return b;
                })
              );
          }
          if (!_) {
            m && m(v);
            return;
          }
          h.forEach(function (b, S) {
            if (!b || !b.type) {
              x();
              return;
            }
            var T = e.util.getKlass(b.type, g);
            T.fromObject(b, function (w, P) {
              P || (v[S] = w), f && f(b, w, P), x();
            });
          });
        },
        enlivenObjectEnlivables: function (h, m, g) {
          var f = e.Object.ENLIVEN_PROPS.filter(function (v) {
            return !!h[v];
          });
          e.util.enlivenObjects(
            f.map(function (v) {
              return h[v];
            }),
            function (v) {
              var y = {};
              f.forEach(function (_, x) {
                (y[_] = v[x]), m && (m[_] = v[x]);
              }),
                g && g(y);
            }
          );
        },
        enlivenPatterns: function (h, m) {
          h = h || [];
          function g() {
            ++v === y && m && m(f);
          }
          var f = [],
            v = 0,
            y = h.length;
          if (!y) {
            m && m(f);
            return;
          }
          h.forEach(function (_, x) {
            _ && _.source
              ? new e.Pattern(_, function (b) {
                  (f[x] = b), g();
                })
              : ((f[x] = _), g());
          });
        },
        groupSVGElements: function (h, m, g) {
          var f;
          return h && h.length === 1
            ? (typeof g < "u" && (h[0].sourcePath = g), h[0])
            : (m &&
                (m.width && m.height
                  ? (m.centerPoint = { x: m.width / 2, y: m.height / 2 })
                  : (delete m.width, delete m.height)),
              (f = new e.Group(h, m)),
              typeof g < "u" && (f.sourcePath = g),
              f);
        },
        populateWithProperties: function (h, m, g) {
          if (g && Array.isArray(g))
            for (var f = 0, v = g.length; f < v; f++)
              g[f] in h && (m[g[f]] = h[g[f]]);
        },
        createCanvasElement: function () {
          return e.document.createElement("canvas");
        },
        copyCanvasElement: function (h) {
          var m = e.util.createCanvasElement();
          return (
            (m.width = h.width),
            (m.height = h.height),
            m.getContext("2d").drawImage(h, 0, 0),
            m
          );
        },
        toDataURL: function (h, m, g) {
          return h.toDataURL("image/" + m, g);
        },
        createImage: function () {
          return e.document.createElement("img");
        },
        multiplyTransformMatrices: function (h, m, g) {
          return [
            h[0] * m[0] + h[2] * m[1],
            h[1] * m[0] + h[3] * m[1],
            h[0] * m[2] + h[2] * m[3],
            h[1] * m[2] + h[3] * m[3],
            g ? 0 : h[0] * m[4] + h[2] * m[5] + h[4],
            g ? 0 : h[1] * m[4] + h[3] * m[5] + h[5],
          ];
        },
        qrDecompose: function (h) {
          var m = u(h[1], h[0]),
            g = d(h[0], 2) + d(h[1], 2),
            f = s(g),
            v = (h[0] * h[3] - h[2] * h[1]) / f,
            y = u(h[0] * h[2] + h[1] * h[3], g);
          return {
            angle: m / l,
            scaleX: f,
            scaleY: v,
            skewX: y / l,
            skewY: 0,
            translateX: h[4],
            translateY: h[5],
          };
        },
        calcRotateMatrix: function (h) {
          if (!h.angle) return e.iMatrix.concat();
          var m = e.util.degreesToRadians(h.angle),
            g = e.util.cos(m),
            f = e.util.sin(m);
          return [g, f, -f, g, 0, 0];
        },
        calcDimensionsMatrix: function (h) {
          var m = typeof h.scaleX > "u" ? 1 : h.scaleX,
            g = typeof h.scaleY > "u" ? 1 : h.scaleY,
            f = [h.flipX ? -m : m, 0, 0, h.flipY ? -g : g, 0, 0],
            v = e.util.multiplyTransformMatrices,
            y = e.util.degreesToRadians;
          return (
            h.skewX && (f = v(f, [1, 0, Math.tan(y(h.skewX)), 1], !0)),
            h.skewY && (f = v(f, [1, Math.tan(y(h.skewY)), 0, 1], !0)),
            f
          );
        },
        composeMatrix: function (h) {
          var m = [1, 0, 0, 1, h.translateX || 0, h.translateY || 0],
            g = e.util.multiplyTransformMatrices;
          return (
            h.angle && (m = g(m, e.util.calcRotateMatrix(h))),
            (h.scaleX !== 1 ||
              h.scaleY !== 1 ||
              h.skewX ||
              h.skewY ||
              h.flipX ||
              h.flipY) &&
              (m = g(m, e.util.calcDimensionsMatrix(h))),
            m
          );
        },
        resetObjectTransform: function (h) {
          (h.scaleX = 1),
            (h.scaleY = 1),
            (h.skewX = 0),
            (h.skewY = 0),
            (h.flipX = !1),
            (h.flipY = !1),
            h.rotate(0);
        },
        saveObjectTransform: function (h) {
          return {
            scaleX: h.scaleX,
            scaleY: h.scaleY,
            skewX: h.skewX,
            skewY: h.skewY,
            angle: h.angle,
            left: h.left,
            flipX: h.flipX,
            flipY: h.flipY,
            top: h.top,
          };
        },
        isTransparent: function (h, m, g, f) {
          f > 0 && (m > f ? (m -= f) : (m = 0), g > f ? (g -= f) : (g = 0));
          var v = !0,
            y,
            _,
            x = h.getImageData(m, g, f * 2 || 1, f * 2 || 1),
            b = x.data.length;
          for (
            y = 3;
            y < b && ((_ = x.data[y]), (v = _ <= 0), v !== !1);
            y += 4
          );
          return (x = null), v;
        },
        parsePreserveAspectRatioAttribute: function (h) {
          var m = "meet",
            g = "Mid",
            f = "Mid",
            v = h.split(" "),
            y;
          return (
            v &&
              v.length &&
              ((m = v.pop()),
              m !== "meet" && m !== "slice"
                ? ((y = m), (m = "meet"))
                : v.length && (y = v.pop())),
            (g = y !== "none" ? y.slice(1, 4) : "none"),
            (f = y !== "none" ? y.slice(5, 8) : "none"),
            { meetOrSlice: m, alignX: g, alignY: f }
          );
        },
        clearFabricFontCache: function (h) {
          (h = (h || "").toLowerCase()),
            h
              ? e.charWidthsCache[h] && delete e.charWidthsCache[h]
              : (e.charWidthsCache = {});
        },
        limitDimsByArea: function (h, m) {
          var g = Math.sqrt(m * h),
            f = Math.floor(m / g);
          return { x: Math.floor(g), y: f };
        },
        capValue: function (h, m, g) {
          return Math.max(h, Math.min(m, g));
        },
        findScaleToFit: function (h, m) {
          return Math.min(m.width / h.width, m.height / h.height);
        },
        findScaleToCover: function (h, m) {
          return Math.max(m.width / h.width, m.height / h.height);
        },
        matrixToSVG: function (h) {
          return (
            "matrix(" +
            h
              .map(function (m) {
                return e.util.toFixed(m, e.Object.NUM_FRACTION_DIGITS);
              })
              .join(" ") +
            ")"
          );
        },
        removeTransformFromObject: function (h, m) {
          var g = e.util.invertTransform(m),
            f = e.util.multiplyTransformMatrices(g, h.calcOwnMatrix());
          e.util.applyTransformToObject(h, f);
        },
        addTransformToObject: function (h, m) {
          e.util.applyTransformToObject(
            h,
            e.util.multiplyTransformMatrices(m, h.calcOwnMatrix())
          );
        },
        applyTransformToObject: function (h, m) {
          var g = e.util.qrDecompose(m),
            f = new e.Point(g.translateX, g.translateY);
          (h.flipX = !1),
            (h.flipY = !1),
            h.set("scaleX", g.scaleX),
            h.set("scaleY", g.scaleY),
            (h.skewX = g.skewX),
            (h.skewY = g.skewY),
            (h.angle = g.angle),
            h.setPositionByOrigin(f, "center", "center");
        },
        sizeAfterTransform: function (h, m, g) {
          var f = h / 2,
            v = m / 2,
            y = [
              { x: -f, y: -v },
              { x: f, y: -v },
              { x: -f, y: v },
              { x: f, y: v },
            ],
            _ = e.util.calcDimensionsMatrix(g),
            x = e.util.makeBoundingBoxFromPoints(y, _);
          return { x: x.width, y: x.height };
        },
        mergeClipPaths: function (h, m) {
          var g = h,
            f = m;
          g.inverted && !f.inverted && ((g = m), (f = h)),
            e.util.applyTransformToObject(
              f,
              e.util.multiplyTransformMatrices(
                e.util.invertTransform(g.calcTransformMatrix()),
                f.calcTransformMatrix()
              )
            );
          var v = g.inverted && f.inverted;
          return (
            v && (g.inverted = f.inverted = !1),
            new e.Group([g], { clipPath: f, inverted: v })
          );
        },
        hasStyleChanged: function (h, m, g) {
          return (
            (g = g || !1),
            h.fill !== m.fill ||
              h.stroke !== m.stroke ||
              h.strokeWidth !== m.strokeWidth ||
              h.fontSize !== m.fontSize ||
              h.fontFamily !== m.fontFamily ||
              h.fontWeight !== m.fontWeight ||
              h.fontStyle !== m.fontStyle ||
              h.textBackgroundColor !== m.textBackgroundColor ||
              h.deltaY !== m.deltaY ||
              (g &&
                (h.overline !== m.overline ||
                  h.underline !== m.underline ||
                  h.linethrough !== m.linethrough))
          );
        },
        stylesToArray: function (g, m) {
          for (
            var g = e.util.object.clone(g, !0),
              f = m.split(`
`),
              v = -1,
              y = {},
              _ = [],
              x = 0;
            x < f.length;
            x++
          ) {
            if (!g[x]) {
              v += f[x].length;
              continue;
            }
            for (var b = 0; b < f[x].length; b++) {
              v++;
              var S = g[x][b];
              if (S && Object.keys(S).length > 0) {
                var T = e.util.hasStyleChanged(y, S, !0);
                T
                  ? _.push({ start: v, end: v + 1, style: S })
                  : _[_.length - 1].end++;
              }
              y = S || {};
            }
          }
          return _;
        },
        stylesFromArray: function (h, m) {
          if (!Array.isArray(h)) return h;
          for (
            var g = m.split(`
`),
              f = -1,
              v = 0,
              y = {},
              _ = 0;
            _ < g.length;
            _++
          )
            for (var x = 0; x < g[_].length; x++)
              f++,
                h[v] &&
                  h[v].start <= f &&
                  f < h[v].end &&
                  ((y[_] = y[_] || {}),
                  (y[_][x] = Object.assign({}, h[v].style)),
                  f === h[v].end - 1 && v++);
          return y;
        },
      };
    })(n),
    (function () {
      var a = Array.prototype.join,
        s = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 },
        u = { m: "l", M: "L" };
      function d(C, R, A, O, H, I, E, k, $, Y, X) {
        var ee = e.util.cos(C),
          he = e.util.sin(C),
          pe = e.util.cos(R),
          Z = e.util.sin(R),
          K = A * H * pe - O * I * Z + E,
          ce = O * H * pe + A * I * Z + k,
          ue = Y + $ * (-A * H * he - O * I * ee),
          oe = X + $ * (-O * H * he + A * I * ee),
          le = K + $ * (A * H * Z + O * I * pe),
          ge = ce + $ * (O * H * Z - A * I * pe);
        return ["C", ue, oe, le, ge, K, ce];
      }
      function l(C, R, A, O, H, I, E) {
        var k = Math.PI,
          $ = (E * k) / 180,
          Y = e.util.sin($),
          X = e.util.cos($),
          ee = 0,
          he = 0;
        (A = Math.abs(A)), (O = Math.abs(O));
        var pe = -X * C * 0.5 - Y * R * 0.5,
          Z = -X * R * 0.5 + Y * C * 0.5,
          K = A * A,
          ce = O * O,
          ue = Z * Z,
          oe = pe * pe,
          le = K * ce - K * ue - ce * oe,
          ge = 0;
        if (le < 0) {
          var Re = Math.sqrt(1 - le / (K * ce));
          (A *= Re), (O *= Re);
        } else ge = (H === I ? -1 : 1) * Math.sqrt(le / (K * ue + ce * oe));
        var Me = (ge * A * Z) / O,
          L = (-ge * O * pe) / A,
          D = X * Me - Y * L + C * 0.5,
          ne = Y * Me + X * L + R * 0.5,
          de = c(1, 0, (pe - Me) / A, (Z - L) / O),
          ye = c((pe - Me) / A, (Z - L) / O, (-pe - Me) / A, (-Z - L) / O);
        I === 0 && ye > 0 ? (ye -= 2 * k) : I === 1 && ye < 0 && (ye += 2 * k);
        for (
          var _e = Math.ceil(Math.abs((ye / k) * 2)),
            Pe = [],
            U = ye / _e,
            te =
              ((8 / 3) * Math.sin(U / 4) * Math.sin(U / 4)) / Math.sin(U / 2),
            we = de + U,
            Se = 0;
          Se < _e;
          Se++
        )
          (Pe[Se] = d(de, we, X, Y, A, O, D, ne, te, ee, he)),
            (ee = Pe[Se][5]),
            (he = Pe[Se][6]),
            (de = we),
            (we += U);
        return Pe;
      }
      function c(C, R, A, O) {
        var H = Math.atan2(R, C),
          I = Math.atan2(O, A);
        return I >= H ? I - H : 2 * Math.PI - (H - I);
      }
      function h(C, R, A, O, H, I, E, k) {
        var $;
        if (
          e.cachesBoundsOfCurve &&
          (($ = a.call(arguments)), e.boundsOfCurveCache[$])
        )
          return e.boundsOfCurveCache[$];
        var Y = Math.sqrt,
          X = Math.min,
          ee = Math.max,
          he = Math.abs,
          pe = [],
          Z = [[], []],
          K,
          ce,
          ue,
          oe,
          le,
          ge,
          Re,
          Me;
        (ce = 6 * C - 12 * A + 6 * H),
          (K = -3 * C + 9 * A - 9 * H + 3 * E),
          (ue = 3 * A - 3 * C);
        for (var L = 0; L < 2; ++L) {
          if (
            (L > 0 &&
              ((ce = 6 * R - 12 * O + 6 * I),
              (K = -3 * R + 9 * O - 9 * I + 3 * k),
              (ue = 3 * O - 3 * R)),
            he(K) < 1e-12)
          ) {
            if (he(ce) < 1e-12) continue;
            (oe = -ue / ce), 0 < oe && oe < 1 && pe.push(oe);
            continue;
          }
          (Re = ce * ce - 4 * ue * K),
            !(Re < 0) &&
              ((Me = Y(Re)),
              (le = (-ce + Me) / (2 * K)),
              0 < le && le < 1 && pe.push(le),
              (ge = (-ce - Me) / (2 * K)),
              0 < ge && ge < 1 && pe.push(ge));
        }
        for (var D, ne, de = pe.length, ye = de, _e; de--; )
          (oe = pe[de]),
            (_e = 1 - oe),
            (D =
              _e * _e * _e * C +
              3 * _e * _e * oe * A +
              3 * _e * oe * oe * H +
              oe * oe * oe * E),
            (Z[0][de] = D),
            (ne =
              _e * _e * _e * R +
              3 * _e * _e * oe * O +
              3 * _e * oe * oe * I +
              oe * oe * oe * k),
            (Z[1][de] = ne);
        (Z[0][ye] = C), (Z[1][ye] = R), (Z[0][ye + 1] = E), (Z[1][ye + 1] = k);
        var Pe = [
          { x: X.apply(null, Z[0]), y: X.apply(null, Z[1]) },
          { x: ee.apply(null, Z[0]), y: ee.apply(null, Z[1]) },
        ];
        return e.cachesBoundsOfCurve && (e.boundsOfCurveCache[$] = Pe), Pe;
      }
      function m(C, R, A) {
        for (
          var O = A[1],
            H = A[2],
            I = A[3],
            E = A[4],
            k = A[5],
            $ = A[6],
            Y = A[7],
            X = l($ - C, Y - R, O, H, E, k, I),
            ee = 0,
            he = X.length;
          ee < he;
          ee++
        )
          (X[ee][1] += C),
            (X[ee][2] += R),
            (X[ee][3] += C),
            (X[ee][4] += R),
            (X[ee][5] += C),
            (X[ee][6] += R);
        return X;
      }
      function g(C) {
        var R = 0,
          A = 0,
          O = C.length,
          H = 0,
          I = 0,
          E,
          k,
          $,
          Y = [],
          X,
          ee,
          he;
        for (k = 0; k < O; ++k) {
          switch ((($ = !1), (E = C[k].slice(0)), E[0])) {
            case "l":
              (E[0] = "L"), (E[1] += R), (E[2] += A);
            case "L":
              (R = E[1]), (A = E[2]);
              break;
            case "h":
              E[1] += R;
            case "H":
              (E[0] = "L"), (E[2] = A), (R = E[1]);
              break;
            case "v":
              E[1] += A;
            case "V":
              (E[0] = "L"), (A = E[1]), (E[1] = R), (E[2] = A);
              break;
            case "m":
              (E[0] = "M"), (E[1] += R), (E[2] += A);
            case "M":
              (R = E[1]), (A = E[2]), (H = E[1]), (I = E[2]);
              break;
            case "c":
              (E[0] = "C"),
                (E[1] += R),
                (E[2] += A),
                (E[3] += R),
                (E[4] += A),
                (E[5] += R),
                (E[6] += A);
            case "C":
              (ee = E[3]), (he = E[4]), (R = E[5]), (A = E[6]);
              break;
            case "s":
              (E[0] = "S"), (E[1] += R), (E[2] += A), (E[3] += R), (E[4] += A);
            case "S":
              X === "C"
                ? ((ee = 2 * R - ee), (he = 2 * A - he))
                : ((ee = R), (he = A)),
                (R = E[3]),
                (A = E[4]),
                (E[0] = "C"),
                (E[5] = E[3]),
                (E[6] = E[4]),
                (E[3] = E[1]),
                (E[4] = E[2]),
                (E[1] = ee),
                (E[2] = he),
                (ee = E[3]),
                (he = E[4]);
              break;
            case "q":
              (E[0] = "Q"), (E[1] += R), (E[2] += A), (E[3] += R), (E[4] += A);
            case "Q":
              (ee = E[1]), (he = E[2]), (R = E[3]), (A = E[4]);
              break;
            case "t":
              (E[0] = "T"), (E[1] += R), (E[2] += A);
            case "T":
              X === "Q"
                ? ((ee = 2 * R - ee), (he = 2 * A - he))
                : ((ee = R), (he = A)),
                (E[0] = "Q"),
                (R = E[1]),
                (A = E[2]),
                (E[1] = ee),
                (E[2] = he),
                (E[3] = R),
                (E[4] = A);
              break;
            case "a":
              (E[0] = "A"), (E[6] += R), (E[7] += A);
            case "A":
              ($ = !0), (Y = Y.concat(m(R, A, E))), (R = E[6]), (A = E[7]);
              break;
            case "z":
            case "Z":
              (R = H), (A = I);
              break;
          }
          $ || Y.push(E), (X = E[0]);
        }
        return Y;
      }
      function f(C, R, A, O) {
        return Math.sqrt((A - C) * (A - C) + (O - R) * (O - R));
      }
      function v(C) {
        return C * C * C;
      }
      function y(C) {
        return 3 * C * C * (1 - C);
      }
      function _(C) {
        return 3 * C * (1 - C) * (1 - C);
      }
      function x(C) {
        return (1 - C) * (1 - C) * (1 - C);
      }
      function b(C, R, A, O, H, I, E, k) {
        return function ($) {
          var Y = v($),
            X = y($),
            ee = _($),
            he = x($);
          return {
            x: E * Y + H * X + A * ee + C * he,
            y: k * Y + I * X + O * ee + R * he,
          };
        };
      }
      function S(C, R, A, O, H, I, E, k) {
        return function ($) {
          var Y = 1 - $,
            X = 3 * Y * Y * (A - C) + 6 * Y * $ * (H - A) + 3 * $ * $ * (E - H),
            ee =
              3 * Y * Y * (O - R) + 6 * Y * $ * (I - O) + 3 * $ * $ * (k - I);
          return Math.atan2(ee, X);
        };
      }
      function T(C) {
        return C * C;
      }
      function w(C) {
        return 2 * C * (1 - C);
      }
      function P(C) {
        return (1 - C) * (1 - C);
      }
      function F(C, R, A, O, H, I) {
        return function (E) {
          var k = T(E),
            $ = w(E),
            Y = P(E);
          return { x: H * k + A * $ + C * Y, y: I * k + O * $ + R * Y };
        };
      }
      function V(C, R, A, O, H, I) {
        return function (E) {
          var k = 1 - E,
            $ = 2 * k * (A - C) + 2 * E * (H - A),
            Y = 2 * k * (O - R) + 2 * E * (I - O);
          return Math.atan2(Y, $);
        };
      }
      function J(C, R, A) {
        var O = { x: R, y: A },
          H,
          I = 0,
          E;
        for (E = 1; E <= 100; E += 1)
          (H = C(E / 100)), (I += f(O.x, O.y, H.x, H.y)), (O = H);
        return I;
      }
      function z(C, R) {
        for (
          var A = 0,
            O = 0,
            H = C.iterator,
            I = { x: C.x, y: C.y },
            E,
            k,
            $ = 0.01,
            Y = C.angleFinder,
            X;
          O < R && $ > 1e-4;

        )
          (E = H(A)),
            (X = A),
            (k = f(I.x, I.y, E.x, E.y)),
            k + O > R ? ((A -= $), ($ /= 2)) : ((I = E), (A += $), (O += k));
        return (E.angle = Y(X)), E;
      }
      function B(C) {
        for (
          var R = 0,
            A = C.length,
            O,
            H = 0,
            I = 0,
            E = 0,
            k = 0,
            $ = [],
            Y,
            X,
            ee,
            he = 0;
          he < A;
          he++
        ) {
          switch (((O = C[he]), (X = { x: H, y: I, command: O[0] }), O[0])) {
            case "M":
              (X.length = 0), (E = H = O[1]), (k = I = O[2]);
              break;
            case "L":
              (X.length = f(H, I, O[1], O[2])), (H = O[1]), (I = O[2]);
              break;
            case "C":
              (Y = b(H, I, O[1], O[2], O[3], O[4], O[5], O[6])),
                (ee = S(H, I, O[1], O[2], O[3], O[4], O[5], O[6])),
                (X.iterator = Y),
                (X.angleFinder = ee),
                (X.length = J(Y, H, I)),
                (H = O[5]),
                (I = O[6]);
              break;
            case "Q":
              (Y = F(H, I, O[1], O[2], O[3], O[4])),
                (ee = V(H, I, O[1], O[2], O[3], O[4])),
                (X.iterator = Y),
                (X.angleFinder = ee),
                (X.length = J(Y, H, I)),
                (H = O[3]),
                (I = O[4]);
              break;
            case "Z":
            case "z":
              (X.destX = E),
                (X.destY = k),
                (X.length = f(H, I, E, k)),
                (H = E),
                (I = k);
              break;
          }
          (R += X.length), $.push(X);
        }
        return $.push({ length: R, x: H, y: I }), $;
      }
      function G(C, R, A) {
        A || (A = B(C));
        for (var O = 0; R - A[O].length > 0 && O < A.length - 2; )
          (R -= A[O].length), O++;
        var H = A[O],
          I = R / H.length,
          E = H.command,
          k = C[O],
          $;
        switch (E) {
          case "M":
            return { x: H.x, y: H.y, angle: 0 };
          case "Z":
          case "z":
            return (
              ($ = new e.Point(H.x, H.y).lerp(
                new e.Point(H.destX, H.destY),
                I
              )),
              ($.angle = Math.atan2(H.destY - H.y, H.destX - H.x)),
              $
            );
          case "L":
            return (
              ($ = new e.Point(H.x, H.y).lerp(new e.Point(k[1], k[2]), I)),
              ($.angle = Math.atan2(k[2] - H.y, k[1] - H.x)),
              $
            );
          case "C":
            return z(H, R);
          case "Q":
            return z(H, R);
        }
      }
      function ie(C) {
        var R = [],
          A = [],
          O,
          H,
          I = e.rePathCommand,
          E = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*",
          k = "(" + E + ")" + e.commaWsp,
          $ = "([01])" + e.commaWsp + "?",
          Y = k + "?" + k + "?" + k + $ + $ + k + "?(" + E + ")",
          X = new RegExp(Y, "g"),
          ee,
          he,
          pe;
        if (!C || !C.match) return R;
        pe = C.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
        for (var Z = 0, K, ce = pe.length; Z < ce; Z++) {
          (O = pe[Z]), (he = O.slice(1).trim()), (A.length = 0);
          var ue = O.charAt(0);
          if (((K = [ue]), ue.toLowerCase() === "a"))
            for (var oe; (oe = X.exec(he)); )
              for (var le = 1; le < oe.length; le++) A.push(oe[le]);
          else for (; (ee = I.exec(he)); ) A.push(ee[0]);
          for (var le = 0, ge = A.length; le < ge; le++)
            (H = parseFloat(A[le])), isNaN(H) || K.push(H);
          var Re = s[ue.toLowerCase()],
            Me = u[ue] || ue;
          if (K.length - 1 > Re)
            for (var L = 1, D = K.length; L < D; L += Re)
              R.push([ue].concat(K.slice(L, L + Re))), (ue = Me);
          else R.push(K);
        }
        return R;
      }
      function re(C, R) {
        var A = [],
          O,
          H = new e.Point(C[0].x, C[0].y),
          I = new e.Point(C[1].x, C[1].y),
          E = C.length,
          k = 1,
          $ = 0,
          Y = E > 2;
        for (
          R = R || 0,
            Y &&
              ((k = C[2].x < I.x ? -1 : C[2].x === I.x ? 0 : 1),
              ($ = C[2].y < I.y ? -1 : C[2].y === I.y ? 0 : 1)),
            A.push(["M", H.x - k * R, H.y - $ * R]),
            O = 1;
          O < E;
          O++
        ) {
          if (!H.eq(I)) {
            var X = H.midPointFrom(I);
            A.push(["Q", H.x, H.y, X.x, X.y]);
          }
          (H = C[O]), O + 1 < C.length && (I = C[O + 1]);
        }
        return (
          Y &&
            ((k = H.x > C[O - 2].x ? 1 : H.x === C[O - 2].x ? 0 : -1),
            ($ = H.y > C[O - 2].y ? 1 : H.y === C[O - 2].y ? 0 : -1)),
          A.push(["L", H.x + k * R, H.y + $ * R]),
          A
        );
      }
      function j(C, R, A) {
        return (
          A &&
            (R = e.util.multiplyTransformMatrices(R, [1, 0, 0, 1, -A.x, -A.y])),
          C.map(function (O) {
            for (var H = O.slice(0), I = {}, E = 1; E < O.length - 1; E += 2)
              (I.x = O[E]),
                (I.y = O[E + 1]),
                (I = e.util.transformPoint(I, R)),
                (H[E] = I.x),
                (H[E + 1] = I.y);
            return H;
          })
        );
      }
      (e.util.joinPath = function (C) {
        return C.map(function (R) {
          return R.join(" ");
        }).join(" ");
      }),
        (e.util.parsePath = ie),
        (e.util.makePathSimpler = g),
        (e.util.getSmoothPathFromPoints = re),
        (e.util.getPathSegmentsInfo = B),
        (e.util.getBoundsOfCurve = h),
        (e.util.getPointOnPath = G),
        (e.util.transformPath = j);
    })(),
    (function () {
      var a = Array.prototype.slice;
      function s(h, m) {
        for (
          var g = a.call(arguments, 2), f = [], v = 0, y = h.length;
          v < y;
          v++
        )
          f[v] = g.length ? h[v][m].apply(h[v], g) : h[v][m].call(h[v]);
        return f;
      }
      function u(h, m) {
        return c(h, m, function (g, f) {
          return g >= f;
        });
      }
      function d(h, m) {
        return c(h, m, function (g, f) {
          return g < f;
        });
      }
      function l(h, m) {
        for (var g = h.length; g--; ) h[g] = m;
        return h;
      }
      function c(h, m, g) {
        if (!(!h || h.length === 0)) {
          var f = h.length - 1,
            v = m ? h[f][m] : h[f];
          if (m) for (; f--; ) g(h[f][m], v) && (v = h[f][m]);
          else for (; f--; ) g(h[f], v) && (v = h[f]);
          return v;
        }
      }
      e.util.array = { fill: l, invoke: s, min: d, max: u };
    })(),
    (function () {
      function a(u, d, l) {
        if (l)
          if (!e.isLikelyNode && d instanceof Element) u = d;
          else if (d instanceof Array) {
            u = [];
            for (var c = 0, h = d.length; c < h; c++) u[c] = a({}, d[c], l);
          } else if (d && typeof d == "object")
            for (var m in d)
              m === "canvas" || m === "group"
                ? (u[m] = null)
                : d.hasOwnProperty(m) && (u[m] = a({}, d[m], l));
          else u = d;
        else for (var m in d) u[m] = d[m];
        return u;
      }
      function s(u, d) {
        return a({}, u, d);
      }
      (e.util.object = { extend: a, clone: s }),
        e.util.object.extend(e.util, e.Observable);
    })(),
    (function () {
      function a(c) {
        return c.replace(/-+(.)?/g, function (h, m) {
          return m ? m.toUpperCase() : "";
        });
      }
      function s(c, h) {
        return (
          c.charAt(0).toUpperCase() +
          (h ? c.slice(1) : c.slice(1).toLowerCase())
        );
      }
      function u(c) {
        return c
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&apos;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }
      function d(c) {
        var h = 0,
          m,
          g = [];
        for (h = 0, m; h < c.length; h++) (m = l(c, h)) !== !1 && g.push(m);
        return g;
      }
      function l(c, h) {
        var m = c.charCodeAt(h);
        if (isNaN(m)) return "";
        if (m < 55296 || m > 57343) return c.charAt(h);
        if (55296 <= m && m <= 56319) {
          if (c.length <= h + 1)
            throw "High surrogate without following low surrogate";
          var g = c.charCodeAt(h + 1);
          if (56320 > g || g > 57343)
            throw "High surrogate without following low surrogate";
          return c.charAt(h) + c.charAt(h + 1);
        }
        if (h === 0) throw "Low surrogate without preceding high surrogate";
        var f = c.charCodeAt(h - 1);
        if (55296 > f || f > 56319)
          throw "Low surrogate without preceding high surrogate";
        return !1;
      }
      e.util.string = {
        camelize: a,
        capitalize: s,
        escapeXml: u,
        graphemeSplit: d,
      };
    })(),
    (function () {
      var a = Array.prototype.slice,
        s = function () {},
        u = (function () {
          for (var m in { toString: 1 }) if (m === "toString") return !1;
          return !0;
        })(),
        d = function (m, g, f) {
          for (var v in g)
            v in m.prototype &&
            typeof m.prototype[v] == "function" &&
            (g[v] + "").indexOf("callSuper") > -1
              ? (m.prototype[v] = (function (y) {
                  return function () {
                    var _ = this.constructor.superclass;
                    this.constructor.superclass = f;
                    var x = g[y].apply(this, arguments);
                    if (((this.constructor.superclass = _), y !== "initialize"))
                      return x;
                  };
                })(v))
              : (m.prototype[v] = g[v]),
              u &&
                (g.toString !== Object.prototype.toString &&
                  (m.prototype.toString = g.toString),
                g.valueOf !== Object.prototype.valueOf &&
                  (m.prototype.valueOf = g.valueOf));
        };
      function l() {}
      function c(m) {
        for (var g = null, f = this; f.constructor.superclass; ) {
          var v = f.constructor.superclass.prototype[m];
          if (f[m] !== v) {
            g = v;
            break;
          }
          f = f.constructor.superclass.prototype;
        }
        return g
          ? arguments.length > 1
            ? g.apply(this, a.call(arguments, 1))
            : g.call(this)
          : console.log(
              "tried to callSuper " +
                m +
                ", method not found in prototype chain",
              this
            );
      }
      function h() {
        var m = null,
          g = a.call(arguments, 0);
        typeof g[0] == "function" && (m = g.shift());
        function f() {
          this.initialize.apply(this, arguments);
        }
        (f.superclass = m),
          (f.subclasses = []),
          m &&
            ((l.prototype = m.prototype),
            (f.prototype = new l()),
            m.subclasses.push(f));
        for (var v = 0, y = g.length; v < y; v++) d(f, g[v], m);
        return (
          f.prototype.initialize || (f.prototype.initialize = s),
          (f.prototype.constructor = f),
          (f.prototype.callSuper = c),
          f
        );
      }
      e.util.createClass = h;
    })(),
    (function () {
      var a = !!e.document.createElement("div").attachEvent,
        s = ["touchstart", "touchmove", "touchend"];
      (e.util.addListener = function (d, l, c, h) {
        d && d.addEventListener(l, c, a ? !1 : h);
      }),
        (e.util.removeListener = function (d, l, c, h) {
          d && d.removeEventListener(l, c, a ? !1 : h);
        });
      function u(d) {
        var l = d.changedTouches;
        return l && l[0] ? l[0] : d;
      }
      (e.util.getPointer = function (d) {
        var l = d.target,
          c = e.util.getScrollLeftTop(l),
          h = u(d);
        return { x: h.clientX + c.left, y: h.clientY + c.top };
      }),
        (e.util.isTouchEvent = function (d) {
          return s.indexOf(d.type) > -1 || d.pointerType === "touch";
        });
    })(),
    (function () {
      function a(h, m) {
        var g = h.style;
        if (!g) return h;
        if (typeof m == "string")
          return (
            (h.style.cssText += ";" + m),
            m.indexOf("opacity") > -1
              ? c(h, m.match(/opacity:\s*(\d?\.?\d*)/)[1])
              : h
          );
        for (var f in m)
          if (f === "opacity") c(h, m[f]);
          else {
            var v =
              f === "float" || f === "cssFloat"
                ? typeof g.styleFloat > "u"
                  ? "cssFloat"
                  : "styleFloat"
                : f;
            g.setProperty(v, m[f]);
          }
        return h;
      }
      var s = e.document.createElement("div"),
        u = typeof s.style.opacity == "string",
        d = typeof s.style.filter == "string",
        l = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,
        c = function (h) {
          return h;
        };
      u
        ? (c = function (h, m) {
            return (h.style.opacity = m), h;
          })
        : d &&
          (c = function (h, m) {
            var g = h.style;
            return (
              h.currentStyle && !h.currentStyle.hasLayout && (g.zoom = 1),
              l.test(g.filter)
                ? ((m = m >= 0.9999 ? "" : "alpha(opacity=" + m * 100 + ")"),
                  (g.filter = g.filter.replace(l, m)))
                : (g.filter += " alpha(opacity=" + m * 100 + ")"),
              h
            );
          }),
        (e.util.setStyle = a);
    })(),
    (function () {
      var a = Array.prototype.slice;
      function s(x) {
        return typeof x == "string" ? e.document.getElementById(x) : x;
      }
      var u,
        d = function (x) {
          return a.call(x, 0);
        };
      try {
        u = d(e.document.childNodes) instanceof Array;
      } catch {}
      u ||
        (d = function (x) {
          for (var b = new Array(x.length), S = x.length; S--; ) b[S] = x[S];
          return b;
        });
      function l(x, b) {
        var S = e.document.createElement(x);
        for (var T in b)
          T === "class"
            ? (S.className = b[T])
            : T === "for"
            ? (S.htmlFor = b[T])
            : S.setAttribute(T, b[T]);
        return S;
      }
      function c(x, b) {
        x &&
          (" " + x.className + " ").indexOf(" " + b + " ") === -1 &&
          (x.className += (x.className ? " " : "") + b);
      }
      function h(x, b, S) {
        return (
          typeof b == "string" && (b = l(b, S)),
          x.parentNode && x.parentNode.replaceChild(b, x),
          b.appendChild(x),
          b
        );
      }
      function m(x) {
        for (
          var b = 0,
            S = 0,
            T = e.document.documentElement,
            w = e.document.body || { scrollLeft: 0, scrollTop: 0 };
          x &&
          (x.parentNode || x.host) &&
          ((x = x.parentNode || x.host),
          x === e.document
            ? ((b = w.scrollLeft || T.scrollLeft || 0),
              (S = w.scrollTop || T.scrollTop || 0))
            : ((b += x.scrollLeft || 0), (S += x.scrollTop || 0)),
          !(x.nodeType === 1 && x.style.position === "fixed"));

        );
        return { left: b, top: S };
      }
      function g(x) {
        var b,
          S = x && x.ownerDocument,
          T = { left: 0, top: 0 },
          w = { left: 0, top: 0 },
          P,
          F = {
            borderLeftWidth: "left",
            borderTopWidth: "top",
            paddingLeft: "left",
            paddingTop: "top",
          };
        if (!S) return w;
        for (var V in F) w[F[V]] += parseInt(f(x, V), 10) || 0;
        return (
          (b = S.documentElement),
          typeof x.getBoundingClientRect < "u" &&
            (T = x.getBoundingClientRect()),
          (P = m(x)),
          {
            left: T.left + P.left - (b.clientLeft || 0) + w.left,
            top: T.top + P.top - (b.clientTop || 0) + w.top,
          }
        );
      }
      var f;
      e.document.defaultView && e.document.defaultView.getComputedStyle
        ? (f = function (x, b) {
            var S = e.document.defaultView.getComputedStyle(x, null);
            return S ? S[b] : void 0;
          })
        : (f = function (x, b) {
            var S = x.style[b];
            return !S && x.currentStyle && (S = x.currentStyle[b]), S;
          }),
        (function () {
          var x = e.document.documentElement.style,
            b =
              "userSelect" in x
                ? "userSelect"
                : "MozUserSelect" in x
                ? "MozUserSelect"
                : "WebkitUserSelect" in x
                ? "WebkitUserSelect"
                : "KhtmlUserSelect" in x
                ? "KhtmlUserSelect"
                : "";
          function S(w) {
            return (
              typeof w.onselectstart < "u" &&
                (w.onselectstart = e.util.falseFunction),
              b
                ? (w.style[b] = "none")
                : typeof w.unselectable == "string" && (w.unselectable = "on"),
              w
            );
          }
          function T(w) {
            return (
              typeof w.onselectstart < "u" && (w.onselectstart = null),
              b
                ? (w.style[b] = "")
                : typeof w.unselectable == "string" && (w.unselectable = ""),
              w
            );
          }
          (e.util.makeElementUnselectable = S),
            (e.util.makeElementSelectable = T);
        })();
      function v(x) {
        var b = e.jsdomImplForWrapper(x);
        return b._canvas || b._image;
      }
      function y(x) {
        if (e.isLikelyNode) {
          var b = e.jsdomImplForWrapper(x);
          b &&
            ((b._image = null),
            (b._canvas = null),
            (b._currentSrc = null),
            (b._attributes = null),
            (b._classList = null));
        }
      }
      function _(x, b) {
        (x.imageSmoothingEnabled =
          x.imageSmoothingEnabled ||
          x.webkitImageSmoothingEnabled ||
          x.mozImageSmoothingEnabled ||
          x.msImageSmoothingEnabled ||
          x.oImageSmoothingEnabled),
          (x.imageSmoothingEnabled = b);
      }
      (e.util.setImageSmoothing = _),
        (e.util.getById = s),
        (e.util.toArray = d),
        (e.util.addClass = c),
        (e.util.makeElement = l),
        (e.util.wrapElement = h),
        (e.util.getScrollLeftTop = m),
        (e.util.getElementOffset = g),
        (e.util.getNodeCanvas = v),
        (e.util.cleanUpJsdomNode = y);
    })(),
    (function () {
      function a(d, l) {
        return d + (/\?/.test(d) ? "&" : "?") + l;
      }
      function s() {}
      function u(d, l) {
        l || (l = {});
        var c = l.method ? l.method.toUpperCase() : "GET",
          h = l.onComplete || function () {},
          m = new e.window.XMLHttpRequest(),
          g = l.body || l.parameters;
        return (
          (m.onreadystatechange = function () {
            m.readyState === 4 && (h(m), (m.onreadystatechange = s));
          }),
          c === "GET" &&
            ((g = null),
            typeof l.parameters == "string" && (d = a(d, l.parameters))),
          m.open(c, d, !0),
          (c === "POST" || c === "PUT") &&
            m.setRequestHeader(
              "Content-Type",
              "application/x-www-form-urlencoded"
            ),
          m.send(g),
          m
        );
      }
      e.util.request = u;
    })(),
    (e.log = console.log),
    (e.warn = console.warn),
    (function () {
      var a = e.util.object.extend,
        s = e.util.object.clone,
        u = [];
      e.util.object.extend(u, {
        cancelAll: function () {
          var v = this.splice(0);
          return (
            v.forEach(function (y) {
              y.cancel();
            }),
            v
          );
        },
        cancelByCanvas: function (v) {
          if (!v) return [];
          var y = this.filter(function (_) {
            return typeof _.target == "object" && _.target.canvas === v;
          });
          return (
            y.forEach(function (_) {
              _.cancel();
            }),
            y
          );
        },
        cancelByTarget: function (v) {
          var y = this.findAnimationsByTarget(v);
          return (
            y.forEach(function (_) {
              _.cancel();
            }),
            y
          );
        },
        findAnimationIndex: function (v) {
          return this.indexOf(this.findAnimation(v));
        },
        findAnimation: function (v) {
          return this.find(function (y) {
            return y.cancel === v;
          });
        },
        findAnimationsByTarget: function (v) {
          return v
            ? this.filter(function (y) {
                return y.target === v;
              })
            : [];
        },
      });
      function d() {
        return !1;
      }
      function l(v, y, _, x) {
        return -_ * Math.cos((v / x) * (Math.PI / 2)) + _ + y;
      }
      function c(v) {
        v || (v = {});
        var y = !1,
          _,
          x = function () {
            var b = e.runningAnimations.indexOf(_);
            return b > -1 && e.runningAnimations.splice(b, 1)[0];
          };
        return (
          (_ = a(s(v), {
            cancel: function () {
              return (y = !0), x();
            },
            currentValue: "startValue" in v ? v.startValue : 0,
            completionRate: 0,
            durationRate: 0,
          })),
          e.runningAnimations.push(_),
          g(function (b) {
            var S = b || +new Date(),
              T = v.duration || 500,
              w = S + T,
              P,
              F = v.onChange || d,
              V = v.abort || d,
              J = v.onComplete || d,
              z = v.easing || l,
              B = "startValue" in v ? v.startValue.length > 0 : !1,
              G = "startValue" in v ? v.startValue : 0,
              ie = "endValue" in v ? v.endValue : 100,
              re =
                v.byValue ||
                (B
                  ? G.map(function (j, C) {
                      return ie[C] - G[C];
                    })
                  : ie - G);
            v.onStart && v.onStart(),
              (function j(C) {
                P = C || +new Date();
                var R = P > w ? T : P - S,
                  A = R / T,
                  O = B
                    ? G.map(function (I, E) {
                        return z(R, G[E], re[E], T);
                      })
                    : z(R, G, re, T),
                  H = Math.abs(B ? (O[0] - G[0]) / re[0] : (O - G) / re);
                if (
                  ((_.currentValue = B ? O.slice() : O),
                  (_.completionRate = H),
                  (_.durationRate = A),
                  !y)
                ) {
                  if (V(O, H, A)) {
                    x();
                    return;
                  }
                  if (P > w) {
                    (_.currentValue = B ? ie.slice() : ie),
                      (_.completionRate = 1),
                      (_.durationRate = 1),
                      F(B ? ie.slice() : ie, 1, 1),
                      J(ie, 1, 1),
                      x();
                    return;
                  } else F(O, H, A), g(j);
                }
              })(S);
          }),
          _.cancel
        );
      }
      var h =
          e.window.requestAnimationFrame ||
          e.window.webkitRequestAnimationFrame ||
          e.window.mozRequestAnimationFrame ||
          e.window.oRequestAnimationFrame ||
          e.window.msRequestAnimationFrame ||
          function (v) {
            return e.window.setTimeout(v, 1e3 / 60);
          },
        m = e.window.cancelAnimationFrame || e.window.clearTimeout;
      function g() {
        return h.apply(e.window, arguments);
      }
      function f() {
        return m.apply(e.window, arguments);
      }
      (e.util.animate = c),
        (e.util.requestAnimFrame = g),
        (e.util.cancelAnimFrame = f),
        (e.runningAnimations = u);
    })(),
    (function () {
      function a(u, d, l) {
        var c =
          "rgba(" +
          parseInt(u[0] + l * (d[0] - u[0]), 10) +
          "," +
          parseInt(u[1] + l * (d[1] - u[1]), 10) +
          "," +
          parseInt(u[2] + l * (d[2] - u[2]), 10);
        return (
          (c += "," + (u && d ? parseFloat(u[3] + l * (d[3] - u[3])) : 1)),
          (c += ")"),
          c
        );
      }
      function s(u, d, l, c) {
        var h = new e.Color(u).getSource(),
          m = new e.Color(d).getSource(),
          g = c.onComplete,
          f = c.onChange;
        return (
          (c = c || {}),
          e.util.animate(
            e.util.object.extend(c, {
              duration: l || 500,
              startValue: h,
              endValue: m,
              byValue: m,
              easing: function (v, y, _, x) {
                var b = c.colorEasing
                  ? c.colorEasing(v, x)
                  : 1 - Math.cos((v / x) * (Math.PI / 2));
                return a(y, _, b);
              },
              onComplete: function (v, y, _) {
                if (g) return g(a(m, m, 0), y, _);
              },
              onChange: function (v, y, _) {
                if (f) {
                  if (Array.isArray(v)) return f(a(v, v, 0), y, _);
                  f(v, y, _);
                }
              },
            })
          )
        );
      }
      e.util.animateColor = s;
    })(),
    (function () {
      function a(C, R, A, O) {
        return (
          C < Math.abs(R)
            ? ((C = R), (O = A / 4))
            : R === 0 && C === 0
            ? (O = (A / (2 * Math.PI)) * Math.asin(1))
            : (O = (A / (2 * Math.PI)) * Math.asin(R / C)),
          { a: C, c: R, p: A, s: O }
        );
      }
      function s(C, R, A) {
        return (
          C.a *
          Math.pow(2, 10 * (R -= 1)) *
          Math.sin(((R * A - C.s) * (2 * Math.PI)) / C.p)
        );
      }
      function u(C, R, A, O) {
        return A * ((C = C / O - 1) * C * C + 1) + R;
      }
      function d(C, R, A, O) {
        return (
          (C /= O / 2),
          C < 1 ? (A / 2) * C * C * C + R : (A / 2) * ((C -= 2) * C * C + 2) + R
        );
      }
      function l(C, R, A, O) {
        return A * (C /= O) * C * C * C + R;
      }
      function c(C, R, A, O) {
        return -A * ((C = C / O - 1) * C * C * C - 1) + R;
      }
      function h(C, R, A, O) {
        return (
          (C /= O / 2),
          C < 1
            ? (A / 2) * C * C * C * C + R
            : (-A / 2) * ((C -= 2) * C * C * C - 2) + R
        );
      }
      function m(C, R, A, O) {
        return A * (C /= O) * C * C * C * C + R;
      }
      function g(C, R, A, O) {
        return A * ((C = C / O - 1) * C * C * C * C + 1) + R;
      }
      function f(C, R, A, O) {
        return (
          (C /= O / 2),
          C < 1
            ? (A / 2) * C * C * C * C * C + R
            : (A / 2) * ((C -= 2) * C * C * C * C + 2) + R
        );
      }
      function v(C, R, A, O) {
        return -A * Math.cos((C / O) * (Math.PI / 2)) + A + R;
      }
      function y(C, R, A, O) {
        return A * Math.sin((C / O) * (Math.PI / 2)) + R;
      }
      function _(C, R, A, O) {
        return (-A / 2) * (Math.cos((Math.PI * C) / O) - 1) + R;
      }
      function x(C, R, A, O) {
        return C === 0 ? R : A * Math.pow(2, 10 * (C / O - 1)) + R;
      }
      function b(C, R, A, O) {
        return C === O ? R + A : A * (-Math.pow(2, (-10 * C) / O) + 1) + R;
      }
      function S(C, R, A, O) {
        return C === 0
          ? R
          : C === O
          ? R + A
          : ((C /= O / 2),
            C < 1
              ? (A / 2) * Math.pow(2, 10 * (C - 1)) + R
              : (A / 2) * (-Math.pow(2, -10 * --C) + 2) + R);
      }
      function T(C, R, A, O) {
        return -A * (Math.sqrt(1 - (C /= O) * C) - 1) + R;
      }
      function w(C, R, A, O) {
        return A * Math.sqrt(1 - (C = C / O - 1) * C) + R;
      }
      function P(C, R, A, O) {
        return (
          (C /= O / 2),
          C < 1
            ? (-A / 2) * (Math.sqrt(1 - C * C) - 1) + R
            : (A / 2) * (Math.sqrt(1 - (C -= 2) * C) + 1) + R
        );
      }
      function F(C, R, A, O) {
        var H = 1.70158,
          I = 0,
          E = A;
        if (C === 0) return R;
        if (((C /= O), C === 1)) return R + A;
        I || (I = O * 0.3);
        var k = a(E, A, I, H);
        return -s(k, C, O) + R;
      }
      function V(C, R, A, O) {
        var H = 1.70158,
          I = 0,
          E = A;
        if (C === 0) return R;
        if (((C /= O), C === 1)) return R + A;
        I || (I = O * 0.3);
        var k = a(E, A, I, H);
        return (
          k.a *
            Math.pow(2, -10 * C) *
            Math.sin(((C * O - k.s) * (2 * Math.PI)) / k.p) +
          k.c +
          R
        );
      }
      function J(C, R, A, O) {
        var H = 1.70158,
          I = 0,
          E = A;
        if (C === 0) return R;
        if (((C /= O / 2), C === 2)) return R + A;
        I || (I = O * (0.3 * 1.5));
        var k = a(E, A, I, H);
        return C < 1
          ? -0.5 * s(k, C, O) + R
          : k.a *
              Math.pow(2, -10 * (C -= 1)) *
              Math.sin(((C * O - k.s) * (2 * Math.PI)) / k.p) *
              0.5 +
              k.c +
              R;
      }
      function z(C, R, A, O, H) {
        return (
          H === void 0 && (H = 1.70158),
          A * (C /= O) * C * ((H + 1) * C - H) + R
        );
      }
      function B(C, R, A, O, H) {
        return (
          H === void 0 && (H = 1.70158),
          A * ((C = C / O - 1) * C * ((H + 1) * C + H) + 1) + R
        );
      }
      function G(C, R, A, O, H) {
        return (
          H === void 0 && (H = 1.70158),
          (C /= O / 2),
          C < 1
            ? (A / 2) * (C * C * (((H *= 1.525) + 1) * C - H)) + R
            : (A / 2) * ((C -= 2) * C * (((H *= 1.525) + 1) * C + H) + 2) + R
        );
      }
      function ie(C, R, A, O) {
        return A - re(O - C, 0, A, O) + R;
      }
      function re(C, R, A, O) {
        return (C /= O) < 1 / 2.75
          ? A * (7.5625 * C * C) + R
          : C < 2 / 2.75
          ? A * (7.5625 * (C -= 1.5 / 2.75) * C + 0.75) + R
          : C < 2.5 / 2.75
          ? A * (7.5625 * (C -= 2.25 / 2.75) * C + 0.9375) + R
          : A * (7.5625 * (C -= 2.625 / 2.75) * C + 0.984375) + R;
      }
      function j(C, R, A, O) {
        return C < O / 2
          ? ie(C * 2, 0, A, O) * 0.5 + R
          : re(C * 2 - O, 0, A, O) * 0.5 + A * 0.5 + R;
      }
      e.util.ease = {
        easeInQuad: function (C, R, A, O) {
          return A * (C /= O) * C + R;
        },
        easeOutQuad: function (C, R, A, O) {
          return -A * (C /= O) * (C - 2) + R;
        },
        easeInOutQuad: function (C, R, A, O) {
          return (
            (C /= O / 2),
            C < 1 ? (A / 2) * C * C + R : (-A / 2) * (--C * (C - 2) - 1) + R
          );
        },
        easeInCubic: function (C, R, A, O) {
          return A * (C /= O) * C * C + R;
        },
        easeOutCubic: u,
        easeInOutCubic: d,
        easeInQuart: l,
        easeOutQuart: c,
        easeInOutQuart: h,
        easeInQuint: m,
        easeOutQuint: g,
        easeInOutQuint: f,
        easeInSine: v,
        easeOutSine: y,
        easeInOutSine: _,
        easeInExpo: x,
        easeOutExpo: b,
        easeInOutExpo: S,
        easeInCirc: T,
        easeOutCirc: w,
        easeInOutCirc: P,
        easeInElastic: F,
        easeOutElastic: V,
        easeInOutElastic: J,
        easeInBack: z,
        easeOutBack: B,
        easeInOutBack: G,
        easeInBounce: ie,
        easeOutBounce: re,
        easeInOutBounce: j,
      };
    })(),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.extend,
        d = s.util.object.clone,
        l = s.util.toFixed,
        c = s.util.parseUnit,
        h = s.util.multiplyTransformMatrices,
        m = [
          "path",
          "circle",
          "polygon",
          "polyline",
          "ellipse",
          "rect",
          "line",
          "image",
          "text",
        ],
        g = ["symbol", "image", "marker", "pattern", "view", "svg"],
        f = [
          "pattern",
          "defs",
          "symbol",
          "metadata",
          "clipPath",
          "mask",
          "desc",
        ],
        v = ["symbol", "g", "a", "svg", "clipPath", "defs"],
        y = {
          cx: "left",
          x: "left",
          r: "radius",
          cy: "top",
          y: "top",
          display: "visible",
          visibility: "visible",
          transform: "transformMatrix",
          "fill-opacity": "fillOpacity",
          "fill-rule": "fillRule",
          "font-family": "fontFamily",
          "font-size": "fontSize",
          "font-style": "fontStyle",
          "font-weight": "fontWeight",
          "letter-spacing": "charSpacing",
          "paint-order": "paintFirst",
          "stroke-dasharray": "strokeDashArray",
          "stroke-dashoffset": "strokeDashOffset",
          "stroke-linecap": "strokeLineCap",
          "stroke-linejoin": "strokeLineJoin",
          "stroke-miterlimit": "strokeMiterLimit",
          "stroke-opacity": "strokeOpacity",
          "stroke-width": "strokeWidth",
          "text-decoration": "textDecoration",
          "text-anchor": "textAnchor",
          opacity: "opacity",
          "clip-path": "clipPath",
          "clip-rule": "clipRule",
          "vector-effect": "strokeUniform",
          "image-rendering": "imageSmoothing",
        },
        _ = { stroke: "strokeOpacity", fill: "fillOpacity" },
        x = "font-size",
        b = "clip-path";
      (s.svgValidTagNamesRegEx = w(m)),
        (s.svgViewBoxElementsRegEx = w(g)),
        (s.svgInvalidAncestorsRegEx = w(f)),
        (s.svgValidParentsRegEx = w(v)),
        (s.cssRules = {}),
        (s.gradientDefs = {}),
        (s.clipPaths = {});
      function S(I) {
        return I in y ? y[I] : I;
      }
      function T(I, E, k, $) {
        var Y = Array.isArray(E),
          X;
        if ((I === "fill" || I === "stroke") && E === "none") E = "";
        else {
          if (I === "strokeUniform") return E === "non-scaling-stroke";
          if (I === "strokeDashArray")
            E === "none"
              ? (E = null)
              : (E = E.replace(/,/g, " ").split(/\s+/).map(parseFloat));
          else if (I === "transformMatrix")
            k && k.transformMatrix
              ? (E = h(k.transformMatrix, s.parseTransformAttribute(E)))
              : (E = s.parseTransformAttribute(E));
          else if (I === "visible")
            (E = E !== "none" && E !== "hidden"),
              k && k.visible === !1 && (E = !1);
          else if (I === "opacity")
            (E = parseFloat(E)),
              k && typeof k.opacity < "u" && (E *= k.opacity);
          else if (I === "textAnchor")
            E = E === "start" ? "left" : E === "end" ? "right" : "center";
          else if (I === "charSpacing") X = (c(E, $) / $) * 1e3;
          else if (I === "paintFirst") {
            var ee = E.indexOf("fill"),
              he = E.indexOf("stroke"),
              E = "fill";
            ((ee > -1 && he > -1 && he < ee) || (ee === -1 && he > -1)) &&
              (E = "stroke");
          } else {
            if (I === "href" || I === "xlink:href" || I === "font") return E;
            if (I === "imageSmoothing") return E === "optimizeQuality";
            X = Y ? E.map(c) : c(E, $);
          }
        }
        return !Y && isNaN(X) ? E : X;
      }
      function w(I) {
        return new RegExp("^(" + I.join("|") + ")\\b", "i");
      }
      function P(I) {
        for (var E in _)
          if (!(typeof I[_[E]] > "u" || I[E] === "")) {
            if (typeof I[E] > "u") {
              if (!s.Object.prototype[E]) continue;
              I[E] = s.Object.prototype[E];
            }
            if (I[E].indexOf("url(") !== 0) {
              var k = new s.Color(I[E]);
              I[E] = k.setAlpha(l(k.getAlpha() * I[_[E]], 2)).toRgba();
            }
          }
        return I;
      }
      function F(I, E) {
        var k,
          $ = [],
          Y,
          X,
          ee;
        for (X = 0, ee = E.length; X < ee; X++)
          (k = E[X]),
            (Y = I.getElementsByTagName(k)),
            ($ = $.concat(Array.prototype.slice.call(Y)));
        return $;
      }
      s.parseTransformAttribute = (function () {
        function I(L, D) {
          var ne = s.util.cos(D[0]),
            de = s.util.sin(D[0]),
            ye = 0,
            _e = 0;
          D.length === 3 && ((ye = D[1]), (_e = D[2])),
            (L[0] = ne),
            (L[1] = de),
            (L[2] = -de),
            (L[3] = ne),
            (L[4] = ye - (ne * ye - de * _e)),
            (L[5] = _e - (de * ye + ne * _e));
        }
        function E(L, D) {
          var ne = D[0],
            de = D.length === 2 ? D[1] : D[0];
          (L[0] = ne), (L[3] = de);
        }
        function k(L, D, ne) {
          L[ne] = Math.tan(s.util.degreesToRadians(D[0]));
        }
        function $(L, D) {
          (L[4] = D[0]), D.length === 2 && (L[5] = D[1]);
        }
        var Y = s.iMatrix,
          X = s.reNum,
          ee = s.commaWsp,
          he = "(?:(skewX)\\s*\\(\\s*(" + X + ")\\s*\\))",
          pe = "(?:(skewY)\\s*\\(\\s*(" + X + ")\\s*\\))",
          Z =
            "(?:(rotate)\\s*\\(\\s*(" +
            X +
            ")(?:" +
            ee +
            "(" +
            X +
            ")" +
            ee +
            "(" +
            X +
            "))?\\s*\\))",
          K =
            "(?:(scale)\\s*\\(\\s*(" +
            X +
            ")(?:" +
            ee +
            "(" +
            X +
            "))?\\s*\\))",
          ce =
            "(?:(translate)\\s*\\(\\s*(" +
            X +
            ")(?:" +
            ee +
            "(" +
            X +
            "))?\\s*\\))",
          ue =
            "(?:(matrix)\\s*\\(\\s*(" +
            X +
            ")" +
            ee +
            "(" +
            X +
            ")" +
            ee +
            "(" +
            X +
            ")" +
            ee +
            "(" +
            X +
            ")" +
            ee +
            "(" +
            X +
            ")" +
            ee +
            "(" +
            X +
            ")\\s*\\))",
          oe =
            "(?:" +
            ue +
            "|" +
            ce +
            "|" +
            K +
            "|" +
            Z +
            "|" +
            he +
            "|" +
            pe +
            ")",
          le = "(?:" + oe + "(?:" + ee + "*" + oe + ")*)",
          ge = "^\\s*(?:" + le + "?)\\s*$",
          Re = new RegExp(ge),
          Me = new RegExp(oe, "g");
        return function (L) {
          var D = Y.concat(),
            ne = [];
          if (!L || (L && !Re.test(L))) return D;
          L.replace(Me, function (ye) {
            var _e = new RegExp(oe).exec(ye).filter(function (te) {
                return !!te;
              }),
              Pe = _e[1],
              U = _e.slice(2).map(parseFloat);
            switch (Pe) {
              case "translate":
                $(D, U);
                break;
              case "rotate":
                (U[0] = s.util.degreesToRadians(U[0])), I(D, U);
                break;
              case "scale":
                E(D, U);
                break;
              case "skewX":
                k(D, U, 2);
                break;
              case "skewY":
                k(D, U, 1);
                break;
              case "matrix":
                D = U;
                break;
            }
            ne.push(D.concat()), (D = Y.concat());
          });
          for (var de = ne[0]; ne.length > 1; )
            ne.shift(), (de = s.util.multiplyTransformMatrices(de, ne[0]));
          return de;
        };
      })();
      function V(I, E) {
        var k, $;
        I.replace(/;\s*$/, "")
          .split(";")
          .forEach(function (Y) {
            var X = Y.split(":");
            (k = X[0].trim().toLowerCase()), ($ = X[1].trim()), (E[k] = $);
          });
      }
      function J(I, E) {
        var k, $;
        for (var Y in I)
          typeof I[Y] > "u" || ((k = Y.toLowerCase()), ($ = I[Y]), (E[k] = $));
      }
      function z(I, E) {
        var k = {};
        for (var $ in s.cssRules[E])
          if (B(I, $.split(" ")))
            for (var Y in s.cssRules[E][$]) k[Y] = s.cssRules[E][$][Y];
        return k;
      }
      function B(I, E) {
        var k,
          $ = !0;
        return (
          (k = ie(I, E.pop())),
          k && E.length && ($ = G(I, E)),
          k && $ && E.length === 0
        );
      }
      function G(I, E) {
        for (
          var k, $ = !0;
          I.parentNode && I.parentNode.nodeType === 1 && E.length;

        )
          $ && (k = E.pop()), (I = I.parentNode), ($ = ie(I, k));
        return E.length === 0;
      }
      function ie(I, E) {
        var k = I.nodeName,
          $ = I.getAttribute("class"),
          Y = I.getAttribute("id"),
          X,
          ee;
        if (
          ((X = new RegExp("^" + k, "i")),
          (E = E.replace(X, "")),
          Y &&
            E.length &&
            ((X = new RegExp("#" + Y + "(?![a-zA-Z\\-]+)", "i")),
            (E = E.replace(X, ""))),
          $ && E.length)
        )
          for ($ = $.split(" "), ee = $.length; ee--; )
            (X = new RegExp("\\." + $[ee] + "(?![a-zA-Z\\-]+)", "i")),
              (E = E.replace(X, ""));
        return E.length === 0;
      }
      function re(I, E) {
        var k;
        if ((I.getElementById && (k = I.getElementById(E)), k)) return k;
        var $,
          Y,
          X,
          ee = I.getElementsByTagName("*");
        for (Y = 0, X = ee.length; Y < X; Y++)
          if ((($ = ee[Y]), E === $.getAttribute("id"))) return $;
      }
      function j(I) {
        for (
          var E = F(I, ["use", "svg:use"]), k = 0;
          E.length && k < E.length;

        ) {
          var $ = E[k],
            Y = $.getAttribute("xlink:href") || $.getAttribute("href");
          if (Y === null) return;
          var X = Y.slice(1),
            ee = $.getAttribute("x") || 0,
            he = $.getAttribute("y") || 0,
            pe = re(I, X).cloneNode(!0),
            Z =
              (pe.getAttribute("transform") || "") +
              " translate(" +
              ee +
              ", " +
              he +
              ")",
            K,
            ce = E.length,
            ue,
            oe,
            le,
            ge,
            Re = s.svgNS;
          if ((R(pe), /^svg$/i.test(pe.nodeName))) {
            var Me = pe.ownerDocument.createElementNS(Re, "g");
            for (oe = 0, le = pe.attributes, ge = le.length; oe < ge; oe++)
              (ue = le.item(oe)),
                Me.setAttributeNS(Re, ue.nodeName, ue.nodeValue);
            for (; pe.firstChild; ) Me.appendChild(pe.firstChild);
            pe = Me;
          }
          for (oe = 0, le = $.attributes, ge = le.length; oe < ge; oe++)
            (ue = le.item(oe)),
              !(
                ue.nodeName === "x" ||
                ue.nodeName === "y" ||
                ue.nodeName === "xlink:href" ||
                ue.nodeName === "href"
              ) &&
                (ue.nodeName === "transform"
                  ? (Z = ue.nodeValue + " " + Z)
                  : pe.setAttribute(ue.nodeName, ue.nodeValue));
          pe.setAttribute("transform", Z),
            pe.setAttribute("instantiated_by_use", "1"),
            pe.removeAttribute("id"),
            (K = $.parentNode),
            K.replaceChild(pe, $),
            E.length === ce && k++;
        }
      }
      var C = new RegExp(
        "^\\s*(" +
          s.reNum +
          "+)\\s*,?\\s*(" +
          s.reNum +
          "+)\\s*,?\\s*(" +
          s.reNum +
          "+)\\s*,?\\s*(" +
          s.reNum +
          "+)\\s*$"
      );
      function R(I) {
        if (!s.svgViewBoxElementsRegEx.test(I.nodeName)) return {};
        var E = I.getAttribute("viewBox"),
          k = 1,
          $ = 1,
          Y = 0,
          X = 0,
          ee,
          he,
          pe,
          Z,
          K = I.getAttribute("width"),
          ce = I.getAttribute("height"),
          ue = I.getAttribute("x") || 0,
          oe = I.getAttribute("y") || 0,
          le = I.getAttribute("preserveAspectRatio") || "",
          ge = !E || !(E = E.match(C)),
          Re = !K || !ce || K === "100%" || ce === "100%",
          Me = ge && Re,
          L = {},
          D = "",
          ne = 0,
          de = 0;
        if (
          ((L.width = 0),
          (L.height = 0),
          (L.toBeParsed = Me),
          ge &&
            (ue || oe) &&
            I.parentNode &&
            I.parentNode.nodeName !== "#document" &&
            ((D = " translate(" + c(ue) + " " + c(oe) + ") "),
            (pe = (I.getAttribute("transform") || "") + D),
            I.setAttribute("transform", pe),
            I.removeAttribute("x"),
            I.removeAttribute("y")),
          Me)
        )
          return L;
        if (ge) return (L.width = c(K)), (L.height = c(ce)), L;
        if (
          ((Y = -parseFloat(E[1])),
          (X = -parseFloat(E[2])),
          (ee = parseFloat(E[3])),
          (he = parseFloat(E[4])),
          (L.minX = Y),
          (L.minY = X),
          (L.viewBoxWidth = ee),
          (L.viewBoxHeight = he),
          Re
            ? ((L.width = ee), (L.height = he))
            : ((L.width = c(K)),
              (L.height = c(ce)),
              (k = L.width / ee),
              ($ = L.height / he)),
          (le = s.util.parsePreserveAspectRatioAttribute(le)),
          le.alignX !== "none" &&
            (le.meetOrSlice === "meet" && ($ = k = k > $ ? $ : k),
            le.meetOrSlice === "slice" && ($ = k = k > $ ? k : $),
            (ne = L.width - ee * k),
            (de = L.height - he * k),
            le.alignX === "Mid" && (ne /= 2),
            le.alignY === "Mid" && (de /= 2),
            le.alignX === "Min" && (ne = 0),
            le.alignY === "Min" && (de = 0)),
          k === 1 && $ === 1 && Y === 0 && X === 0 && ue === 0 && oe === 0)
        )
          return L;
        if (
          ((ue || oe) &&
            I.parentNode.nodeName !== "#document" &&
            (D = " translate(" + c(ue) + " " + c(oe) + ") "),
          (pe =
            D +
            " matrix(" +
            k +
            " 0 0 " +
            $ +
            " " +
            (Y * k + ne) +
            " " +
            (X * $ + de) +
            ") "),
          I.nodeName === "svg")
        ) {
          for (
            Z = I.ownerDocument.createElementNS(s.svgNS, "g");
            I.firstChild;

          )
            Z.appendChild(I.firstChild);
          I.appendChild(Z);
        } else
          (Z = I),
            Z.removeAttribute("x"),
            Z.removeAttribute("y"),
            (pe = Z.getAttribute("transform") + pe);
        return Z.setAttribute("transform", pe), L;
      }
      function A(I, E) {
        for (; I && (I = I.parentNode); )
          if (
            I.nodeName &&
            E.test(I.nodeName.replace("svg:", "")) &&
            !I.getAttribute("instantiated_by_use")
          )
            return !0;
        return !1;
      }
      s.parseSVGDocument = function (I, E, k, $) {
        if (I) {
          j(I);
          var Y = s.Object.__uid++,
            X,
            ee,
            he = R(I),
            pe = s.util.toArray(I.getElementsByTagName("*"));
          if (
            ((he.crossOrigin = $ && $.crossOrigin),
            (he.svgUid = Y),
            pe.length === 0 && s.isLikelyNode)
          ) {
            pe = I.selectNodes('//*[name(.)!="svg"]');
            var Z = [];
            for (X = 0, ee = pe.length; X < ee; X++) Z[X] = pe[X];
            pe = Z;
          }
          var K = pe.filter(function (ue) {
            return (
              R(ue),
              s.svgValidTagNamesRegEx.test(ue.nodeName.replace("svg:", "")) &&
                !A(ue, s.svgInvalidAncestorsRegEx)
            );
          });
          if (!K || (K && !K.length)) {
            E && E([], {});
            return;
          }
          var ce = {};
          pe
            .filter(function (ue) {
              return ue.nodeName.replace("svg:", "") === "clipPath";
            })
            .forEach(function (ue) {
              var oe = ue.getAttribute("id");
              ce[oe] = s.util
                .toArray(ue.getElementsByTagName("*"))
                .filter(function (le) {
                  return s.svgValidTagNamesRegEx.test(
                    le.nodeName.replace("svg:", "")
                  );
                });
            }),
            (s.gradientDefs[Y] = s.getGradientDefs(I)),
            (s.cssRules[Y] = s.getCSSRules(I)),
            (s.clipPaths[Y] = ce),
            s.parseElements(
              K,
              function (ue, oe) {
                E &&
                  (E(ue, he, oe, pe),
                  delete s.gradientDefs[Y],
                  delete s.cssRules[Y],
                  delete s.clipPaths[Y]);
              },
              d(he),
              k,
              $
            );
        }
      };
      function O(I, E) {
        var k = [
            "gradientTransform",
            "x1",
            "x2",
            "y1",
            "y2",
            "gradientUnits",
            "cx",
            "cy",
            "r",
            "fx",
            "fy",
          ],
          $ = "xlink:href",
          Y = E.getAttribute($).slice(1),
          X = re(I, Y);
        if (
          (X && X.getAttribute($) && O(I, X),
          k.forEach(function (he) {
            X &&
              !E.hasAttribute(he) &&
              X.hasAttribute(he) &&
              E.setAttribute(he, X.getAttribute(he));
          }),
          !E.children.length)
        )
          for (var ee = X.cloneNode(!0); ee.firstChild; )
            E.appendChild(ee.firstChild);
        E.removeAttribute($);
      }
      var H = new RegExp(
        "(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" +
          s.reNum +
          "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" +
          s.reNum +
          "))?\\s+(.*)"
      );
      u(s, {
        parseFontDeclaration: function (I, E) {
          var k = I.match(H);
          if (k) {
            var $ = k[1],
              Y = k[3],
              X = k[4],
              ee = k[5],
              he = k[6];
            $ && (E.fontStyle = $),
              Y && (E.fontWeight = isNaN(parseFloat(Y)) ? Y : parseFloat(Y)),
              X && (E.fontSize = c(X)),
              he && (E.fontFamily = he),
              ee && (E.lineHeight = ee === "normal" ? 1 : ee);
          }
        },
        getGradientDefs: function (I) {
          var E = [
              "linearGradient",
              "radialGradient",
              "svg:linearGradient",
              "svg:radialGradient",
            ],
            k = F(I, E),
            $,
            Y = 0,
            X = {};
          for (Y = k.length; Y--; )
            ($ = k[Y]),
              $.getAttribute("xlink:href") && O(I, $),
              (X[$.getAttribute("id")] = $);
          return X;
        },
        parseAttributes: function (I, E, k) {
          if (I) {
            var $,
              Y = {},
              X,
              ee;
            typeof k > "u" && (k = I.getAttribute("svgUid")),
              I.parentNode &&
                s.svgValidParentsRegEx.test(I.parentNode.nodeName) &&
                (Y = s.parseAttributes(I.parentNode, E, k));
            var he = E.reduce(function (le, ge) {
                return ($ = I.getAttribute(ge)), $ && (le[ge] = $), le;
              }, {}),
              pe = u(z(I, k), s.parseStyleAttribute(I));
            (he = u(he, pe)),
              pe[b] && I.setAttribute(b, pe[b]),
              (X = ee = Y.fontSize || s.Text.DEFAULT_SVG_FONT_SIZE),
              he[x] && (he[x] = X = c(he[x], ee));
            var Z,
              K,
              ce = {};
            for (var ue in he)
              (Z = S(ue)), (K = T(Z, he[ue], Y, X)), (ce[Z] = K);
            ce && ce.font && s.parseFontDeclaration(ce.font, ce);
            var oe = u(Y, ce);
            return s.svgValidParentsRegEx.test(I.nodeName) ? oe : P(oe);
          }
        },
        parseElements: function (I, E, k, $, Y) {
          new s.ElementsParser(I, E, k, $, Y).parse();
        },
        parseStyleAttribute: function (I) {
          var E = {},
            k = I.getAttribute("style");
          return k && (typeof k == "string" ? V(k, E) : J(k, E)), E;
        },
        parsePointsAttribute: function (I) {
          if (!I) return null;
          (I = I.replace(/,/g, " ").trim()), (I = I.split(/\s+/));
          var E = [],
            k,
            $;
          for (k = 0, $ = I.length; k < $; k += 2)
            E.push({ x: parseFloat(I[k]), y: parseFloat(I[k + 1]) });
          return E;
        },
        getCSSRules: function (I) {
          var E = I.getElementsByTagName("style"),
            k,
            $,
            Y = {},
            X;
          for (k = 0, $ = E.length; k < $; k++) {
            var ee = E[k].textContent;
            (ee = ee.replace(/\/\*[\s\S]*?\*\//g, "")),
              ee.trim() !== "" &&
                ((X = ee.split("}")),
                (X = X.filter(function (he) {
                  return he.trim();
                })),
                X.forEach(function (he) {
                  var pe = he.split("{"),
                    Z = {},
                    K = pe[1].trim(),
                    ce = K.split(";").filter(function (ge) {
                      return ge.trim();
                    });
                  for (k = 0, $ = ce.length; k < $; k++) {
                    var ue = ce[k].split(":"),
                      oe = ue[0].trim(),
                      le = ue[1].trim();
                    Z[oe] = le;
                  }
                  (he = pe[0].trim()),
                    he.split(",").forEach(function (ge) {
                      (ge = ge.replace(/^svg/i, "").trim()),
                        ge !== "" &&
                          (Y[ge]
                            ? s.util.object.extend(Y[ge], Z)
                            : (Y[ge] = s.util.object.clone(Z)));
                    });
                }));
          }
          return Y;
        },
        loadSVGFromURL: function (I, E, k, $) {
          (I = I.replace(/^\n\s*/, "").trim()),
            new s.util.request(I, { method: "get", onComplete: Y });
          function Y(X) {
            var ee = X.responseXML;
            if (!ee || !ee.documentElement) return E && E(null), !1;
            s.parseSVGDocument(
              ee.documentElement,
              function (he, pe, Z, K) {
                E && E(he, pe, Z, K);
              },
              k,
              $
            );
          }
        },
        loadSVGFromString: function (I, E, k, $) {
          var Y = new s.window.DOMParser(),
            X = Y.parseFromString(I.trim(), "text/xml");
          s.parseSVGDocument(
            X.documentElement,
            function (ee, he, pe, Z) {
              E(ee, he, pe, Z);
            },
            k,
            $
          );
        },
      });
    })(n),
    (e.ElementsParser = function (a, s, u, d, l, c) {
      (this.elements = a),
        (this.callback = s),
        (this.options = u),
        (this.reviver = d),
        (this.svgUid = (u && u.svgUid) || 0),
        (this.parsingOptions = l),
        (this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g),
        (this.doc = c);
    }),
    (function (a) {
      (a.parse = function () {
        (this.instances = new Array(this.elements.length)),
          (this.numElements = this.elements.length),
          this.createObjects();
      }),
        (a.createObjects = function () {
          var s = this;
          this.elements.forEach(function (u, d) {
            u.setAttribute("svgUid", s.svgUid), s.createObject(u, d);
          });
        }),
        (a.findTag = function (s) {
          return e[e.util.string.capitalize(s.tagName.replace("svg:", ""))];
        }),
        (a.createObject = function (s, u) {
          var d = this.findTag(s);
          if (d && d.fromElement)
            try {
              d.fromElement(s, this.createCallback(u, s), this.options);
            } catch (l) {
              e.log(l);
            }
          else this.checkIfDone();
        }),
        (a.createCallback = function (s, u) {
          var d = this;
          return function (l) {
            var c;
            d.resolveGradient(l, u, "fill"),
              d.resolveGradient(l, u, "stroke"),
              l instanceof e.Image &&
                l._originalElement &&
                (c = l.parsePreserveAspectRatioAttribute(u)),
              l._removeTransformMatrix(c),
              d.resolveClipPath(l, u),
              d.reviver && d.reviver(u, l),
              (d.instances[s] = l),
              d.checkIfDone();
          };
        }),
        (a.extractPropertyDefinition = function (s, u, d) {
          var l = s[u],
            c = this.regexUrl;
          if (c.test(l)) {
            c.lastIndex = 0;
            var h = c.exec(l)[1];
            return (c.lastIndex = 0), e[d][this.svgUid][h];
          }
        }),
        (a.resolveGradient = function (s, u, d) {
          var l = this.extractPropertyDefinition(s, d, "gradientDefs");
          if (l) {
            var c = u.getAttribute(d + "-opacity"),
              h = e.Gradient.fromElement(l, s, c, this.options);
            s.set(d, h);
          }
        }),
        (a.createClipPathCallback = function (s, u) {
          return function (d) {
            d._removeTransformMatrix(), (d.fillRule = d.clipRule), u.push(d);
          };
        }),
        (a.resolveClipPath = function (s, u) {
          var d = this.extractPropertyDefinition(s, "clipPath", "clipPaths"),
            l,
            c,
            h,
            m,
            g,
            f;
          if (d) {
            (m = []), (h = e.util.invertTransform(s.calcTransformMatrix()));
            for (
              var v = d[0].parentNode, y = u;
              y.parentNode && y.getAttribute("clip-path") !== s.clipPath;

            )
              y = y.parentNode;
            y.parentNode.appendChild(v);
            for (var _ = 0; _ < d.length; _++)
              (l = d[_]),
                (c = this.findTag(l)),
                c.fromElement(
                  l,
                  this.createClipPathCallback(s, m),
                  this.options
                );
            m.length === 1 ? (d = m[0]) : (d = new e.Group(m)),
              (g = e.util.multiplyTransformMatrices(
                h,
                d.calcTransformMatrix()
              )),
              d.clipPath && this.resolveClipPath(d, y);
            var f = e.util.qrDecompose(g);
            (d.flipX = !1),
              (d.flipY = !1),
              d.set("scaleX", f.scaleX),
              d.set("scaleY", f.scaleY),
              (d.angle = f.angle),
              (d.skewX = f.skewX),
              (d.skewY = 0),
              d.setPositionByOrigin(
                { x: f.translateX, y: f.translateY },
                "center",
                "center"
              ),
              (s.clipPath = d);
          } else delete s.clipPath;
        }),
        (a.checkIfDone = function () {
          --this.numElements === 0 &&
            ((this.instances = this.instances.filter(function (s) {
              return s != null;
            })),
            this.callback(this.instances, this.elements));
        });
    })(e.ElementsParser.prototype),
    (function (a) {
      var s = a.fabric || (a.fabric = {});
      if (s.Point) {
        s.warn("fabric.Point is already defined");
        return;
      }
      s.Point = u;
      function u(d, l) {
        (this.x = d), (this.y = l);
      }
      u.prototype = {
        type: "point",
        constructor: u,
        add: function (d) {
          return new u(this.x + d.x, this.y + d.y);
        },
        addEquals: function (d) {
          return (this.x += d.x), (this.y += d.y), this;
        },
        scalarAdd: function (d) {
          return new u(this.x + d, this.y + d);
        },
        scalarAddEquals: function (d) {
          return (this.x += d), (this.y += d), this;
        },
        subtract: function (d) {
          return new u(this.x - d.x, this.y - d.y);
        },
        subtractEquals: function (d) {
          return (this.x -= d.x), (this.y -= d.y), this;
        },
        scalarSubtract: function (d) {
          return new u(this.x - d, this.y - d);
        },
        scalarSubtractEquals: function (d) {
          return (this.x -= d), (this.y -= d), this;
        },
        multiply: function (d) {
          return new u(this.x * d, this.y * d);
        },
        multiplyEquals: function (d) {
          return (this.x *= d), (this.y *= d), this;
        },
        divide: function (d) {
          return new u(this.x / d, this.y / d);
        },
        divideEquals: function (d) {
          return (this.x /= d), (this.y /= d), this;
        },
        eq: function (d) {
          return this.x === d.x && this.y === d.y;
        },
        lt: function (d) {
          return this.x < d.x && this.y < d.y;
        },
        lte: function (d) {
          return this.x <= d.x && this.y <= d.y;
        },
        gt: function (d) {
          return this.x > d.x && this.y > d.y;
        },
        gte: function (d) {
          return this.x >= d.x && this.y >= d.y;
        },
        lerp: function (d, l) {
          return (
            typeof l > "u" && (l = 0.5),
            (l = Math.max(Math.min(1, l), 0)),
            new u(this.x + (d.x - this.x) * l, this.y + (d.y - this.y) * l)
          );
        },
        distanceFrom: function (d) {
          var l = this.x - d.x,
            c = this.y - d.y;
          return Math.sqrt(l * l + c * c);
        },
        midPointFrom: function (d) {
          return this.lerp(d);
        },
        min: function (d) {
          return new u(Math.min(this.x, d.x), Math.min(this.y, d.y));
        },
        max: function (d) {
          return new u(Math.max(this.x, d.x), Math.max(this.y, d.y));
        },
        toString: function () {
          return this.x + "," + this.y;
        },
        setXY: function (d, l) {
          return (this.x = d), (this.y = l), this;
        },
        setX: function (d) {
          return (this.x = d), this;
        },
        setY: function (d) {
          return (this.y = d), this;
        },
        setFromPoint: function (d) {
          return (this.x = d.x), (this.y = d.y), this;
        },
        swap: function (d) {
          var l = this.x,
            c = this.y;
          (this.x = d.x), (this.y = d.y), (d.x = l), (d.y = c);
        },
        clone: function () {
          return new u(this.x, this.y);
        },
      };
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {});
      if (s.Intersection) {
        s.warn("fabric.Intersection is already defined");
        return;
      }
      function u(d) {
        (this.status = d), (this.points = []);
      }
      (s.Intersection = u),
        (s.Intersection.prototype = {
          constructor: u,
          appendPoint: function (d) {
            return this.points.push(d), this;
          },
          appendPoints: function (d) {
            return (this.points = this.points.concat(d)), this;
          },
        }),
        (s.Intersection.intersectLineLine = function (d, l, c, h) {
          var m,
            g = (h.x - c.x) * (d.y - c.y) - (h.y - c.y) * (d.x - c.x),
            f = (l.x - d.x) * (d.y - c.y) - (l.y - d.y) * (d.x - c.x),
            v = (h.y - c.y) * (l.x - d.x) - (h.x - c.x) * (l.y - d.y);
          if (v !== 0) {
            var y = g / v,
              _ = f / v;
            0 <= y && y <= 1 && 0 <= _ && _ <= 1
              ? ((m = new u("Intersection")),
                m.appendPoint(
                  new s.Point(d.x + y * (l.x - d.x), d.y + y * (l.y - d.y))
                ))
              : (m = new u());
          } else
            g === 0 || f === 0
              ? (m = new u("Coincident"))
              : (m = new u("Parallel"));
          return m;
        }),
        (s.Intersection.intersectLinePolygon = function (d, l, c) {
          var h = new u(),
            m = c.length,
            g,
            f,
            v,
            y;
          for (y = 0; y < m; y++)
            (g = c[y]),
              (f = c[(y + 1) % m]),
              (v = u.intersectLineLine(d, l, g, f)),
              h.appendPoints(v.points);
          return h.points.length > 0 && (h.status = "Intersection"), h;
        }),
        (s.Intersection.intersectPolygonPolygon = function (d, l) {
          var c = new u(),
            h = d.length,
            m;
          for (m = 0; m < h; m++) {
            var g = d[m],
              f = d[(m + 1) % h],
              v = u.intersectLinePolygon(g, f, l);
            c.appendPoints(v.points);
          }
          return c.points.length > 0 && (c.status = "Intersection"), c;
        }),
        (s.Intersection.intersectPolygonRectangle = function (d, l, c) {
          var h = l.min(c),
            m = l.max(c),
            g = new s.Point(m.x, h.y),
            f = new s.Point(h.x, m.y),
            v = u.intersectLinePolygon(h, g, d),
            y = u.intersectLinePolygon(g, m, d),
            _ = u.intersectLinePolygon(m, f, d),
            x = u.intersectLinePolygon(f, h, d),
            b = new u();
          return (
            b.appendPoints(v.points),
            b.appendPoints(y.points),
            b.appendPoints(_.points),
            b.appendPoints(x.points),
            b.points.length > 0 && (b.status = "Intersection"),
            b
          );
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {});
      if (s.Color) {
        s.warn("fabric.Color is already defined.");
        return;
      }
      function u(l) {
        l ? this._tryParsingColor(l) : this.setSource([0, 0, 0, 1]);
      }
      (s.Color = u),
        (s.Color.prototype = {
          _tryParsingColor: function (l) {
            var c;
            l in u.colorNameMap && (l = u.colorNameMap[l]),
              l === "transparent" && (c = [255, 255, 255, 0]),
              c || (c = u.sourceFromHex(l)),
              c || (c = u.sourceFromRgb(l)),
              c || (c = u.sourceFromHsl(l)),
              c || (c = [0, 0, 0, 1]),
              c && this.setSource(c);
          },
          _rgbToHsl: function (l, c, h) {
            (l /= 255), (c /= 255), (h /= 255);
            var m,
              g,
              f,
              v = s.util.array.max([l, c, h]),
              y = s.util.array.min([l, c, h]);
            if (((f = (v + y) / 2), v === y)) m = g = 0;
            else {
              var _ = v - y;
              switch (((g = f > 0.5 ? _ / (2 - v - y) : _ / (v + y)), v)) {
                case l:
                  m = (c - h) / _ + (c < h ? 6 : 0);
                  break;
                case c:
                  m = (h - l) / _ + 2;
                  break;
                case h:
                  m = (l - c) / _ + 4;
                  break;
              }
              m /= 6;
            }
            return [
              Math.round(m * 360),
              Math.round(g * 100),
              Math.round(f * 100),
            ];
          },
          getSource: function () {
            return this._source;
          },
          setSource: function (l) {
            this._source = l;
          },
          toRgb: function () {
            var l = this.getSource();
            return "rgb(" + l[0] + "," + l[1] + "," + l[2] + ")";
          },
          toRgba: function () {
            var l = this.getSource();
            return "rgba(" + l[0] + "," + l[1] + "," + l[2] + "," + l[3] + ")";
          },
          toHsl: function () {
            var l = this.getSource(),
              c = this._rgbToHsl(l[0], l[1], l[2]);
            return "hsl(" + c[0] + "," + c[1] + "%," + c[2] + "%)";
          },
          toHsla: function () {
            var l = this.getSource(),
              c = this._rgbToHsl(l[0], l[1], l[2]);
            return (
              "hsla(" + c[0] + "," + c[1] + "%," + c[2] + "%," + l[3] + ")"
            );
          },
          toHex: function () {
            var l = this.getSource(),
              c,
              h,
              m;
            return (
              (c = l[0].toString(16)),
              (c = c.length === 1 ? "0" + c : c),
              (h = l[1].toString(16)),
              (h = h.length === 1 ? "0" + h : h),
              (m = l[2].toString(16)),
              (m = m.length === 1 ? "0" + m : m),
              c.toUpperCase() + h.toUpperCase() + m.toUpperCase()
            );
          },
          toHexa: function () {
            var l = this.getSource(),
              c;
            return (
              (c = Math.round(l[3] * 255)),
              (c = c.toString(16)),
              (c = c.length === 1 ? "0" + c : c),
              this.toHex() + c.toUpperCase()
            );
          },
          getAlpha: function () {
            return this.getSource()[3];
          },
          setAlpha: function (l) {
            var c = this.getSource();
            return (c[3] = l), this.setSource(c), this;
          },
          toGrayscale: function () {
            var l = this.getSource(),
              c = parseInt(
                (l[0] * 0.3 + l[1] * 0.59 + l[2] * 0.11).toFixed(0),
                10
              ),
              h = l[3];
            return this.setSource([c, c, c, h]), this;
          },
          toBlackWhite: function (l) {
            var c = this.getSource(),
              h = (c[0] * 0.3 + c[1] * 0.59 + c[2] * 0.11).toFixed(0),
              m = c[3];
            return (
              (l = l || 127),
              (h = Number(h) < Number(l) ? 0 : 255),
              this.setSource([h, h, h, m]),
              this
            );
          },
          overlayWith: function (l) {
            l instanceof u || (l = new u(l));
            var c = [],
              h = this.getAlpha(),
              m = 0.5,
              g = this.getSource(),
              f = l.getSource(),
              v;
            for (v = 0; v < 3; v++)
              c.push(Math.round(g[v] * (1 - m) + f[v] * m));
            return (c[3] = h), this.setSource(c), this;
          },
        }),
        (s.Color.reRGBa =
          /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i),
        (s.Color.reHSLa =
          /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i),
        (s.Color.reHex =
          /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i),
        (s.Color.colorNameMap = {
          aliceblue: "#F0F8FF",
          antiquewhite: "#FAEBD7",
          aqua: "#00FFFF",
          aquamarine: "#7FFFD4",
          azure: "#F0FFFF",
          beige: "#F5F5DC",
          bisque: "#FFE4C4",
          black: "#000000",
          blanchedalmond: "#FFEBCD",
          blue: "#0000FF",
          blueviolet: "#8A2BE2",
          brown: "#A52A2A",
          burlywood: "#DEB887",
          cadetblue: "#5F9EA0",
          chartreuse: "#7FFF00",
          chocolate: "#D2691E",
          coral: "#FF7F50",
          cornflowerblue: "#6495ED",
          cornsilk: "#FFF8DC",
          crimson: "#DC143C",
          cyan: "#00FFFF",
          darkblue: "#00008B",
          darkcyan: "#008B8B",
          darkgoldenrod: "#B8860B",
          darkgray: "#A9A9A9",
          darkgrey: "#A9A9A9",
          darkgreen: "#006400",
          darkkhaki: "#BDB76B",
          darkmagenta: "#8B008B",
          darkolivegreen: "#556B2F",
          darkorange: "#FF8C00",
          darkorchid: "#9932CC",
          darkred: "#8B0000",
          darksalmon: "#E9967A",
          darkseagreen: "#8FBC8F",
          darkslateblue: "#483D8B",
          darkslategray: "#2F4F4F",
          darkslategrey: "#2F4F4F",
          darkturquoise: "#00CED1",
          darkviolet: "#9400D3",
          deeppink: "#FF1493",
          deepskyblue: "#00BFFF",
          dimgray: "#696969",
          dimgrey: "#696969",
          dodgerblue: "#1E90FF",
          firebrick: "#B22222",
          floralwhite: "#FFFAF0",
          forestgreen: "#228B22",
          fuchsia: "#FF00FF",
          gainsboro: "#DCDCDC",
          ghostwhite: "#F8F8FF",
          gold: "#FFD700",
          goldenrod: "#DAA520",
          gray: "#808080",
          grey: "#808080",
          green: "#008000",
          greenyellow: "#ADFF2F",
          honeydew: "#F0FFF0",
          hotpink: "#FF69B4",
          indianred: "#CD5C5C",
          indigo: "#4B0082",
          ivory: "#FFFFF0",
          khaki: "#F0E68C",
          lavender: "#E6E6FA",
          lavenderblush: "#FFF0F5",
          lawngreen: "#7CFC00",
          lemonchiffon: "#FFFACD",
          lightblue: "#ADD8E6",
          lightcoral: "#F08080",
          lightcyan: "#E0FFFF",
          lightgoldenrodyellow: "#FAFAD2",
          lightgray: "#D3D3D3",
          lightgrey: "#D3D3D3",
          lightgreen: "#90EE90",
          lightpink: "#FFB6C1",
          lightsalmon: "#FFA07A",
          lightseagreen: "#20B2AA",
          lightskyblue: "#87CEFA",
          lightslategray: "#778899",
          lightslategrey: "#778899",
          lightsteelblue: "#B0C4DE",
          lightyellow: "#FFFFE0",
          lime: "#00FF00",
          limegreen: "#32CD32",
          linen: "#FAF0E6",
          magenta: "#FF00FF",
          maroon: "#800000",
          mediumaquamarine: "#66CDAA",
          mediumblue: "#0000CD",
          mediumorchid: "#BA55D3",
          mediumpurple: "#9370DB",
          mediumseagreen: "#3CB371",
          mediumslateblue: "#7B68EE",
          mediumspringgreen: "#00FA9A",
          mediumturquoise: "#48D1CC",
          mediumvioletred: "#C71585",
          midnightblue: "#191970",
          mintcream: "#F5FFFA",
          mistyrose: "#FFE4E1",
          moccasin: "#FFE4B5",
          navajowhite: "#FFDEAD",
          navy: "#000080",
          oldlace: "#FDF5E6",
          olive: "#808000",
          olivedrab: "#6B8E23",
          orange: "#FFA500",
          orangered: "#FF4500",
          orchid: "#DA70D6",
          palegoldenrod: "#EEE8AA",
          palegreen: "#98FB98",
          paleturquoise: "#AFEEEE",
          palevioletred: "#DB7093",
          papayawhip: "#FFEFD5",
          peachpuff: "#FFDAB9",
          peru: "#CD853F",
          pink: "#FFC0CB",
          plum: "#DDA0DD",
          powderblue: "#B0E0E6",
          purple: "#800080",
          rebeccapurple: "#663399",
          red: "#FF0000",
          rosybrown: "#BC8F8F",
          royalblue: "#4169E1",
          saddlebrown: "#8B4513",
          salmon: "#FA8072",
          sandybrown: "#F4A460",
          seagreen: "#2E8B57",
          seashell: "#FFF5EE",
          sienna: "#A0522D",
          silver: "#C0C0C0",
          skyblue: "#87CEEB",
          slateblue: "#6A5ACD",
          slategray: "#708090",
          slategrey: "#708090",
          snow: "#FFFAFA",
          springgreen: "#00FF7F",
          steelblue: "#4682B4",
          tan: "#D2B48C",
          teal: "#008080",
          thistle: "#D8BFD8",
          tomato: "#FF6347",
          turquoise: "#40E0D0",
          violet: "#EE82EE",
          wheat: "#F5DEB3",
          white: "#FFFFFF",
          whitesmoke: "#F5F5F5",
          yellow: "#FFFF00",
          yellowgreen: "#9ACD32",
        });
      function d(l, c, h) {
        return (
          h < 0 && (h += 1),
          h > 1 && (h -= 1),
          h < 1 / 6
            ? l + (c - l) * 6 * h
            : h < 1 / 2
            ? c
            : h < 2 / 3
            ? l + (c - l) * (2 / 3 - h) * 6
            : l
        );
      }
      (s.Color.fromRgb = function (l) {
        return u.fromSource(u.sourceFromRgb(l));
      }),
        (s.Color.sourceFromRgb = function (l) {
          var c = l.match(u.reRGBa);
          if (c) {
            var h =
                (parseInt(c[1], 10) / (/%$/.test(c[1]) ? 100 : 1)) *
                (/%$/.test(c[1]) ? 255 : 1),
              m =
                (parseInt(c[2], 10) / (/%$/.test(c[2]) ? 100 : 1)) *
                (/%$/.test(c[2]) ? 255 : 1),
              g =
                (parseInt(c[3], 10) / (/%$/.test(c[3]) ? 100 : 1)) *
                (/%$/.test(c[3]) ? 255 : 1);
            return [
              parseInt(h, 10),
              parseInt(m, 10),
              parseInt(g, 10),
              c[4] ? parseFloat(c[4]) : 1,
            ];
          }
        }),
        (s.Color.fromRgba = u.fromRgb),
        (s.Color.fromHsl = function (l) {
          return u.fromSource(u.sourceFromHsl(l));
        }),
        (s.Color.sourceFromHsl = function (l) {
          var c = l.match(u.reHSLa);
          if (c) {
            var h = (((parseFloat(c[1]) % 360) + 360) % 360) / 360,
              m = parseFloat(c[2]) / (/%$/.test(c[2]) ? 100 : 1),
              g = parseFloat(c[3]) / (/%$/.test(c[3]) ? 100 : 1),
              f,
              v,
              y;
            if (m === 0) f = v = y = g;
            else {
              var _ = g <= 0.5 ? g * (m + 1) : g + m - g * m,
                x = g * 2 - _;
              (f = d(x, _, h + 1 / 3)),
                (v = d(x, _, h)),
                (y = d(x, _, h - 1 / 3));
            }
            return [
              Math.round(f * 255),
              Math.round(v * 255),
              Math.round(y * 255),
              c[4] ? parseFloat(c[4]) : 1,
            ];
          }
        }),
        (s.Color.fromHsla = u.fromHsl),
        (s.Color.fromHex = function (l) {
          return u.fromSource(u.sourceFromHex(l));
        }),
        (s.Color.sourceFromHex = function (l) {
          if (l.match(u.reHex)) {
            var c = l.slice(l.indexOf("#") + 1),
              h = c.length === 3 || c.length === 4,
              m = c.length === 8 || c.length === 4,
              g = h ? c.charAt(0) + c.charAt(0) : c.substring(0, 2),
              f = h ? c.charAt(1) + c.charAt(1) : c.substring(2, 4),
              v = h ? c.charAt(2) + c.charAt(2) : c.substring(4, 6),
              y = m
                ? h
                  ? c.charAt(3) + c.charAt(3)
                  : c.substring(6, 8)
                : "FF";
            return [
              parseInt(g, 16),
              parseInt(f, 16),
              parseInt(v, 16),
              parseFloat((parseInt(y, 16) / 255).toFixed(2)),
            ];
          }
        }),
        (s.Color.fromSource = function (l) {
          var c = new u();
          return c.setSource(l), c;
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"],
        d = ["ns", "nesw", "ew", "nwse"],
        l = {},
        c = "left",
        h = "top",
        m = "right",
        g = "bottom",
        f = "center",
        v = { top: g, bottom: h, left: m, right: c, center: f },
        y = s.util.radiansToDegrees,
        _ =
          Math.sign ||
          function (Z) {
            return (Z > 0) - (Z < 0) || +Z;
          };
      function x(Z, K) {
        var ce = Z.angle + y(Math.atan2(K.y, K.x)) + 360;
        return Math.round((ce % 360) / 45);
      }
      function b(Z, K) {
        var ce = K.transform.target,
          ue = ce.canvas,
          oe = s.util.object.clone(K);
        (oe.target = ce), ue && ue.fire("object:" + Z, oe), ce.fire(Z, K);
      }
      function S(Z, K) {
        var ce = K.canvas,
          ue = ce.uniScaleKey,
          oe = Z[ue];
        return (ce.uniformScaling && !oe) || (!ce.uniformScaling && oe);
      }
      function T(Z) {
        return Z.originX === f && Z.originY === f;
      }
      function w(Z, K, ce) {
        var ue = Z.lockScalingX,
          oe = Z.lockScalingY;
        return !!(
          (ue && oe) ||
          (!K && (ue || oe) && ce) ||
          (ue && K === "x") ||
          (oe && K === "y")
        );
      }
      function P(Z, K, ce) {
        var ue = "not-allowed",
          oe = S(Z, ce),
          le = "";
        if (
          (K.x !== 0 && K.y === 0
            ? (le = "x")
            : K.x === 0 && K.y !== 0 && (le = "y"),
          w(ce, le, oe))
        )
          return ue;
        var ge = x(ce, K);
        return u[ge] + "-resize";
      }
      function F(Z, K, ce) {
        var ue = "not-allowed";
        if ((K.x !== 0 && ce.lockSkewingY) || (K.y !== 0 && ce.lockSkewingX))
          return ue;
        var oe = x(ce, K) % 4;
        return d[oe] + "-resize";
      }
      function V(Z, K, ce) {
        return Z[ce.canvas.altActionKey]
          ? l.skewCursorStyleHandler(Z, K, ce)
          : l.scaleCursorStyleHandler(Z, K, ce);
      }
      function J(Z, K, ce) {
        var ue = Z[ce.canvas.altActionKey];
        if (K.x === 0) return ue ? "skewX" : "scaleY";
        if (K.y === 0) return ue ? "skewY" : "scaleX";
      }
      function z(Z, K, ce) {
        return ce.lockRotation ? "not-allowed" : K.cursorStyle;
      }
      function B(Z, K, ce, ue) {
        return { e: Z, transform: K, pointer: { x: ce, y: ue } };
      }
      function G(Z) {
        return function (K, ce, ue, oe) {
          var le = ce.target,
            ge = le.getCenterPoint(),
            Re = le.translateToOriginPoint(ge, ce.originX, ce.originY),
            Me = Z(K, ce, ue, oe);
          return le.setPositionByOrigin(Re, ce.originX, ce.originY), Me;
        };
      }
      function ie(Z, K) {
        return function (ce, ue, oe, le) {
          var ge = K(ce, ue, oe, le);
          return ge && b(Z, B(ce, ue, oe, le)), ge;
        };
      }
      function re(Z, K, ce, ue, oe) {
        var le = Z.target,
          ge = le.controls[Z.corner],
          Re = le.canvas.getZoom(),
          Me = le.padding / Re,
          L = le.toLocalPoint(new s.Point(ue, oe), K, ce);
        return (
          L.x >= Me && (L.x -= Me),
          L.x <= -Me && (L.x += Me),
          L.y >= Me && (L.y -= Me),
          L.y <= Me && (L.y += Me),
          (L.x -= ge.offsetX),
          (L.y -= ge.offsetY),
          L
        );
      }
      function j(Z) {
        return Z.flipX !== Z.flipY;
      }
      function C(Z, K, ce, ue, oe) {
        if (Z[K] !== 0) {
          var le = Z._getTransformedDimensions()[ue],
            ge = (oe / le) * Z[ce];
          Z.set(ce, ge);
        }
      }
      function R(Z, K, ce, ue) {
        var oe = K.target,
          le = oe._getTransformedDimensions(0, oe.skewY),
          ge = re(K, K.originX, K.originY, ce, ue),
          Re = Math.abs(ge.x * 2) - le.x,
          Me = oe.skewX,
          L;
        Re < 2
          ? (L = 0)
          : ((L = y(Math.atan2(Re / oe.scaleX, le.y / oe.scaleY))),
            K.originX === c && K.originY === g && (L = -L),
            K.originX === m && K.originY === h && (L = -L),
            j(oe) && (L = -L));
        var D = Me !== L;
        if (D) {
          var ne = oe._getTransformedDimensions().y;
          oe.set("skewX", L), C(oe, "skewY", "scaleY", "y", ne);
        }
        return D;
      }
      function A(Z, K, ce, ue) {
        var oe = K.target,
          le = oe._getTransformedDimensions(oe.skewX, 0),
          ge = re(K, K.originX, K.originY, ce, ue),
          Re = Math.abs(ge.y * 2) - le.y,
          Me = oe.skewY,
          L;
        Re < 2
          ? (L = 0)
          : ((L = y(Math.atan2(Re / oe.scaleY, le.x / oe.scaleX))),
            K.originX === c && K.originY === g && (L = -L),
            K.originX === m && K.originY === h && (L = -L),
            j(oe) && (L = -L));
        var D = Me !== L;
        if (D) {
          var ne = oe._getTransformedDimensions().x;
          oe.set("skewY", L), C(oe, "skewX", "scaleX", "x", ne);
        }
        return D;
      }
      function O(Z, K, ce, ue) {
        var oe = K.target,
          le = oe.skewX,
          ge,
          Re = K.originY;
        if (oe.lockSkewingX) return !1;
        if (le === 0) {
          var Me = re(K, f, f, ce, ue);
          Me.x > 0 ? (ge = c) : (ge = m);
        } else
          le > 0 && (ge = Re === h ? c : m),
            le < 0 && (ge = Re === h ? m : c),
            j(oe) && (ge = ge === c ? m : c);
        K.originX = ge;
        var L = ie("skewing", G(R));
        return L(Z, K, ce, ue);
      }
      function H(Z, K, ce, ue) {
        var oe = K.target,
          le = oe.skewY,
          ge,
          Re = K.originX;
        if (oe.lockSkewingY) return !1;
        if (le === 0) {
          var Me = re(K, f, f, ce, ue);
          Me.y > 0 ? (ge = h) : (ge = g);
        } else
          le > 0 && (ge = Re === c ? h : g),
            le < 0 && (ge = Re === c ? g : h),
            j(oe) && (ge = ge === h ? g : h);
        K.originY = ge;
        var L = ie("skewing", G(A));
        return L(Z, K, ce, ue);
      }
      function I(Z, K, ce, ue) {
        var oe = K,
          le = oe.target,
          ge = le.translateToOriginPoint(
            le.getCenterPoint(),
            oe.originX,
            oe.originY
          );
        if (le.lockRotation) return !1;
        var Re = Math.atan2(oe.ey - ge.y, oe.ex - ge.x),
          Me = Math.atan2(ue - ge.y, ce - ge.x),
          L = y(Me - Re + oe.theta),
          D = !0;
        if (le.snapAngle > 0) {
          var ne = le.snapAngle,
            de = le.snapThreshold || ne,
            ye = Math.ceil(L / ne) * ne,
            _e = Math.floor(L / ne) * ne;
          Math.abs(L - _e) < de ? (L = _e) : Math.abs(L - ye) < de && (L = ye);
        }
        return (
          L < 0 && (L = 360 + L),
          (L %= 360),
          (D = le.angle !== L),
          (le.angle = L),
          D
        );
      }
      function E(Z, K, ce, ue, oe) {
        oe = oe || {};
        var le = K.target,
          ge = le.lockScalingX,
          Re = le.lockScalingY,
          Me = oe.by,
          L,
          D,
          ne,
          de,
          ye = S(Z, le),
          _e = w(le, Me, ye),
          Pe,
          U,
          te = K.gestureScale;
        if (_e) return !1;
        if (te) (D = K.scaleX * te), (ne = K.scaleY * te);
        else {
          if (
            ((L = re(K, K.originX, K.originY, ce, ue)),
            (Pe = Me !== "y" ? _(L.x) : 1),
            (U = Me !== "x" ? _(L.y) : 1),
            K.signX || (K.signX = Pe),
            K.signY || (K.signY = U),
            le.lockScalingFlip && (K.signX !== Pe || K.signY !== U))
          )
            return !1;
          if (((de = le._getTransformedDimensions()), ye && !Me)) {
            var we = Math.abs(L.x) + Math.abs(L.y),
              Se = K.original,
              Ee =
                Math.abs((de.x * Se.scaleX) / le.scaleX) +
                Math.abs((de.y * Se.scaleY) / le.scaleY),
              Le = we / Ee;
            (D = Se.scaleX * Le), (ne = Se.scaleY * Le);
          } else
            (D = Math.abs((L.x * le.scaleX) / de.x)),
              (ne = Math.abs((L.y * le.scaleY) / de.y));
          T(K) && ((D *= 2), (ne *= 2)),
            K.signX !== Pe &&
              Me !== "y" &&
              ((K.originX = v[K.originX]), (D *= -1), (K.signX = Pe)),
            K.signY !== U &&
              Me !== "x" &&
              ((K.originY = v[K.originY]), (ne *= -1), (K.signY = U));
        }
        var De = le.scaleX,
          He = le.scaleY;
        return (
          Me
            ? (Me === "x" && le.set("scaleX", D),
              Me === "y" && le.set("scaleY", ne))
            : (!ge && le.set("scaleX", D), !Re && le.set("scaleY", ne)),
          De !== le.scaleX || He !== le.scaleY
        );
      }
      function k(Z, K, ce, ue) {
        return E(Z, K, ce, ue);
      }
      function $(Z, K, ce, ue) {
        return E(Z, K, ce, ue, { by: "x" });
      }
      function Y(Z, K, ce, ue) {
        return E(Z, K, ce, ue, { by: "y" });
      }
      function X(Z, K, ce, ue) {
        return Z[K.target.canvas.altActionKey]
          ? l.skewHandlerX(Z, K, ce, ue)
          : l.scalingY(Z, K, ce, ue);
      }
      function ee(Z, K, ce, ue) {
        return Z[K.target.canvas.altActionKey]
          ? l.skewHandlerY(Z, K, ce, ue)
          : l.scalingX(Z, K, ce, ue);
      }
      function he(Z, K, ce, ue) {
        var oe = K.target,
          le = re(K, K.originX, K.originY, ce, ue),
          ge = oe.strokeWidth / (oe.strokeUniform ? oe.scaleX : 1),
          Re = T(K) ? 2 : 1,
          Me = oe.width,
          L = Math.abs((le.x * Re) / oe.scaleX) - ge;
        return oe.set("width", Math.max(L, 0)), Me !== L;
      }
      function pe(Z, K, ce, ue) {
        var oe = K.target,
          le = ce - K.offsetX,
          ge = ue - K.offsetY,
          Re = !oe.get("lockMovementX") && oe.left !== le,
          Me = !oe.get("lockMovementY") && oe.top !== ge;
        return (
          Re && oe.set("left", le),
          Me && oe.set("top", ge),
          (Re || Me) && b("moving", B(Z, K, ce, ue)),
          Re || Me
        );
      }
      (l.scaleCursorStyleHandler = P),
        (l.skewCursorStyleHandler = F),
        (l.scaleSkewCursorStyleHandler = V),
        (l.rotationWithSnapping = ie("rotating", G(I))),
        (l.scalingEqually = ie("scaling", G(k))),
        (l.scalingX = ie("scaling", G($))),
        (l.scalingY = ie("scaling", G(Y))),
        (l.scalingYOrSkewingX = X),
        (l.scalingXOrSkewingY = ee),
        (l.changeWidth = ie("resizing", G(he))),
        (l.skewHandlerX = O),
        (l.skewHandlerY = H),
        (l.dragHandler = pe),
        (l.scaleOrSkewActionName = J),
        (l.rotationStyleHandler = z),
        (l.fireEvent = b),
        (l.wrapWithFixedAnchor = G),
        (l.wrapWithFireEvent = ie),
        (l.getLocalPoint = re),
        (s.controlsUtils = l);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.degreesToRadians,
        d = s.controlsUtils;
      function l(h, m, g, f, v) {
        f = f || {};
        var y = this.sizeX || f.cornerSize || v.cornerSize,
          _ = this.sizeY || f.cornerSize || v.cornerSize,
          x =
            typeof f.transparentCorners < "u"
              ? f.transparentCorners
              : v.transparentCorners,
          b = x ? "stroke" : "fill",
          S = !x && (f.cornerStrokeColor || v.cornerStrokeColor),
          T = m,
          w = g,
          P;
        h.save(),
          (h.fillStyle = f.cornerColor || v.cornerColor),
          (h.strokeStyle = f.cornerStrokeColor || v.cornerStrokeColor),
          y > _
            ? ((P = y), h.scale(1, _ / y), (w = (g * y) / _))
            : _ > y
            ? ((P = _), h.scale(y / _, 1), (T = (m * _) / y))
            : (P = y),
          (h.lineWidth = 1),
          h.beginPath(),
          h.arc(T, w, P / 2, 0, 2 * Math.PI, !1),
          h[b](),
          S && h.stroke(),
          h.restore();
      }
      function c(h, m, g, f, v) {
        f = f || {};
        var y = this.sizeX || f.cornerSize || v.cornerSize,
          _ = this.sizeY || f.cornerSize || v.cornerSize,
          x =
            typeof f.transparentCorners < "u"
              ? f.transparentCorners
              : v.transparentCorners,
          b = x ? "stroke" : "fill",
          S = !x && (f.cornerStrokeColor || v.cornerStrokeColor),
          T = y / 2,
          w = _ / 2;
        h.save(),
          (h.fillStyle = f.cornerColor || v.cornerColor),
          (h.strokeStyle = f.cornerStrokeColor || v.cornerStrokeColor),
          (h.lineWidth = 1),
          h.translate(m, g),
          h.rotate(u(v.angle)),
          h[b + "Rect"](-T, -w, y, _),
          S && h.strokeRect(-T, -w, y, _),
          h.restore();
      }
      (d.renderCircleControl = l), (d.renderSquareControl = c);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {});
      function u(d) {
        for (var l in d) this[l] = d[l];
      }
      (s.Control = u),
        (s.Control.prototype = {
          visible: !0,
          actionName: "scale",
          angle: 0,
          x: 0,
          y: 0,
          offsetX: 0,
          offsetY: 0,
          sizeX: null,
          sizeY: null,
          touchSizeX: null,
          touchSizeY: null,
          cursorStyle: "crosshair",
          withConnection: !1,
          actionHandler: function () {},
          mouseDownHandler: function () {},
          mouseUpHandler: function () {},
          getActionHandler: function () {
            return this.actionHandler;
          },
          getMouseDownHandler: function () {
            return this.mouseDownHandler;
          },
          getMouseUpHandler: function () {
            return this.mouseUpHandler;
          },
          cursorStyleHandler: function (d, l) {
            return l.cursorStyle;
          },
          getActionName: function (d, l) {
            return l.actionName;
          },
          getVisibility: function (d, l) {
            var c = d._controlsVisibility;
            return c && typeof c[l] < "u" ? c[l] : this.visible;
          },
          setVisibility: function (d) {
            this.visible = d;
          },
          positionHandler: function (d, l) {
            var c = s.util.transformPoint(
              {
                x: this.x * d.x + this.offsetX,
                y: this.y * d.y + this.offsetY,
              },
              l
            );
            return c;
          },
          calcCornerCoords: function (d, l, c, h, m) {
            var g,
              f,
              v,
              y,
              _ = m ? this.touchSizeX : this.sizeX,
              x = m ? this.touchSizeY : this.sizeY;
            if (_ && x && _ !== x) {
              var b = Math.atan2(x, _),
                S = Math.sqrt(_ * _ + x * x) / 2,
                T = b - s.util.degreesToRadians(d),
                w = Math.PI / 2 - b - s.util.degreesToRadians(d);
              (g = S * s.util.cos(T)),
                (f = S * s.util.sin(T)),
                (v = S * s.util.cos(w)),
                (y = S * s.util.sin(w));
            } else {
              var P = _ && x ? _ : l;
              S = P * 0.7071067812;
              var T = s.util.degreesToRadians(45 - d);
              (g = v = S * s.util.cos(T)), (f = y = S * s.util.sin(T));
            }
            return {
              tl: { x: c - y, y: h - v },
              tr: { x: c + g, y: h - f },
              bl: { x: c - g, y: h + f },
              br: { x: c + y, y: h + v },
            };
          },
          render: function (d, l, c, h, m) {
            switch (((h = h || {}), h.cornerStyle || m.cornerStyle)) {
              case "circle":
                s.controlsUtils.renderCircleControl.call(this, d, l, c, h, m);
                break;
              default:
                s.controlsUtils.renderSquareControl.call(this, d, l, c, h, m);
            }
          },
        });
    })(n),
    (function () {
      function a(c, h) {
        var m = c.getAttribute("style"),
          g = c.getAttribute("offset") || 0,
          f,
          v,
          y,
          _;
        if (
          ((g = parseFloat(g) / (/%$/.test(g) ? 100 : 1)),
          (g = g < 0 ? 0 : g > 1 ? 1 : g),
          m)
        ) {
          var x = m.split(/\s*;\s*/);
          for (x[x.length - 1] === "" && x.pop(), _ = x.length; _--; ) {
            var b = x[_].split(/\s*:\s*/),
              S = b[0].trim(),
              T = b[1].trim();
            S === "stop-color" ? (f = T) : S === "stop-opacity" && (y = T);
          }
        }
        return (
          f || (f = c.getAttribute("stop-color") || "rgb(0,0,0)"),
          y || (y = c.getAttribute("stop-opacity")),
          (f = new e.Color(f)),
          (v = f.getAlpha()),
          (y = isNaN(parseFloat(y)) ? 1 : parseFloat(y)),
          (y *= v * h),
          { offset: g, color: f.toRgb(), opacity: y }
        );
      }
      function s(c) {
        return {
          x1: c.getAttribute("x1") || 0,
          y1: c.getAttribute("y1") || 0,
          x2: c.getAttribute("x2") || "100%",
          y2: c.getAttribute("y2") || 0,
        };
      }
      function u(c) {
        return {
          x1: c.getAttribute("fx") || c.getAttribute("cx") || "50%",
          y1: c.getAttribute("fy") || c.getAttribute("cy") || "50%",
          r1: 0,
          x2: c.getAttribute("cx") || "50%",
          y2: c.getAttribute("cy") || "50%",
          r2: c.getAttribute("r") || "50%",
        };
      }
      var d = e.util.object.clone;
      (e.Gradient = e.util.createClass({
        offsetX: 0,
        offsetY: 0,
        gradientTransform: null,
        gradientUnits: "pixels",
        type: "linear",
        initialize: function (c) {
          c || (c = {}), c.coords || (c.coords = {});
          var h,
            m = this;
          Object.keys(c).forEach(function (g) {
            m[g] = c[g];
          }),
            this.id
              ? (this.id += "_" + e.Object.__uid++)
              : (this.id = e.Object.__uid++),
            (h = {
              x1: c.coords.x1 || 0,
              y1: c.coords.y1 || 0,
              x2: c.coords.x2 || 0,
              y2: c.coords.y2 || 0,
            }),
            this.type === "radial" &&
              ((h.r1 = c.coords.r1 || 0), (h.r2 = c.coords.r2 || 0)),
            (this.coords = h),
            (this.colorStops = c.colorStops.slice());
        },
        addColorStop: function (c) {
          for (var h in c) {
            var m = new e.Color(c[h]);
            this.colorStops.push({
              offset: parseFloat(h),
              color: m.toRgb(),
              opacity: m.getAlpha(),
            });
          }
          return this;
        },
        toObject: function (c) {
          var h = {
            type: this.type,
            coords: this.coords,
            colorStops: this.colorStops,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            gradientUnits: this.gradientUnits,
            gradientTransform: this.gradientTransform
              ? this.gradientTransform.concat()
              : this.gradientTransform,
          };
          return e.util.populateWithProperties(this, h, c), h;
        },
        toSVG: function (c, v) {
          var m = d(this.coords, !0),
            g,
            f,
            v = v || {},
            y,
            _,
            x = d(this.colorStops, !0),
            b = m.r1 > m.r2,
            S = this.gradientTransform
              ? this.gradientTransform.concat()
              : e.iMatrix.concat(),
            T = -this.offsetX,
            w = -this.offsetY,
            P = !!v.additionalTransform,
            F =
              this.gradientUnits === "pixels"
                ? "userSpaceOnUse"
                : "objectBoundingBox";
          if (
            (x.sort(function (G, ie) {
              return G.offset - ie.offset;
            }),
            F === "objectBoundingBox"
              ? ((T /= c.width), (w /= c.height))
              : ((T += c.width / 2), (w += c.height / 2)),
            c.type === "path" &&
              this.gradientUnits !== "percentage" &&
              ((T -= c.pathOffset.x), (w -= c.pathOffset.y)),
            (S[4] -= T),
            (S[5] -= w),
            (_ = 'id="SVGID_' + this.id + '" gradientUnits="' + F + '"'),
            (_ +=
              ' gradientTransform="' +
              (P ? v.additionalTransform + " " : "") +
              e.util.matrixToSVG(S) +
              '" '),
            this.type === "linear"
              ? (y = [
                  "<linearGradient ",
                  _,
                  ' x1="',
                  m.x1,
                  '" y1="',
                  m.y1,
                  '" x2="',
                  m.x2,
                  '" y2="',
                  m.y2,
                  `">
`,
                ])
              : this.type === "radial" &&
                (y = [
                  "<radialGradient ",
                  _,
                  ' cx="',
                  b ? m.x1 : m.x2,
                  '" cy="',
                  b ? m.y1 : m.y2,
                  '" r="',
                  b ? m.r1 : m.r2,
                  '" fx="',
                  b ? m.x2 : m.x1,
                  '" fy="',
                  b ? m.y2 : m.y1,
                  `">
`,
                ]),
            this.type === "radial")
          ) {
            if (b)
              for (x = x.concat(), x.reverse(), g = 0, f = x.length; g < f; g++)
                x[g].offset = 1 - x[g].offset;
            var V = Math.min(m.r1, m.r2);
            if (V > 0) {
              var J = Math.max(m.r1, m.r2),
                z = V / J;
              for (g = 0, f = x.length; g < f; g++)
                x[g].offset += z * (1 - x[g].offset);
            }
          }
          for (g = 0, f = x.length; g < f; g++) {
            var B = x[g];
            y.push(
              "<stop ",
              'offset="',
              B.offset * 100 + "%",
              '" style="stop-color:',
              B.color,
              typeof B.opacity < "u" ? ";stop-opacity: " + B.opacity : ";",
              `"/>
`
            );
          }
          return (
            y.push(
              this.type === "linear"
                ? `</linearGradient>
`
                : `</radialGradient>
`
            ),
            y.join("")
          );
        },
        toLive: function (c) {
          var h,
            m = e.util.object.clone(this.coords),
            g,
            f;
          if (this.type) {
            for (
              this.type === "linear"
                ? (h = c.createLinearGradient(m.x1, m.y1, m.x2, m.y2))
                : this.type === "radial" &&
                  (h = c.createRadialGradient(
                    m.x1,
                    m.y1,
                    m.r1,
                    m.x2,
                    m.y2,
                    m.r2
                  )),
                g = 0,
                f = this.colorStops.length;
              g < f;
              g++
            ) {
              var v = this.colorStops[g].color,
                y = this.colorStops[g].opacity,
                _ = this.colorStops[g].offset;
              typeof y < "u" && (v = new e.Color(v).setAlpha(y).toRgba()),
                h.addColorStop(_, v);
            }
            return h;
          }
        },
      })),
        e.util.object.extend(e.Gradient, {
          fromElement: function (c, h, m, g) {
            var f = parseFloat(m) / (/%$/.test(m) ? 100 : 1);
            (f = f < 0 ? 0 : f > 1 ? 1 : f), isNaN(f) && (f = 1);
            var v = c.getElementsByTagName("stop"),
              y,
              _ =
                c.getAttribute("gradientUnits") === "userSpaceOnUse"
                  ? "pixels"
                  : "percentage",
              x = c.getAttribute("gradientTransform") || "",
              b = [],
              S,
              T,
              w = 0,
              P = 0,
              F;
            for (
              c.nodeName === "linearGradient" || c.nodeName === "LINEARGRADIENT"
                ? ((y = "linear"), (S = s(c)))
                : ((y = "radial"), (S = u(c))),
                T = v.length;
              T--;

            )
              b.push(a(v[T], f));
            (F = e.parseTransformAttribute(x)),
              l(h, S, g, _),
              _ === "pixels" && ((w = -h.left), (P = -h.top));
            var V = new e.Gradient({
              id: c.getAttribute("id"),
              type: y,
              coords: S,
              colorStops: b,
              gradientUnits: _,
              gradientTransform: F,
              offsetX: w,
              offsetY: P,
            });
            return V;
          },
        });
      function l(c, h, m, g) {
        var f, v;
        Object.keys(h).forEach(function (y) {
          (f = h[y]),
            f === "Infinity"
              ? (v = 1)
              : f === "-Infinity"
              ? (v = 0)
              : ((v = parseFloat(h[y], 10)),
                typeof f == "string" &&
                  /^(\d+\.\d+)%|(\d+)%$/.test(f) &&
                  ((v *= 0.01),
                  g === "pixels" &&
                    ((y === "x1" || y === "x2" || y === "r2") &&
                      (v *= m.viewBoxWidth || m.width),
                    (y === "y1" || y === "y2") &&
                      (v *= m.viewBoxHeight || m.height)))),
            (h[y] = v);
        });
      }
    })(),
    (function () {
      var a = e.util.toFixed;
      e.Pattern = e.util.createClass({
        repeat: "repeat",
        offsetX: 0,
        offsetY: 0,
        crossOrigin: "",
        patternTransform: null,
        initialize: function (s, u) {
          if (
            (s || (s = {}),
            (this.id = e.Object.__uid++),
            this.setOptions(s),
            !s.source || (s.source && typeof s.source != "string"))
          ) {
            u && u(this);
            return;
          } else {
            var d = this;
            (this.source = e.util.createImage()),
              e.util.loadImage(
                s.source,
                function (l, c) {
                  (d.source = l), u && u(d, c);
                },
                null,
                this.crossOrigin
              );
          }
        },
        toObject: function (s) {
          var u = e.Object.NUM_FRACTION_DIGITS,
            d,
            l;
          return (
            typeof this.source.src == "string"
              ? (d = this.source.src)
              : typeof this.source == "object" &&
                this.source.toDataURL &&
                (d = this.source.toDataURL()),
            (l = {
              type: "pattern",
              source: d,
              repeat: this.repeat,
              crossOrigin: this.crossOrigin,
              offsetX: a(this.offsetX, u),
              offsetY: a(this.offsetY, u),
              patternTransform: this.patternTransform
                ? this.patternTransform.concat()
                : null,
            }),
            e.util.populateWithProperties(this, l, s),
            l
          );
        },
        toSVG: function (s) {
          var u =
              typeof this.source == "function" ? this.source() : this.source,
            d = u.width / s.width,
            l = u.height / s.height,
            c = this.offsetX / s.width,
            h = this.offsetY / s.height,
            m = "";
          return (
            (this.repeat === "repeat-x" || this.repeat === "no-repeat") &&
              ((l = 1), h && (l += Math.abs(h))),
            (this.repeat === "repeat-y" || this.repeat === "no-repeat") &&
              ((d = 1), c && (d += Math.abs(c))),
            u.src ? (m = u.src) : u.toDataURL && (m = u.toDataURL()),
            '<pattern id="SVGID_' +
              this.id +
              '" x="' +
              c +
              '" y="' +
              h +
              '" width="' +
              d +
              '" height="' +
              l +
              `">
<image x="0" y="0" width="` +
              u.width +
              '" height="' +
              u.height +
              '" xlink:href="' +
              m +
              `"></image>
</pattern>
`
          );
        },
        setOptions: function (s) {
          for (var u in s) this[u] = s[u];
        },
        toLive: function (s) {
          var u = this.source;
          return !u ||
            (typeof u.src < "u" &&
              (!u.complete || u.naturalWidth === 0 || u.naturalHeight === 0))
            ? ""
            : s.createPattern(u, this.repeat);
        },
      });
    })(),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.toFixed;
      if (s.Shadow) {
        s.warn("fabric.Shadow is already defined.");
        return;
      }
      (s.Shadow = s.util.createClass({
        color: "rgb(0,0,0)",
        blur: 0,
        offsetX: 0,
        offsetY: 0,
        affectStroke: !1,
        includeDefaultValues: !0,
        nonScaling: !1,
        initialize: function (d) {
          typeof d == "string" && (d = this._parseShadow(d));
          for (var l in d) this[l] = d[l];
          this.id = s.Object.__uid++;
        },
        _parseShadow: function (d) {
          var l = d.trim(),
            c = s.Shadow.reOffsetsAndBlur.exec(l) || [],
            h = l.replace(s.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)";
          return {
            color: h.trim(),
            offsetX: parseFloat(c[1], 10) || 0,
            offsetY: parseFloat(c[2], 10) || 0,
            blur: parseFloat(c[3], 10) || 0,
          };
        },
        toString: function () {
          return [this.offsetX, this.offsetY, this.blur, this.color].join(
            "px "
          );
        },
        toSVG: function (d) {
          var l = 40,
            c = 40,
            h = s.Object.NUM_FRACTION_DIGITS,
            m = s.util.rotateVector(
              { x: this.offsetX, y: this.offsetY },
              s.util.degreesToRadians(-d.angle)
            ),
            g = 20,
            f = new s.Color(this.color);
          return (
            d.width &&
              d.height &&
              ((l = u((Math.abs(m.x) + this.blur) / d.width, h) * 100 + g),
              (c = u((Math.abs(m.y) + this.blur) / d.height, h) * 100 + g)),
            d.flipX && (m.x *= -1),
            d.flipY && (m.y *= -1),
            '<filter id="SVGID_' +
              this.id +
              '" y="-' +
              c +
              '%" height="' +
              (100 + 2 * c) +
              '%" x="-' +
              l +
              '%" width="' +
              (100 + 2 * l) +
              `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="` +
              u(this.blur ? this.blur / 2 : 0, h) +
              `"></feGaussianBlur>
	<feOffset dx="` +
              u(m.x, h) +
              '" dy="' +
              u(m.y, h) +
              `" result="oBlur" ></feOffset>
	<feFlood flood-color="` +
              f.toRgb() +
              '" flood-opacity="' +
              f.getAlpha() +
              `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`
          );
        },
        toObject: function () {
          if (this.includeDefaultValues)
            return {
              color: this.color,
              blur: this.blur,
              offsetX: this.offsetX,
              offsetY: this.offsetY,
              affectStroke: this.affectStroke,
              nonScaling: this.nonScaling,
            };
          var d = {},
            l = s.Shadow.prototype;
          return (
            [
              "color",
              "blur",
              "offsetX",
              "offsetY",
              "affectStroke",
              "nonScaling",
            ].forEach(function (c) {
              this[c] !== l[c] && (d[c] = this[c]);
            }, this),
            d
          );
        },
      })),
        (s.Shadow.reOffsetsAndBlur =
          /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/);
    })(n),
    (function () {
      if (e.StaticCanvas) {
        e.warn("fabric.StaticCanvas is already defined.");
        return;
      }
      var a = e.util.object.extend,
        s = e.util.getElementOffset,
        u = e.util.removeFromArray,
        d = e.util.toFixed,
        l = e.util.transformPoint,
        c = e.util.invertTransform,
        h = e.util.getNodeCanvas,
        m = e.util.createCanvasElement,
        g = new Error("Could not initialize `canvas` element");
      (e.StaticCanvas = e.util.createClass(e.CommonMethods, {
        initialize: function (f, v) {
          v || (v = {}),
            (this.renderAndResetBound = this.renderAndReset.bind(this)),
            (this.requestRenderAllBound = this.requestRenderAll.bind(this)),
            this._initStatic(f, v);
        },
        backgroundColor: "",
        backgroundImage: null,
        overlayColor: "",
        overlayImage: null,
        includeDefaultValues: !0,
        stateful: !1,
        renderOnAddRemove: !0,
        controlsAboveOverlay: !1,
        allowTouchScrolling: !1,
        imageSmoothingEnabled: !0,
        viewportTransform: e.iMatrix.concat(),
        backgroundVpt: !0,
        overlayVpt: !0,
        enableRetinaScaling: !0,
        vptCoords: {},
        skipOffscreen: !0,
        clipPath: void 0,
        _initStatic: function (f, v) {
          var y = this.requestRenderAllBound;
          (this._objects = []),
            this._createLowerCanvas(f),
            this._initOptions(v),
            this.interactive || this._initRetinaScaling(),
            v.overlayImage && this.setOverlayImage(v.overlayImage, y),
            v.backgroundImage && this.setBackgroundImage(v.backgroundImage, y),
            v.backgroundColor && this.setBackgroundColor(v.backgroundColor, y),
            v.overlayColor && this.setOverlayColor(v.overlayColor, y),
            this.calcOffset();
        },
        _isRetinaScaling: function () {
          return e.devicePixelRatio > 1 && this.enableRetinaScaling;
        },
        getRetinaScaling: function () {
          return this._isRetinaScaling() ? Math.max(1, e.devicePixelRatio) : 1;
        },
        _initRetinaScaling: function () {
          if (this._isRetinaScaling()) {
            var f = e.devicePixelRatio;
            this.__initRetinaScaling(
              f,
              this.lowerCanvasEl,
              this.contextContainer
            ),
              this.upperCanvasEl &&
                this.__initRetinaScaling(
                  f,
                  this.upperCanvasEl,
                  this.contextTop
                );
          }
        },
        __initRetinaScaling: function (f, v, y) {
          v.setAttribute("width", this.width * f),
            v.setAttribute("height", this.height * f),
            y.scale(f, f);
        },
        calcOffset: function () {
          return (this._offset = s(this.lowerCanvasEl)), this;
        },
        setOverlayImage: function (f, v, y) {
          return this.__setBgOverlayImage("overlayImage", f, v, y);
        },
        setBackgroundImage: function (f, v, y) {
          return this.__setBgOverlayImage("backgroundImage", f, v, y);
        },
        setOverlayColor: function (f, v) {
          return this.__setBgOverlayColor("overlayColor", f, v);
        },
        setBackgroundColor: function (f, v) {
          return this.__setBgOverlayColor("backgroundColor", f, v);
        },
        __setBgOverlayImage: function (f, v, y, _) {
          return (
            typeof v == "string"
              ? e.util.loadImage(
                  v,
                  function (x, b) {
                    if (x) {
                      var S = new e.Image(x, _);
                      (this[f] = S), (S.canvas = this);
                    }
                    y && y(x, b);
                  },
                  this,
                  _ && _.crossOrigin
                )
              : (_ && v.setOptions(_),
                (this[f] = v),
                v && (v.canvas = this),
                y && y(v, !1)),
            this
          );
        },
        __setBgOverlayColor: function (f, v, y) {
          return (
            (this[f] = v),
            this._initGradient(v, f),
            this._initPattern(v, f, y),
            this
          );
        },
        _createCanvasElement: function () {
          var f = m();
          if (!f || (f.style || (f.style = {}), typeof f.getContext > "u"))
            throw g;
          return f;
        },
        _initOptions: function (f) {
          var v = this.lowerCanvasEl;
          this._setOptions(f),
            (this.width = this.width || parseInt(v.width, 10) || 0),
            (this.height = this.height || parseInt(v.height, 10) || 0),
            this.lowerCanvasEl.style &&
              ((v.width = this.width),
              (v.height = this.height),
              (v.style.width = this.width + "px"),
              (v.style.height = this.height + "px"),
              (this.viewportTransform = this.viewportTransform.slice()));
        },
        _createLowerCanvas: function (f) {
          f && f.getContext
            ? (this.lowerCanvasEl = f)
            : (this.lowerCanvasEl =
                e.util.getById(f) || this._createCanvasElement()),
            e.util.addClass(this.lowerCanvasEl, "lower-canvas"),
            (this._originalCanvasStyle = this.lowerCanvasEl.style),
            this.interactive && this._applyCanvasStyle(this.lowerCanvasEl),
            (this.contextContainer = this.lowerCanvasEl.getContext("2d"));
        },
        getWidth: function () {
          return this.width;
        },
        getHeight: function () {
          return this.height;
        },
        setWidth: function (f, v) {
          return this.setDimensions({ width: f }, v);
        },
        setHeight: function (f, v) {
          return this.setDimensions({ height: f }, v);
        },
        setDimensions: function (f, v) {
          var y;
          v = v || {};
          for (var _ in f)
            (y = f[_]),
              v.cssOnly ||
                (this._setBackstoreDimension(_, f[_]),
                (y += "px"),
                (this.hasLostContext = !0)),
              v.backstoreOnly || this._setCssDimension(_, y);
          return (
            this._isCurrentlyDrawing &&
              this.freeDrawingBrush &&
              this.freeDrawingBrush._setBrushStyles(this.contextTop),
            this._initRetinaScaling(),
            this.calcOffset(),
            v.cssOnly || this.requestRenderAll(),
            this
          );
        },
        _setBackstoreDimension: function (f, v) {
          return (
            (this.lowerCanvasEl[f] = v),
            this.upperCanvasEl && (this.upperCanvasEl[f] = v),
            this.cacheCanvasEl && (this.cacheCanvasEl[f] = v),
            (this[f] = v),
            this
          );
        },
        _setCssDimension: function (f, v) {
          return (
            (this.lowerCanvasEl.style[f] = v),
            this.upperCanvasEl && (this.upperCanvasEl.style[f] = v),
            this.wrapperEl && (this.wrapperEl.style[f] = v),
            this
          );
        },
        getZoom: function () {
          return this.viewportTransform[0];
        },
        setViewportTransform: function (f) {
          var v = this._activeObject,
            y = this.backgroundImage,
            _ = this.overlayImage,
            x,
            b,
            S;
          for (
            this.viewportTransform = f, b = 0, S = this._objects.length;
            b < S;
            b++
          )
            (x = this._objects[b]), x.group || x.setCoords(!0);
          return (
            v && v.setCoords(),
            y && y.setCoords(!0),
            _ && _.setCoords(!0),
            this.calcViewportBoundaries(),
            this.renderOnAddRemove && this.requestRenderAll(),
            this
          );
        },
        zoomToPoint: function (f, v) {
          var y = f,
            _ = this.viewportTransform.slice(0);
          (f = l(f, c(this.viewportTransform))), (_[0] = v), (_[3] = v);
          var x = l(f, _);
          return (
            (_[4] += y.x - x.x),
            (_[5] += y.y - x.y),
            this.setViewportTransform(_)
          );
        },
        setZoom: function (f) {
          return this.zoomToPoint(new e.Point(0, 0), f), this;
        },
        absolutePan: function (f) {
          var v = this.viewportTransform.slice(0);
          return (v[4] = -f.x), (v[5] = -f.y), this.setViewportTransform(v);
        },
        relativePan: function (f) {
          return this.absolutePan(
            new e.Point(
              -f.x - this.viewportTransform[4],
              -f.y - this.viewportTransform[5]
            )
          );
        },
        getElement: function () {
          return this.lowerCanvasEl;
        },
        _onObjectAdded: function (f) {
          this.stateful && f.setupState(),
            f._set("canvas", this),
            f.setCoords(),
            this.fire("object:added", { target: f }),
            f.fire("added");
        },
        _onObjectRemoved: function (f) {
          this.fire("object:removed", { target: f }),
            f.fire("removed"),
            delete f.canvas;
        },
        clearContext: function (f) {
          return f.clearRect(0, 0, this.width, this.height), this;
        },
        getContext: function () {
          return this.contextContainer;
        },
        clear: function () {
          return (
            this.remove.apply(this, this.getObjects()),
            (this.backgroundImage = null),
            (this.overlayImage = null),
            (this.backgroundColor = ""),
            (this.overlayColor = ""),
            this._hasITextHandlers &&
              (this.off("mouse:up", this._mouseUpITextHandler),
              (this._iTextInstances = null),
              (this._hasITextHandlers = !1)),
            this.clearContext(this.contextContainer),
            this.fire("canvas:cleared"),
            this.renderOnAddRemove && this.requestRenderAll(),
            this
          );
        },
        renderAll: function () {
          var f = this.contextContainer;
          return this.renderCanvas(f, this._objects), this;
        },
        renderAndReset: function () {
          (this.isRendering = 0), this.renderAll();
        },
        requestRenderAll: function () {
          return (
            this.isRendering ||
              (this.isRendering = e.util.requestAnimFrame(
                this.renderAndResetBound
              )),
            this
          );
        },
        calcViewportBoundaries: function () {
          var f = {},
            v = this.width,
            y = this.height,
            _ = c(this.viewportTransform);
          return (
            (f.tl = l({ x: 0, y: 0 }, _)),
            (f.br = l({ x: v, y }, _)),
            (f.tr = new e.Point(f.br.x, f.tl.y)),
            (f.bl = new e.Point(f.tl.x, f.br.y)),
            (this.vptCoords = f),
            f
          );
        },
        cancelRequestedRender: function () {
          this.isRendering &&
            (e.util.cancelAnimFrame(this.isRendering), (this.isRendering = 0));
        },
        renderCanvas: function (f, v) {
          var y = this.viewportTransform,
            _ = this.clipPath;
          this.cancelRequestedRender(),
            this.calcViewportBoundaries(),
            this.clearContext(f),
            e.util.setImageSmoothing(f, this.imageSmoothingEnabled),
            this.fire("before:render", { ctx: f }),
            this._renderBackground(f),
            f.save(),
            f.transform(y[0], y[1], y[2], y[3], y[4], y[5]),
            this._renderObjects(f, v),
            f.restore(),
            !this.controlsAboveOverlay &&
              this.interactive &&
              this.drawControls(f),
            _ &&
              ((_.canvas = this),
              _.shouldCache(),
              (_._transformDone = !0),
              _.renderCache({ forClipping: !0 }),
              this.drawClipPathOnCanvas(f)),
            this._renderOverlay(f),
            this.controlsAboveOverlay &&
              this.interactive &&
              this.drawControls(f),
            this.fire("after:render", { ctx: f });
        },
        drawClipPathOnCanvas: function (f) {
          var v = this.viewportTransform,
            y = this.clipPath;
          f.save(),
            f.transform(v[0], v[1], v[2], v[3], v[4], v[5]),
            (f.globalCompositeOperation = "destination-in"),
            y.transform(f),
            f.scale(1 / y.zoomX, 1 / y.zoomY),
            f.drawImage(
              y._cacheCanvas,
              -y.cacheTranslationX,
              -y.cacheTranslationY
            ),
            f.restore();
        },
        _renderObjects: function (f, v) {
          var y, _;
          for (y = 0, _ = v.length; y < _; ++y) v[y] && v[y].render(f);
        },
        _renderBackgroundOrOverlay: function (f, v) {
          var y = this[v + "Color"],
            _ = this[v + "Image"],
            x = this.viewportTransform,
            b = this[v + "Vpt"];
          if (!(!y && !_)) {
            if (y) {
              f.save(),
                f.beginPath(),
                f.moveTo(0, 0),
                f.lineTo(this.width, 0),
                f.lineTo(this.width, this.height),
                f.lineTo(0, this.height),
                f.closePath(),
                (f.fillStyle = y.toLive ? y.toLive(f, this) : y),
                b && f.transform(x[0], x[1], x[2], x[3], x[4], x[5]),
                f.transform(1, 0, 0, 1, y.offsetX || 0, y.offsetY || 0);
              var S = y.gradientTransform || y.patternTransform;
              S && f.transform(S[0], S[1], S[2], S[3], S[4], S[5]),
                f.fill(),
                f.restore();
            }
            _ &&
              (f.save(),
              b && f.transform(x[0], x[1], x[2], x[3], x[4], x[5]),
              _.render(f),
              f.restore());
          }
        },
        _renderBackground: function (f) {
          this._renderBackgroundOrOverlay(f, "background");
        },
        _renderOverlay: function (f) {
          this._renderBackgroundOrOverlay(f, "overlay");
        },
        getCenter: function () {
          return { top: this.height / 2, left: this.width / 2 };
        },
        getCenterPoint: function () {
          return new e.Point(this.width / 2, this.height / 2);
        },
        centerObjectH: function (f) {
          return this._centerObject(
            f,
            new e.Point(this.getCenterPoint().x, f.getCenterPoint().y)
          );
        },
        centerObjectV: function (f) {
          return this._centerObject(
            f,
            new e.Point(f.getCenterPoint().x, this.getCenterPoint().y)
          );
        },
        centerObject: function (f) {
          var v = this.getCenterPoint();
          return this._centerObject(f, v);
        },
        viewportCenterObject: function (f) {
          var v = this.getVpCenter();
          return this._centerObject(f, v);
        },
        viewportCenterObjectH: function (f) {
          var v = this.getVpCenter();
          return (
            this._centerObject(f, new e.Point(v.x, f.getCenterPoint().y)), this
          );
        },
        viewportCenterObjectV: function (f) {
          var v = this.getVpCenter();
          return this._centerObject(f, new e.Point(f.getCenterPoint().x, v.y));
        },
        getVpCenter: function () {
          var f = this.getCenterPoint(),
            v = c(this.viewportTransform);
          return l(f, v);
        },
        _centerObject: function (f, v) {
          return (
            f.setPositionByOrigin(v, "center", "center"),
            f.setCoords(),
            this.renderOnAddRemove && this.requestRenderAll(),
            this
          );
        },
        toDatalessJSON: function (f) {
          return this.toDatalessObject(f);
        },
        toObject: function (f) {
          return this._toObjectMethod("toObject", f);
        },
        toDatalessObject: function (f) {
          return this._toObjectMethod("toDatalessObject", f);
        },
        _toObjectMethod: function (f, v) {
          var y = this.clipPath,
            _ = { version: e.version, objects: this._toObjects(f, v) };
          return (
            y &&
              !y.excludeFromExport &&
              (_.clipPath = this._toObject(this.clipPath, f, v)),
            a(_, this.__serializeBgOverlay(f, v)),
            e.util.populateWithProperties(this, _, v),
            _
          );
        },
        _toObjects: function (f, v) {
          return this._objects
            .filter(function (y) {
              return !y.excludeFromExport;
            })
            .map(function (y) {
              return this._toObject(y, f, v);
            }, this);
        },
        _toObject: function (f, v, y) {
          var _;
          this.includeDefaultValues ||
            ((_ = f.includeDefaultValues), (f.includeDefaultValues = !1));
          var x = f[v](y);
          return this.includeDefaultValues || (f.includeDefaultValues = _), x;
        },
        __serializeBgOverlay: function (f, v) {
          var y = {},
            _ = this.backgroundImage,
            x = this.overlayImage,
            b = this.backgroundColor,
            S = this.overlayColor;
          return (
            b && b.toObject
              ? b.excludeFromExport || (y.background = b.toObject(v))
              : b && (y.background = b),
            S && S.toObject
              ? S.excludeFromExport || (y.overlay = S.toObject(v))
              : S && (y.overlay = S),
            _ &&
              !_.excludeFromExport &&
              (y.backgroundImage = this._toObject(_, f, v)),
            x &&
              !x.excludeFromExport &&
              (y.overlayImage = this._toObject(x, f, v)),
            y
          );
        },
        svgViewportTransformation: !0,
        toSVG: function (f, v) {
          f || (f = {}), (f.reviver = v);
          var y = [];
          return (
            this._setSVGPreamble(y, f),
            this._setSVGHeader(y, f),
            this.clipPath &&
              y.push(
                '<g clip-path="url(#' +
                  this.clipPath.clipPathId +
                  `)" >
`
              ),
            this._setSVGBgOverlayColor(y, "background"),
            this._setSVGBgOverlayImage(y, "backgroundImage", v),
            this._setSVGObjects(y, v),
            this.clipPath &&
              y.push(`</g>
`),
            this._setSVGBgOverlayColor(y, "overlay"),
            this._setSVGBgOverlayImage(y, "overlayImage", v),
            y.push("</svg>"),
            y.join("")
          );
        },
        _setSVGPreamble: function (f, v) {
          v.suppressPreamble ||
            f.push(
              '<?xml version="1.0" encoding="',
              v.encoding || "UTF-8",
              `" standalone="no" ?>
`,
              '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
              `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`
            );
        },
        _setSVGHeader: function (f, v) {
          var y = v.width || this.width,
            _ = v.height || this.height,
            x,
            b = 'viewBox="0 0 ' + this.width + " " + this.height + '" ',
            S = e.Object.NUM_FRACTION_DIGITS;
          v.viewBox
            ? (b =
                'viewBox="' +
                v.viewBox.x +
                " " +
                v.viewBox.y +
                " " +
                v.viewBox.width +
                " " +
                v.viewBox.height +
                '" ')
            : this.svgViewportTransformation &&
              ((x = this.viewportTransform),
              (b =
                'viewBox="' +
                d(-x[4] / x[0], S) +
                " " +
                d(-x[5] / x[3], S) +
                " " +
                d(this.width / x[0], S) +
                " " +
                d(this.height / x[3], S) +
                '" ')),
            f.push(
              "<svg ",
              'xmlns="http://www.w3.org/2000/svg" ',
              'xmlns:xlink="http://www.w3.org/1999/xlink" ',
              'version="1.1" ',
              'width="',
              y,
              '" ',
              'height="',
              _,
              '" ',
              b,
              `xml:space="preserve">
`,
              "<desc>Created with Fabric.js ",
              e.version,
              `</desc>
`,
              `<defs>
`,
              this.createSVGFontFacesMarkup(),
              this.createSVGRefElementsMarkup(),
              this.createSVGClipPathMarkup(v),
              `</defs>
`
            );
        },
        createSVGClipPathMarkup: function (f) {
          var v = this.clipPath;
          return v
            ? ((v.clipPathId = "CLIPPATH_" + e.Object.__uid++),
              '<clipPath id="' +
                v.clipPathId +
                `" >
` +
                this.clipPath.toClipPathSVG(f.reviver) +
                `</clipPath>
`)
            : "";
        },
        createSVGRefElementsMarkup: function () {
          var f = this,
            v = ["background", "overlay"].map(function (y) {
              var _ = f[y + "Color"];
              if (_ && _.toLive) {
                var x = f[y + "Vpt"],
                  b = f.viewportTransform,
                  S = {
                    width: f.width / (x ? b[0] : 1),
                    height: f.height / (x ? b[3] : 1),
                  };
                return _.toSVG(S, {
                  additionalTransform: x ? e.util.matrixToSVG(b) : "",
                });
              }
            });
          return v.join("");
        },
        createSVGFontFacesMarkup: function () {
          var f = "",
            v = {},
            y,
            _,
            x,
            b,
            S,
            T,
            w,
            P,
            F,
            V = e.fontPaths,
            J = [];
          for (
            this._objects.forEach(function B(G) {
              J.push(G), G._objects && G._objects.forEach(B);
            }),
              P = 0,
              F = J.length;
            P < F;
            P++
          )
            if (
              ((y = J[P]),
              (_ = y.fontFamily),
              !(y.type.indexOf("text") === -1 || v[_] || !V[_]) &&
                ((v[_] = !0), !!y.styles))
            ) {
              x = y.styles;
              for (S in x) {
                b = x[S];
                for (w in b)
                  (T = b[w]), (_ = T.fontFamily), !v[_] && V[_] && (v[_] = !0);
              }
            }
          for (var z in v)
            f += [
              `		@font-face {
`,
              "			font-family: '",
              z,
              `';
`,
              "			src: url('",
              V[z],
              `');
`,
              `		}
`,
            ].join("");
          return (
            f &&
              (f = [
                '	<style type="text/css">',
                `<![CDATA[
`,
                f,
                "]]>",
                `</style>
`,
              ].join("")),
            f
          );
        },
        _setSVGObjects: function (f, v) {
          var y,
            _,
            x,
            b = this._objects;
          for (_ = 0, x = b.length; _ < x; _++)
            (y = b[_]), !y.excludeFromExport && this._setSVGObject(f, y, v);
        },
        _setSVGObject: function (f, v, y) {
          f.push(v.toSVG(y));
        },
        _setSVGBgOverlayImage: function (f, v, y) {
          this[v] &&
            !this[v].excludeFromExport &&
            this[v].toSVG &&
            f.push(this[v].toSVG(y));
        },
        _setSVGBgOverlayColor: function (f, v) {
          var y = this[v + "Color"],
            _ = this.viewportTransform,
            x = this.width,
            b = this.height;
          if (y)
            if (y.toLive) {
              var S = y.repeat,
                T = e.util.invertTransform(_),
                w = this[v + "Vpt"],
                P = w ? e.util.matrixToSVG(T) : "";
              f.push(
                '<rect transform="' + P + " translate(",
                x / 2,
                ",",
                b / 2,
                ')"',
                ' x="',
                y.offsetX - x / 2,
                '" y="',
                y.offsetY - b / 2,
                '" ',
                'width="',
                S === "repeat-y" || S === "no-repeat" ? y.source.width : x,
                '" height="',
                S === "repeat-x" || S === "no-repeat" ? y.source.height : b,
                '" fill="url(#SVGID_' + y.id + ')"',
                `></rect>
`
              );
            } else
              f.push(
                '<rect x="0" y="0" width="100%" height="100%" ',
                'fill="',
                y,
                '"',
                `></rect>
`
              );
        },
        sendToBack: function (f) {
          if (!f) return this;
          var v = this._activeObject,
            y,
            _,
            x;
          if (f === v && f.type === "activeSelection")
            for (x = v._objects, y = x.length; y--; )
              (_ = x[y]), u(this._objects, _), this._objects.unshift(_);
          else u(this._objects, f), this._objects.unshift(f);
          return this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        bringToFront: function (f) {
          if (!f) return this;
          var v = this._activeObject,
            y,
            _,
            x;
          if (f === v && f.type === "activeSelection")
            for (x = v._objects, y = 0; y < x.length; y++)
              (_ = x[y]), u(this._objects, _), this._objects.push(_);
          else u(this._objects, f), this._objects.push(f);
          return this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        sendBackwards: function (f, v) {
          if (!f) return this;
          var y = this._activeObject,
            _,
            x,
            b,
            S,
            T,
            w = 0;
          if (f === y && f.type === "activeSelection")
            for (T = y._objects, _ = 0; _ < T.length; _++)
              (x = T[_]),
                (b = this._objects.indexOf(x)),
                b > 0 + w &&
                  ((S = b - 1),
                  u(this._objects, x),
                  this._objects.splice(S, 0, x)),
                w++;
          else
            (b = this._objects.indexOf(f)),
              b !== 0 &&
                ((S = this._findNewLowerIndex(f, b, v)),
                u(this._objects, f),
                this._objects.splice(S, 0, f));
          return this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        _findNewLowerIndex: function (f, v, y) {
          var _, x;
          if (y)
            for (_ = v, x = v - 1; x >= 0; --x) {
              var b =
                f.intersectsWithObject(this._objects[x]) ||
                f.isContainedWithinObject(this._objects[x]) ||
                this._objects[x].isContainedWithinObject(f);
              if (b) {
                _ = x;
                break;
              }
            }
          else _ = v - 1;
          return _;
        },
        bringForward: function (f, v) {
          if (!f) return this;
          var y = this._activeObject,
            _,
            x,
            b,
            S,
            T,
            w = 0;
          if (f === y && f.type === "activeSelection")
            for (T = y._objects, _ = T.length; _--; )
              (x = T[_]),
                (b = this._objects.indexOf(x)),
                b < this._objects.length - 1 - w &&
                  ((S = b + 1),
                  u(this._objects, x),
                  this._objects.splice(S, 0, x)),
                w++;
          else
            (b = this._objects.indexOf(f)),
              b !== this._objects.length - 1 &&
                ((S = this._findNewUpperIndex(f, b, v)),
                u(this._objects, f),
                this._objects.splice(S, 0, f));
          return this.renderOnAddRemove && this.requestRenderAll(), this;
        },
        _findNewUpperIndex: function (f, v, y) {
          var _, x, b;
          if (y)
            for (_ = v, x = v + 1, b = this._objects.length; x < b; ++x) {
              var S =
                f.intersectsWithObject(this._objects[x]) ||
                f.isContainedWithinObject(this._objects[x]) ||
                this._objects[x].isContainedWithinObject(f);
              if (S) {
                _ = x;
                break;
              }
            }
          else _ = v + 1;
          return _;
        },
        moveTo: function (f, v) {
          return (
            u(this._objects, f),
            this._objects.splice(v, 0, f),
            this.renderOnAddRemove && this.requestRenderAll()
          );
        },
        dispose: function () {
          return (
            this.isRendering &&
              (e.util.cancelAnimFrame(this.isRendering),
              (this.isRendering = 0)),
            this.forEachObject(function (f) {
              f.dispose && f.dispose();
            }),
            (this._objects = []),
            this.backgroundImage &&
              this.backgroundImage.dispose &&
              this.backgroundImage.dispose(),
            (this.backgroundImage = null),
            this.overlayImage &&
              this.overlayImage.dispose &&
              this.overlayImage.dispose(),
            (this.overlayImage = null),
            (this._iTextInstances = null),
            (this.contextContainer = null),
            this.lowerCanvasEl.classList.remove("lower-canvas"),
            e.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle),
            delete this._originalCanvasStyle,
            this.lowerCanvasEl.setAttribute("width", this.width),
            this.lowerCanvasEl.setAttribute("height", this.height),
            e.util.cleanUpJsdomNode(this.lowerCanvasEl),
            (this.lowerCanvasEl = void 0),
            this
          );
        },
        toString: function () {
          return (
            "#<fabric.Canvas (" +
            this.complexity() +
            "): { objects: " +
            this._objects.length +
            " }>"
          );
        },
      })),
        a(e.StaticCanvas.prototype, e.Observable),
        a(e.StaticCanvas.prototype, e.Collection),
        a(e.StaticCanvas.prototype, e.DataURLExporter),
        a(e.StaticCanvas, {
          EMPTY_JSON: '{"objects": [], "background": "white"}',
          supports: function (f) {
            var v = m();
            if (!v || !v.getContext) return null;
            var y = v.getContext("2d");
            if (!y) return null;
            switch (f) {
              case "setLineDash":
                return typeof y.setLineDash < "u";
              default:
                return null;
            }
          },
        }),
        (e.StaticCanvas.prototype.toJSON = e.StaticCanvas.prototype.toObject),
        e.isLikelyNode &&
          ((e.StaticCanvas.prototype.createPNGStream = function () {
            var f = h(this.lowerCanvasEl);
            return f && f.createPNGStream();
          }),
          (e.StaticCanvas.prototype.createJPEGStream = function (f) {
            var v = h(this.lowerCanvasEl);
            return v && v.createJPEGStream(f);
          }));
    })(),
    (e.BaseBrush = e.util.createClass({
      color: "rgb(0, 0, 0)",
      width: 1,
      shadow: null,
      strokeLineCap: "round",
      strokeLineJoin: "round",
      strokeMiterLimit: 10,
      strokeDashArray: null,
      limitedToCanvasSize: !1,
      _setBrushStyles: function (a) {
        (a.strokeStyle = this.color),
          (a.lineWidth = this.width),
          (a.lineCap = this.strokeLineCap),
          (a.miterLimit = this.strokeMiterLimit),
          (a.lineJoin = this.strokeLineJoin),
          a.setLineDash(this.strokeDashArray || []);
      },
      _saveAndTransform: function (a) {
        var s = this.canvas.viewportTransform;
        a.save(), a.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
      },
      _setShadow: function () {
        if (this.shadow) {
          var a = this.canvas,
            s = this.shadow,
            u = a.contextTop,
            d = a.getZoom();
          a && a._isRetinaScaling() && (d *= e.devicePixelRatio),
            (u.shadowColor = s.color),
            (u.shadowBlur = s.blur * d),
            (u.shadowOffsetX = s.offsetX * d),
            (u.shadowOffsetY = s.offsetY * d);
        }
      },
      needsFullRender: function () {
        var a = new e.Color(this.color);
        return a.getAlpha() < 1 || !!this.shadow;
      },
      _resetShadow: function () {
        var a = this.canvas.contextTop;
        (a.shadowColor = ""),
          (a.shadowBlur = a.shadowOffsetX = a.shadowOffsetY = 0);
      },
      _isOutSideCanvas: function (a) {
        return (
          a.x < 0 ||
          a.x > this.canvas.getWidth() ||
          a.y < 0 ||
          a.y > this.canvas.getHeight()
        );
      },
    })),
    (function () {
      e.PencilBrush = e.util.createClass(e.BaseBrush, {
        decimate: 0.4,
        drawStraightLine: !1,
        straightLineKey: "shiftKey",
        initialize: function (a) {
          (this.canvas = a), (this._points = []);
        },
        needsFullRender: function () {
          return this.callSuper("needsFullRender") || this._hasStraightLine;
        },
        _drawSegment: function (a, s, u) {
          var d = s.midPointFrom(u);
          return a.quadraticCurveTo(s.x, s.y, d.x, d.y), d;
        },
        onMouseDown: function (a, s) {
          this.canvas._isMainEvent(s.e) &&
            ((this.drawStraightLine = s.e[this.straightLineKey]),
            this._prepareForDrawing(a),
            this._captureDrawingPath(a),
            this._render());
        },
        onMouseMove: function (a, s) {
          if (
            this.canvas._isMainEvent(s.e) &&
            ((this.drawStraightLine = s.e[this.straightLineKey]),
            !(this.limitedToCanvasSize === !0 && this._isOutSideCanvas(a)) &&
              this._captureDrawingPath(a) &&
              this._points.length > 1)
          )
            if (this.needsFullRender())
              this.canvas.clearContext(this.canvas.contextTop), this._render();
            else {
              var u = this._points,
                d = u.length,
                l = this.canvas.contextTop;
              this._saveAndTransform(l),
                this.oldEnd &&
                  (l.beginPath(), l.moveTo(this.oldEnd.x, this.oldEnd.y)),
                (this.oldEnd = this._drawSegment(l, u[d - 2], u[d - 1], !0)),
                l.stroke(),
                l.restore();
            }
        },
        onMouseUp: function (a) {
          return this.canvas._isMainEvent(a.e)
            ? ((this.drawStraightLine = !1),
              (this.oldEnd = void 0),
              this._finalizeAndAddPath(),
              !1)
            : !0;
        },
        _prepareForDrawing: function (a) {
          var s = new e.Point(a.x, a.y);
          this._reset(),
            this._addPoint(s),
            this.canvas.contextTop.moveTo(s.x, s.y);
        },
        _addPoint: function (a) {
          return this._points.length > 1 &&
            a.eq(this._points[this._points.length - 1])
            ? !1
            : (this.drawStraightLine &&
                this._points.length > 1 &&
                ((this._hasStraightLine = !0), this._points.pop()),
              this._points.push(a),
              !0);
        },
        _reset: function () {
          (this._points = []),
            this._setBrushStyles(this.canvas.contextTop),
            this._setShadow(),
            (this._hasStraightLine = !1);
        },
        _captureDrawingPath: function (a) {
          var s = new e.Point(a.x, a.y);
          return this._addPoint(s);
        },
        _render: function (a) {
          var s,
            u,
            d = this._points[0],
            l = this._points[1];
          if (
            ((a = a || this.canvas.contextTop),
            this._saveAndTransform(a),
            a.beginPath(),
            this._points.length === 2 && d.x === l.x && d.y === l.y)
          ) {
            var c = this.width / 1e3;
            (d = new e.Point(d.x, d.y)),
              (l = new e.Point(l.x, l.y)),
              (d.x -= c),
              (l.x += c);
          }
          for (a.moveTo(d.x, d.y), s = 1, u = this._points.length; s < u; s++)
            this._drawSegment(a, d, l),
              (d = this._points[s]),
              (l = this._points[s + 1]);
          a.lineTo(d.x, d.y), a.stroke(), a.restore();
        },
        convertPointsToSVGPath: function (a) {
          var s = this.width / 1e3;
          return e.util.getSmoothPathFromPoints(a, s);
        },
        _isEmptySVGPath: function (a) {
          var s = e.util.joinPath(a);
          return s === "M 0 0 Q 0 0 0 0 L 0 0";
        },
        createPath: function (a) {
          var s = new e.Path(a, {
            fill: null,
            stroke: this.color,
            strokeWidth: this.width,
            strokeLineCap: this.strokeLineCap,
            strokeMiterLimit: this.strokeMiterLimit,
            strokeLineJoin: this.strokeLineJoin,
            strokeDashArray: this.strokeDashArray,
          });
          return (
            this.shadow &&
              ((this.shadow.affectStroke = !0),
              (s.shadow = new e.Shadow(this.shadow))),
            s
          );
        },
        decimatePoints: function (a, s) {
          if (a.length <= 2) return a;
          var u = this.canvas.getZoom(),
            d = Math.pow(s / u, 2),
            l,
            c = a.length - 1,
            h = a[0],
            m = [h],
            g;
          for (l = 1; l < c - 1; l++)
            (g = Math.pow(h.x - a[l].x, 2) + Math.pow(h.y - a[l].y, 2)),
              g >= d && ((h = a[l]), m.push(h));
          return m.push(a[c]), m;
        },
        _finalizeAndAddPath: function () {
          var a = this.canvas.contextTop;
          a.closePath(),
            this.decimate &&
              (this._points = this.decimatePoints(this._points, this.decimate));
          var s = this.convertPointsToSVGPath(this._points);
          if (this._isEmptySVGPath(s)) {
            this.canvas.requestRenderAll();
            return;
          }
          var u = this.createPath(s);
          this.canvas.clearContext(this.canvas.contextTop),
            this.canvas.fire("before:path:created", { path: u }),
            this.canvas.add(u),
            this.canvas.requestRenderAll(),
            u.setCoords(),
            this._resetShadow(),
            this.canvas.fire("path:created", { path: u });
        },
      });
    })(),
    (e.CircleBrush = e.util.createClass(e.BaseBrush, {
      width: 10,
      initialize: function (a) {
        (this.canvas = a), (this.points = []);
      },
      drawDot: function (a) {
        var s = this.addPoint(a),
          u = this.canvas.contextTop;
        this._saveAndTransform(u), this.dot(u, s), u.restore();
      },
      dot: function (a, s) {
        (a.fillStyle = s.fill),
          a.beginPath(),
          a.arc(s.x, s.y, s.radius, 0, Math.PI * 2, !1),
          a.closePath(),
          a.fill();
      },
      onMouseDown: function (a) {
        (this.points.length = 0),
          this.canvas.clearContext(this.canvas.contextTop),
          this._setShadow(),
          this.drawDot(a);
      },
      _render: function () {
        var a = this.canvas.contextTop,
          s,
          u,
          d = this.points;
        for (this._saveAndTransform(a), s = 0, u = d.length; s < u; s++)
          this.dot(a, d[s]);
        a.restore();
      },
      onMouseMove: function (a) {
        (this.limitedToCanvasSize === !0 && this._isOutSideCanvas(a)) ||
          (this.needsFullRender()
            ? (this.canvas.clearContext(this.canvas.contextTop),
              this.addPoint(a),
              this._render())
            : this.drawDot(a));
      },
      onMouseUp: function () {
        var a = this.canvas.renderOnAddRemove,
          s,
          u;
        this.canvas.renderOnAddRemove = !1;
        var d = [];
        for (s = 0, u = this.points.length; s < u; s++) {
          var l = this.points[s],
            c = new e.Circle({
              radius: l.radius,
              left: l.x,
              top: l.y,
              originX: "center",
              originY: "center",
              fill: l.fill,
            });
          this.shadow && (c.shadow = new e.Shadow(this.shadow)), d.push(c);
        }
        var h = new e.Group(d);
        (h.canvas = this.canvas),
          this.canvas.fire("before:path:created", { path: h }),
          this.canvas.add(h),
          this.canvas.fire("path:created", { path: h }),
          this.canvas.clearContext(this.canvas.contextTop),
          this._resetShadow(),
          (this.canvas.renderOnAddRemove = a),
          this.canvas.requestRenderAll();
      },
      addPoint: function (a) {
        var s = new e.Point(a.x, a.y),
          u =
            e.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) /
            2,
          d = new e.Color(this.color)
            .setAlpha(e.util.getRandomInt(0, 100) / 100)
            .toRgba();
        return (s.radius = u), (s.fill = d), this.points.push(s), s;
      },
    })),
    (e.SprayBrush = e.util.createClass(e.BaseBrush, {
      width: 10,
      density: 20,
      dotWidth: 1,
      dotWidthVariance: 1,
      randomOpacity: !1,
      optimizeOverlapping: !0,
      initialize: function (a) {
        (this.canvas = a), (this.sprayChunks = []);
      },
      onMouseDown: function (a) {
        (this.sprayChunks.length = 0),
          this.canvas.clearContext(this.canvas.contextTop),
          this._setShadow(),
          this.addSprayChunk(a),
          this.render(this.sprayChunkPoints);
      },
      onMouseMove: function (a) {
        (this.limitedToCanvasSize === !0 && this._isOutSideCanvas(a)) ||
          (this.addSprayChunk(a), this.render(this.sprayChunkPoints));
      },
      onMouseUp: function () {
        var a = this.canvas.renderOnAddRemove;
        this.canvas.renderOnAddRemove = !1;
        for (var s = [], u = 0, d = this.sprayChunks.length; u < d; u++)
          for (var l = this.sprayChunks[u], c = 0, h = l.length; c < h; c++) {
            var m = new e.Rect({
              width: l[c].width,
              height: l[c].width,
              left: l[c].x + 1,
              top: l[c].y + 1,
              originX: "center",
              originY: "center",
              fill: this.color,
            });
            s.push(m);
          }
        this.optimizeOverlapping && (s = this._getOptimizedRects(s));
        var g = new e.Group(s);
        this.shadow && g.set("shadow", new e.Shadow(this.shadow)),
          this.canvas.fire("before:path:created", { path: g }),
          this.canvas.add(g),
          this.canvas.fire("path:created", { path: g }),
          this.canvas.clearContext(this.canvas.contextTop),
          this._resetShadow(),
          (this.canvas.renderOnAddRemove = a),
          this.canvas.requestRenderAll();
      },
      _getOptimizedRects: function (a) {
        var s = {},
          u,
          d,
          l;
        for (d = 0, l = a.length; d < l; d++)
          (u = a[d].left + "" + a[d].top), s[u] || (s[u] = a[d]);
        var c = [];
        for (u in s) c.push(s[u]);
        return c;
      },
      render: function (a) {
        var s = this.canvas.contextTop,
          u,
          d;
        for (
          s.fillStyle = this.color,
            this._saveAndTransform(s),
            u = 0,
            d = a.length;
          u < d;
          u++
        ) {
          var l = a[u];
          typeof l.opacity < "u" && (s.globalAlpha = l.opacity),
            s.fillRect(l.x, l.y, l.width, l.width);
        }
        s.restore();
      },
      _render: function () {
        var a = this.canvas.contextTop,
          s,
          u;
        for (
          a.fillStyle = this.color,
            this._saveAndTransform(a),
            s = 0,
            u = this.sprayChunks.length;
          s < u;
          s++
        )
          this.render(this.sprayChunks[s]);
        a.restore();
      },
      addSprayChunk: function (a) {
        this.sprayChunkPoints = [];
        var s,
          u,
          d,
          l = this.width / 2,
          c;
        for (c = 0; c < this.density; c++) {
          (s = e.util.getRandomInt(a.x - l, a.x + l)),
            (u = e.util.getRandomInt(a.y - l, a.y + l)),
            this.dotWidthVariance
              ? (d = e.util.getRandomInt(
                  Math.max(1, this.dotWidth - this.dotWidthVariance),
                  this.dotWidth + this.dotWidthVariance
                ))
              : (d = this.dotWidth);
          var h = new e.Point(s, u);
          (h.width = d),
            this.randomOpacity &&
              (h.opacity = e.util.getRandomInt(0, 100) / 100),
            this.sprayChunkPoints.push(h);
        }
        this.sprayChunks.push(this.sprayChunkPoints);
      },
    })),
    (e.PatternBrush = e.util.createClass(e.PencilBrush, {
      getPatternSrc: function () {
        var a = 20,
          s = 5,
          u = e.util.createCanvasElement(),
          d = u.getContext("2d");
        return (
          (u.width = u.height = a + s),
          (d.fillStyle = this.color),
          d.beginPath(),
          d.arc(a / 2, a / 2, a / 2, 0, Math.PI * 2, !1),
          d.closePath(),
          d.fill(),
          u
        );
      },
      getPatternSrcFunction: function () {
        return String(this.getPatternSrc).replace(
          "this.color",
          '"' + this.color + '"'
        );
      },
      getPattern: function (a) {
        return a.createPattern(this.source || this.getPatternSrc(), "repeat");
      },
      _setBrushStyles: function (a) {
        this.callSuper("_setBrushStyles", a),
          (a.strokeStyle = this.getPattern(a));
      },
      createPath: function (a) {
        var s = this.callSuper("createPath", a),
          u = s._getLeftTopCoords().scalarAdd(s.strokeWidth / 2);
        return (
          (s.stroke = new e.Pattern({
            source: this.source || this.getPatternSrcFunction(),
            offsetX: -u.x,
            offsetY: -u.y,
          })),
          s
        );
      },
    })),
    (function () {
      var a = e.util.getPointer,
        s = e.util.degreesToRadians,
        u = e.util.isTouchEvent;
      e.Canvas = e.util.createClass(e.StaticCanvas, {
        initialize: function (l, c) {
          c || (c = {}),
            (this.renderAndResetBound = this.renderAndReset.bind(this)),
            (this.requestRenderAllBound = this.requestRenderAll.bind(this)),
            this._initStatic(l, c),
            this._initInteractive(),
            this._createCacheCanvas();
        },
        uniformScaling: !0,
        uniScaleKey: "shiftKey",
        centeredScaling: !1,
        centeredRotation: !1,
        centeredKey: "altKey",
        altActionKey: "shiftKey",
        interactive: !0,
        selection: !0,
        selectionKey: "shiftKey",
        altSelectionKey: null,
        selectionColor: "rgba(100, 100, 255, 0.3)",
        selectionDashArray: [],
        selectionBorderColor: "rgba(255, 255, 255, 0.3)",
        selectionLineWidth: 1,
        selectionFullyContained: !1,
        hoverCursor: "move",
        moveCursor: "move",
        defaultCursor: "default",
        freeDrawingCursor: "crosshair",
        notAllowedCursor: "not-allowed",
        containerClass: "canvas-container",
        perPixelTargetFind: !1,
        targetFindTolerance: 0,
        skipTargetFind: !1,
        isDrawingMode: !1,
        preserveObjectStacking: !1,
        snapAngle: 0,
        snapThreshold: null,
        stopContextMenu: !1,
        fireRightClick: !1,
        fireMiddleClick: !1,
        targets: [],
        enablePointerEvents: !1,
        _hoveredTarget: null,
        _hoveredTargets: [],
        _initInteractive: function () {
          (this._currentTransform = null),
            (this._groupSelector = null),
            this._initWrapperElement(),
            this._createUpperCanvas(),
            this._initEventListeners(),
            this._initRetinaScaling(),
            (this.freeDrawingBrush = e.PencilBrush && new e.PencilBrush(this)),
            this.calcOffset();
        },
        _chooseObjectsToRender: function () {
          var l = this.getActiveObjects(),
            c,
            h,
            m;
          if (l.length > 0 && !this.preserveObjectStacking) {
            (h = []), (m = []);
            for (var g = 0, f = this._objects.length; g < f; g++)
              (c = this._objects[g]),
                l.indexOf(c) === -1 ? h.push(c) : m.push(c);
            l.length > 1 && (this._activeObject._objects = m),
              h.push.apply(h, m);
          } else h = this._objects;
          return h;
        },
        renderAll: function () {
          this.contextTopDirty &&
            !this._groupSelector &&
            !this.isDrawingMode &&
            (this.clearContext(this.contextTop), (this.contextTopDirty = !1)),
            this.hasLostContext &&
              (this.renderTopLayer(this.contextTop),
              (this.hasLostContext = !1));
          var l = this.contextContainer;
          return this.renderCanvas(l, this._chooseObjectsToRender()), this;
        },
        renderTopLayer: function (l) {
          l.save(),
            this.isDrawingMode &&
              this._isCurrentlyDrawing &&
              (this.freeDrawingBrush && this.freeDrawingBrush._render(),
              (this.contextTopDirty = !0)),
            this.selection &&
              this._groupSelector &&
              (this._drawSelection(l), (this.contextTopDirty = !0)),
            l.restore();
        },
        renderTop: function () {
          var l = this.contextTop;
          return (
            this.clearContext(l),
            this.renderTopLayer(l),
            this.fire("after:render"),
            this
          );
        },
        _normalizePointer: function (l, c) {
          var h = l.calcTransformMatrix(),
            m = e.util.invertTransform(h),
            g = this.restorePointerVpt(c);
          return e.util.transformPoint(g, m);
        },
        isTargetTransparent: function (l, c, h) {
          if (l.shouldCache() && l._cacheCanvas && l !== this._activeObject) {
            var m = this._normalizePointer(l, { x: c, y: h }),
              g = Math.max(l.cacheTranslationX + m.x * l.zoomX, 0),
              f = Math.max(l.cacheTranslationY + m.y * l.zoomY, 0),
              x = e.util.isTransparent(
                l._cacheContext,
                Math.round(g),
                Math.round(f),
                this.targetFindTolerance
              );
            return x;
          }
          var v = this.contextCache,
            y = l.selectionBackgroundColor,
            _ = this.viewportTransform;
          (l.selectionBackgroundColor = ""),
            this.clearContext(v),
            v.save(),
            v.transform(_[0], _[1], _[2], _[3], _[4], _[5]),
            l.render(v),
            v.restore(),
            (l.selectionBackgroundColor = y);
          var x = e.util.isTransparent(v, c, h, this.targetFindTolerance);
          return x;
        },
        _isSelectionKeyPressed: function (l) {
          var c = !1;
          return (
            Array.isArray(this.selectionKey)
              ? (c = !!this.selectionKey.find(function (h) {
                  return l[h] === !0;
                }))
              : (c = l[this.selectionKey]),
            c
          );
        },
        _shouldClearSelection: function (l, c) {
          var h = this.getActiveObjects(),
            m = this._activeObject;
          return (
            !c ||
            (c &&
              m &&
              h.length > 1 &&
              h.indexOf(c) === -1 &&
              m !== c &&
              !this._isSelectionKeyPressed(l)) ||
            (c && !c.evented) ||
            (c && !c.selectable && m && m !== c)
          );
        },
        _shouldCenterTransform: function (l, c, h) {
          if (l) {
            var m;
            return (
              c === "scale" ||
              c === "scaleX" ||
              c === "scaleY" ||
              c === "resizing"
                ? (m = this.centeredScaling || l.centeredScaling)
                : c === "rotate" &&
                  (m = this.centeredRotation || l.centeredRotation),
              m ? !h : h
            );
          }
        },
        _getOriginFromCorner: function (l, c) {
          var h = { x: l.originX, y: l.originY };
          return (
            c === "ml" || c === "tl" || c === "bl"
              ? (h.x = "right")
              : (c === "mr" || c === "tr" || c === "br") && (h.x = "left"),
            c === "tl" || c === "mt" || c === "tr"
              ? (h.y = "bottom")
              : (c === "bl" || c === "mb" || c === "br") && (h.y = "top"),
            h
          );
        },
        _getActionFromCorner: function (l, c, h, m) {
          if (!c || !l) return "drag";
          var g = m.controls[c];
          return g.getActionName(h, g, m);
        },
        _setupCurrentTransform: function (l, c, h) {
          if (c) {
            var m = this.getPointer(l),
              g = c.__corner,
              f = c.controls[g],
              v =
                h && g
                  ? f.getActionHandler(l, c, f)
                  : e.controlsUtils.dragHandler,
              y = this._getActionFromCorner(h, g, l, c),
              _ = this._getOriginFromCorner(c, g),
              x = l[this.centeredKey],
              b = {
                target: c,
                action: y,
                actionHandler: v,
                corner: g,
                scaleX: c.scaleX,
                scaleY: c.scaleY,
                skewX: c.skewX,
                skewY: c.skewY,
                offsetX: m.x - c.left,
                offsetY: m.y - c.top,
                originX: _.x,
                originY: _.y,
                ex: m.x,
                ey: m.y,
                lastX: m.x,
                lastY: m.y,
                theta: s(c.angle),
                width: c.width * c.scaleX,
                shiftKey: l.shiftKey,
                altKey: x,
                original: e.util.saveObjectTransform(c),
              };
            this._shouldCenterTransform(c, y, x) &&
              ((b.originX = "center"), (b.originY = "center")),
              (b.original.originX = _.x),
              (b.original.originY = _.y),
              (this._currentTransform = b),
              this._beforeTransform(l);
          }
        },
        setCursor: function (l) {
          this.upperCanvasEl.style.cursor = l;
        },
        _drawSelection: function (l) {
          var c = this._groupSelector,
            h = new e.Point(c.ex, c.ey),
            m = e.util.transformPoint(h, this.viewportTransform),
            g = new e.Point(c.ex + c.left, c.ey + c.top),
            f = e.util.transformPoint(g, this.viewportTransform),
            v = Math.min(m.x, f.x),
            y = Math.min(m.y, f.y),
            _ = Math.max(m.x, f.x),
            x = Math.max(m.y, f.y),
            b = this.selectionLineWidth / 2;
          this.selectionColor &&
            ((l.fillStyle = this.selectionColor),
            l.fillRect(v, y, _ - v, x - y)),
            !(!this.selectionLineWidth || !this.selectionBorderColor) &&
              ((l.lineWidth = this.selectionLineWidth),
              (l.strokeStyle = this.selectionBorderColor),
              (v += b),
              (y += b),
              (_ -= b),
              (x -= b),
              e.Object.prototype._setLineDash.call(
                this,
                l,
                this.selectionDashArray
              ),
              l.strokeRect(v, y, _ - v, x - y));
        },
        findTarget: function (l, c) {
          if (!this.skipTargetFind) {
            var h = !0,
              m = this.getPointer(l, h),
              g = this._activeObject,
              f = this.getActiveObjects(),
              v,
              y,
              _ = u(l),
              x = (f.length > 1 && !c) || f.length === 1;
            if (
              ((this.targets = []),
              (x && g._findTargetCorner(m, _)) ||
                (f.length > 1 &&
                  !c &&
                  g === this._searchPossibleTargets([g], m)))
            )
              return g;
            if (f.length === 1 && g === this._searchPossibleTargets([g], m))
              if (this.preserveObjectStacking)
                (v = g), (y = this.targets), (this.targets = []);
              else return g;
            var b = this._searchPossibleTargets(this._objects, m);
            return (
              l[this.altSelectionKey] &&
                b &&
                v &&
                b !== v &&
                ((b = v), (this.targets = y)),
              b
            );
          }
        },
        _checkTarget: function (l, c, h) {
          if (c && c.visible && c.evented && c.containsPoint(l))
            if (
              (this.perPixelTargetFind || c.perPixelTargetFind) &&
              !c.isEditing
            ) {
              var m = this.isTargetTransparent(c, h.x, h.y);
              if (!m) return !0;
            } else return !0;
        },
        _searchPossibleTargets: function (l, c) {
          for (var h, m = l.length, g; m--; ) {
            var f = l[m],
              v = f.group ? this._normalizePointer(f.group, c) : c;
            if (this._checkTarget(v, f, c)) {
              (h = l[m]),
                h.subTargetCheck &&
                  h instanceof e.Group &&
                  ((g = this._searchPossibleTargets(h._objects, c)),
                  g && this.targets.push(g));
              break;
            }
          }
          return h;
        },
        restorePointerVpt: function (l) {
          return e.util.transformPoint(
            l,
            e.util.invertTransform(this.viewportTransform)
          );
        },
        getPointer: function (l, c) {
          if (this._absolutePointer && !c) return this._absolutePointer;
          if (this._pointer && c) return this._pointer;
          var h = a(l),
            m = this.upperCanvasEl,
            g = m.getBoundingClientRect(),
            f = g.width || 0,
            v = g.height || 0,
            y;
          (!f || !v) &&
            ("top" in g && "bottom" in g && (v = Math.abs(g.top - g.bottom)),
            "right" in g && "left" in g && (f = Math.abs(g.right - g.left))),
            this.calcOffset(),
            (h.x = h.x - this._offset.left),
            (h.y = h.y - this._offset.top),
            c || (h = this.restorePointerVpt(h));
          var _ = this.getRetinaScaling();
          return (
            _ !== 1 && ((h.x /= _), (h.y /= _)),
            f === 0 || v === 0
              ? (y = { width: 1, height: 1 })
              : (y = { width: m.width / f, height: m.height / v }),
            { x: h.x * y.width, y: h.y * y.height }
          );
        },
        _createUpperCanvas: function () {
          var l = this.lowerCanvasEl.className.replace(
              /\s*lower-canvas\s*/,
              ""
            ),
            c = this.lowerCanvasEl,
            h = this.upperCanvasEl;
          h
            ? (h.className = "")
            : ((h = this._createCanvasElement()), (this.upperCanvasEl = h)),
            e.util.addClass(h, "upper-canvas " + l),
            this.wrapperEl.appendChild(h),
            this._copyCanvasStyle(c, h),
            this._applyCanvasStyle(h),
            (this.contextTop = h.getContext("2d"));
        },
        getTopContext: function () {
          return this.contextTop;
        },
        _createCacheCanvas: function () {
          (this.cacheCanvasEl = this._createCanvasElement()),
            this.cacheCanvasEl.setAttribute("width", this.width),
            this.cacheCanvasEl.setAttribute("height", this.height),
            (this.contextCache = this.cacheCanvasEl.getContext("2d"));
        },
        _initWrapperElement: function () {
          (this.wrapperEl = e.util.wrapElement(this.lowerCanvasEl, "div", {
            class: this.containerClass,
          })),
            e.util.setStyle(this.wrapperEl, {
              width: this.width + "px",
              height: this.height + "px",
              position: "relative",
            }),
            e.util.makeElementUnselectable(this.wrapperEl);
        },
        _applyCanvasStyle: function (l) {
          var c = this.width || l.width,
            h = this.height || l.height;
          e.util.setStyle(l, {
            position: "absolute",
            width: c + "px",
            height: h + "px",
            left: 0,
            top: 0,
            "touch-action": this.allowTouchScrolling ? "manipulation" : "none",
            "-ms-touch-action": this.allowTouchScrolling
              ? "manipulation"
              : "none",
          }),
            (l.width = c),
            (l.height = h),
            e.util.makeElementUnselectable(l);
        },
        _copyCanvasStyle: function (l, c) {
          c.style.cssText = l.style.cssText;
        },
        getSelectionContext: function () {
          return this.contextTop;
        },
        getSelectionElement: function () {
          return this.upperCanvasEl;
        },
        getActiveObject: function () {
          return this._activeObject;
        },
        getActiveObjects: function () {
          var l = this._activeObject;
          return l
            ? l.type === "activeSelection" && l._objects
              ? l._objects.slice(0)
              : [l]
            : [];
        },
        _onObjectRemoved: function (l) {
          l === this._activeObject &&
            (this.fire("before:selection:cleared", { target: l }),
            this._discardActiveObject(),
            this.fire("selection:cleared", { target: l }),
            l.fire("deselected")),
            l === this._hoveredTarget &&
              ((this._hoveredTarget = null), (this._hoveredTargets = [])),
            this.callSuper("_onObjectRemoved", l);
        },
        _fireSelectionEvents: function (l, c) {
          var h = !1,
            m = this.getActiveObjects(),
            g = [],
            f = [];
          l.forEach(function (v) {
            m.indexOf(v) === -1 &&
              ((h = !0), v.fire("deselected", { e: c, target: v }), f.push(v));
          }),
            m.forEach(function (v) {
              l.indexOf(v) === -1 &&
                ((h = !0), v.fire("selected", { e: c, target: v }), g.push(v));
            }),
            l.length > 0 && m.length > 0
              ? h &&
                this.fire("selection:updated", {
                  e: c,
                  selected: g,
                  deselected: f,
                })
              : m.length > 0
              ? this.fire("selection:created", { e: c, selected: g })
              : l.length > 0 &&
                this.fire("selection:cleared", { e: c, deselected: f });
        },
        setActiveObject: function (l, c) {
          var h = this.getActiveObjects();
          return (
            this._setActiveObject(l, c), this._fireSelectionEvents(h, c), this
          );
        },
        _setActiveObject: function (l, c) {
          return this._activeObject === l ||
            !this._discardActiveObject(c, l) ||
            l.onSelect({ e: c })
            ? !1
            : ((this._activeObject = l), !0);
        },
        _discardActiveObject: function (l, c) {
          var h = this._activeObject;
          if (h) {
            if (h.onDeselect({ e: l, object: c })) return !1;
            this._activeObject = null;
          }
          return !0;
        },
        discardActiveObject: function (l) {
          var c = this.getActiveObjects(),
            h = this.getActiveObject();
          return (
            c.length &&
              this.fire("before:selection:cleared", { target: h, e: l }),
            this._discardActiveObject(l),
            this._fireSelectionEvents(c, l),
            this
          );
        },
        dispose: function () {
          var l = this.wrapperEl;
          return (
            this.removeListeners(),
            l.removeChild(this.upperCanvasEl),
            l.removeChild(this.lowerCanvasEl),
            (this.contextCache = null),
            (this.contextTop = null),
            ["upperCanvasEl", "cacheCanvasEl"].forEach(
              function (c) {
                e.util.cleanUpJsdomNode(this[c]), (this[c] = void 0);
              }.bind(this)
            ),
            l.parentNode &&
              l.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl),
            delete this.wrapperEl,
            e.StaticCanvas.prototype.dispose.call(this),
            this
          );
        },
        clear: function () {
          return (
            this.discardActiveObject(),
            this.clearContext(this.contextTop),
            this.callSuper("clear")
          );
        },
        drawControls: function (l) {
          var c = this._activeObject;
          c && c._renderControls(l);
        },
        _toObject: function (l, c, h) {
          var m = this._realizeGroupTransformOnObject(l),
            g = this.callSuper("_toObject", l, c, h);
          return this._unwindGroupTransformOnObject(l, m), g;
        },
        _realizeGroupTransformOnObject: function (l) {
          if (
            l.group &&
            l.group.type === "activeSelection" &&
            this._activeObject === l.group
          ) {
            var c = [
                "angle",
                "flipX",
                "flipY",
                "left",
                "scaleX",
                "scaleY",
                "skewX",
                "skewY",
                "top",
              ],
              h = {};
            return (
              c.forEach(function (m) {
                h[m] = l[m];
              }),
              e.util.addTransformToObject(
                l,
                this._activeObject.calcOwnMatrix()
              ),
              h
            );
          } else return null;
        },
        _unwindGroupTransformOnObject: function (l, c) {
          c && l.set(c);
        },
        _setSVGObject: function (l, c, h) {
          var m = this._realizeGroupTransformOnObject(c);
          this.callSuper("_setSVGObject", l, c, h),
            this._unwindGroupTransformOnObject(c, m);
        },
        setViewportTransform: function (l) {
          this.renderOnAddRemove &&
            this._activeObject &&
            this._activeObject.isEditing &&
            this._activeObject.clearContextTop(),
            e.StaticCanvas.prototype.setViewportTransform.call(this, l);
        },
      });
      for (var d in e.StaticCanvas)
        d !== "prototype" && (e.Canvas[d] = e.StaticCanvas[d]);
    })(),
    (function () {
      var a = e.util.addListener,
        s = e.util.removeListener,
        u = 3,
        d = 2,
        l = 1,
        c = { passive: !1 };
      function h(m, g) {
        return m.button && m.button === g - 1;
      }
      e.util.object.extend(e.Canvas.prototype, {
        mainTouchId: null,
        _initEventListeners: function () {
          this.removeListeners(),
            this._bindEvents(),
            this.addOrRemove(a, "add");
        },
        _getEventPrefix: function () {
          return this.enablePointerEvents ? "pointer" : "mouse";
        },
        addOrRemove: function (m, g) {
          var f = this.upperCanvasEl,
            v = this._getEventPrefix();
          m(e.window, "resize", this._onResize),
            m(f, v + "down", this._onMouseDown),
            m(f, v + "move", this._onMouseMove, c),
            m(f, v + "out", this._onMouseOut),
            m(f, v + "enter", this._onMouseEnter),
            m(f, "wheel", this._onMouseWheel),
            m(f, "contextmenu", this._onContextMenu),
            m(f, "dblclick", this._onDoubleClick),
            m(f, "dragover", this._onDragOver),
            m(f, "dragenter", this._onDragEnter),
            m(f, "dragleave", this._onDragLeave),
            m(f, "drop", this._onDrop),
            this.enablePointerEvents ||
              m(f, "touchstart", this._onTouchStart, c),
            typeof eventjs < "u" &&
              g in eventjs &&
              (eventjs[g](f, "gesture", this._onGesture),
              eventjs[g](f, "drag", this._onDrag),
              eventjs[g](f, "orientation", this._onOrientationChange),
              eventjs[g](f, "shake", this._onShake),
              eventjs[g](f, "longpress", this._onLongPress));
        },
        removeListeners: function () {
          this.addOrRemove(s, "remove");
          var m = this._getEventPrefix();
          s(e.document, m + "up", this._onMouseUp),
            s(e.document, "touchend", this._onTouchEnd, c),
            s(e.document, m + "move", this._onMouseMove, c),
            s(e.document, "touchmove", this._onMouseMove, c);
        },
        _bindEvents: function () {
          this.eventsBound ||
            ((this._onMouseDown = this._onMouseDown.bind(this)),
            (this._onTouchStart = this._onTouchStart.bind(this)),
            (this._onMouseMove = this._onMouseMove.bind(this)),
            (this._onMouseUp = this._onMouseUp.bind(this)),
            (this._onTouchEnd = this._onTouchEnd.bind(this)),
            (this._onResize = this._onResize.bind(this)),
            (this._onGesture = this._onGesture.bind(this)),
            (this._onDrag = this._onDrag.bind(this)),
            (this._onShake = this._onShake.bind(this)),
            (this._onLongPress = this._onLongPress.bind(this)),
            (this._onOrientationChange = this._onOrientationChange.bind(this)),
            (this._onMouseWheel = this._onMouseWheel.bind(this)),
            (this._onMouseOut = this._onMouseOut.bind(this)),
            (this._onMouseEnter = this._onMouseEnter.bind(this)),
            (this._onContextMenu = this._onContextMenu.bind(this)),
            (this._onDoubleClick = this._onDoubleClick.bind(this)),
            (this._onDragOver = this._onDragOver.bind(this)),
            (this._onDragEnter = this._simpleEventHandler.bind(
              this,
              "dragenter"
            )),
            (this._onDragLeave = this._simpleEventHandler.bind(
              this,
              "dragleave"
            )),
            (this._onDrop = this._onDrop.bind(this)),
            (this.eventsBound = !0));
        },
        _onGesture: function (m, g) {
          this.__onTransformGesture && this.__onTransformGesture(m, g);
        },
        _onDrag: function (m, g) {
          this.__onDrag && this.__onDrag(m, g);
        },
        _onMouseWheel: function (m) {
          this.__onMouseWheel(m);
        },
        _onMouseOut: function (m) {
          var g = this._hoveredTarget;
          this.fire("mouse:out", { target: g, e: m }),
            (this._hoveredTarget = null),
            g && g.fire("mouseout", { e: m });
          var f = this;
          this._hoveredTargets.forEach(function (v) {
            f.fire("mouse:out", { target: g, e: m }),
              v && g.fire("mouseout", { e: m });
          }),
            (this._hoveredTargets = []);
        },
        _onMouseEnter: function (m) {
          !this._currentTransform &&
            !this.findTarget(m) &&
            (this.fire("mouse:over", { target: null, e: m }),
            (this._hoveredTarget = null),
            (this._hoveredTargets = []));
        },
        _onOrientationChange: function (m, g) {
          this.__onOrientationChange && this.__onOrientationChange(m, g);
        },
        _onShake: function (m, g) {
          this.__onShake && this.__onShake(m, g);
        },
        _onLongPress: function (m, g) {
          this.__onLongPress && this.__onLongPress(m, g);
        },
        _onDragOver: function (m) {
          m.preventDefault();
          var g = this._simpleEventHandler("dragover", m);
          this._fireEnterLeaveEvents(g, m);
        },
        _onDrop: function (m) {
          return (
            this._simpleEventHandler("drop:before", m),
            this._simpleEventHandler("drop", m)
          );
        },
        _onContextMenu: function (m) {
          return (
            this.stopContextMenu && (m.stopPropagation(), m.preventDefault()),
            !1
          );
        },
        _onDoubleClick: function (m) {
          this._cacheTransformEventData(m),
            this._handleEvent(m, "dblclick"),
            this._resetTransformEventData(m);
        },
        getPointerId: function (m) {
          var g = m.changedTouches;
          return g
            ? g[0] && g[0].identifier
            : this.enablePointerEvents
            ? m.pointerId
            : -1;
        },
        _isMainEvent: function (m) {
          return m.isPrimary === !0
            ? !0
            : m.isPrimary === !1
            ? !1
            : m.type === "touchend" && m.touches.length === 0
            ? !0
            : m.changedTouches
            ? m.changedTouches[0].identifier === this.mainTouchId
            : !0;
        },
        _onTouchStart: function (m) {
          m.preventDefault(),
            this.mainTouchId === null &&
              (this.mainTouchId = this.getPointerId(m)),
            this.__onMouseDown(m),
            this._resetTransformEventData();
          var g = this.upperCanvasEl,
            f = this._getEventPrefix();
          a(e.document, "touchend", this._onTouchEnd, c),
            a(e.document, "touchmove", this._onMouseMove, c),
            s(g, f + "down", this._onMouseDown);
        },
        _onMouseDown: function (m) {
          this.__onMouseDown(m), this._resetTransformEventData();
          var g = this.upperCanvasEl,
            f = this._getEventPrefix();
          s(g, f + "move", this._onMouseMove, c),
            a(e.document, f + "up", this._onMouseUp),
            a(e.document, f + "move", this._onMouseMove, c);
        },
        _onTouchEnd: function (m) {
          if (!(m.touches.length > 0)) {
            this.__onMouseUp(m),
              this._resetTransformEventData(),
              (this.mainTouchId = null);
            var g = this._getEventPrefix();
            s(e.document, "touchend", this._onTouchEnd, c),
              s(e.document, "touchmove", this._onMouseMove, c);
            var f = this;
            this._willAddMouseDown && clearTimeout(this._willAddMouseDown),
              (this._willAddMouseDown = setTimeout(function () {
                a(f.upperCanvasEl, g + "down", f._onMouseDown),
                  (f._willAddMouseDown = 0);
              }, 400));
          }
        },
        _onMouseUp: function (m) {
          this.__onMouseUp(m), this._resetTransformEventData();
          var g = this.upperCanvasEl,
            f = this._getEventPrefix();
          this._isMainEvent(m) &&
            (s(e.document, f + "up", this._onMouseUp),
            s(e.document, f + "move", this._onMouseMove, c),
            a(g, f + "move", this._onMouseMove, c));
        },
        _onMouseMove: function (m) {
          !this.allowTouchScrolling && m.preventDefault && m.preventDefault(),
            this.__onMouseMove(m);
        },
        _onResize: function () {
          this.calcOffset();
        },
        _shouldRender: function (m) {
          var g = this._activeObject;
          return !!g != !!m || (g && m && g !== m)
            ? !0
            : (g && g.isEditing, !1);
        },
        __onMouseUp: function (m) {
          var g,
            f = this._currentTransform,
            v = this._groupSelector,
            y = !1,
            _ = !v || (v.left === 0 && v.top === 0);
          if (
            (this._cacheTransformEventData(m),
            (g = this._target),
            this._handleEvent(m, "up:before"),
            h(m, u))
          ) {
            this.fireRightClick && this._handleEvent(m, "up", u, _);
            return;
          }
          if (h(m, d)) {
            this.fireMiddleClick && this._handleEvent(m, "up", d, _),
              this._resetTransformEventData();
            return;
          }
          if (this.isDrawingMode && this._isCurrentlyDrawing) {
            this._onMouseUpInDrawingMode(m);
            return;
          }
          if (this._isMainEvent(m)) {
            if (
              (f &&
                (this._finalizeCurrentTransform(m), (y = f.actionPerformed)),
              !_)
            ) {
              var x = g === this._activeObject;
              this._maybeGroupObjects(m),
                y ||
                  (y =
                    this._shouldRender(g) || (!x && g === this._activeObject));
            }
            var b, S;
            if (g) {
              if (
                ((b = g._findTargetCorner(
                  this.getPointer(m, !0),
                  e.util.isTouchEvent(m)
                )),
                g.selectable && g !== this._activeObject && g.activeOn === "up")
              )
                this.setActiveObject(g, m), (y = !0);
              else {
                var T = g.controls[b],
                  w = T && T.getMouseUpHandler(m, g, T);
                w && ((S = this.getPointer(m)), w(m, f, S.x, S.y));
              }
              g.isMoving = !1;
            }
            if (f && (f.target !== g || f.corner !== b)) {
              var P = f.target && f.target.controls[f.corner],
                F = P && P.getMouseUpHandler(m, g, T);
              (S = S || this.getPointer(m)), F && F(m, f, S.x, S.y);
            }
            this._setCursorFromEvent(m, g),
              this._handleEvent(m, "up", l, _),
              (this._groupSelector = null),
              (this._currentTransform = null),
              g && (g.__corner = 0),
              y ? this.requestRenderAll() : _ || this.renderTop();
          }
        },
        _simpleEventHandler: function (m, g) {
          var f = this.findTarget(g),
            v = this.targets,
            y = { e: g, target: f, subTargets: v };
          if ((this.fire(m, y), f && f.fire(m, y), !v)) return f;
          for (var _ = 0; _ < v.length; _++) v[_].fire(m, y);
          return f;
        },
        _handleEvent: function (m, g, f, v) {
          var y = this._target,
            _ = this.targets || [],
            x = {
              e: m,
              target: y,
              subTargets: _,
              button: f || l,
              isClick: v || !1,
              pointer: this._pointer,
              absolutePointer: this._absolutePointer,
              transform: this._currentTransform,
            };
          g === "up" &&
            ((x.currentTarget = this.findTarget(m)),
            (x.currentSubTargets = this.targets)),
            this.fire("mouse:" + g, x),
            y && y.fire("mouse" + g, x);
          for (var b = 0; b < _.length; b++) _[b].fire("mouse" + g, x);
        },
        _finalizeCurrentTransform: function (m) {
          var g = this._currentTransform,
            f = g.target,
            v = { e: m, target: f, transform: g, action: g.action };
          f._scaling && (f._scaling = !1),
            f.setCoords(),
            (g.actionPerformed || (this.stateful && f.hasStateChanged())) &&
              this._fire("modified", v);
        },
        _onMouseDownInDrawingMode: function (m) {
          (this._isCurrentlyDrawing = !0),
            this.getActiveObject() &&
              this.discardActiveObject(m).requestRenderAll();
          var g = this.getPointer(m);
          this.freeDrawingBrush.onMouseDown(g, { e: m, pointer: g }),
            this._handleEvent(m, "down");
        },
        _onMouseMoveInDrawingMode: function (m) {
          if (this._isCurrentlyDrawing) {
            var g = this.getPointer(m);
            this.freeDrawingBrush.onMouseMove(g, { e: m, pointer: g });
          }
          this.setCursor(this.freeDrawingCursor), this._handleEvent(m, "move");
        },
        _onMouseUpInDrawingMode: function (m) {
          var g = this.getPointer(m);
          (this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({
            e: m,
            pointer: g,
          })),
            this._handleEvent(m, "up");
        },
        __onMouseDown: function (m) {
          this._cacheTransformEventData(m), this._handleEvent(m, "down:before");
          var g = this._target;
          if (h(m, u)) {
            this.fireRightClick && this._handleEvent(m, "down", u);
            return;
          }
          if (h(m, d)) {
            this.fireMiddleClick && this._handleEvent(m, "down", d);
            return;
          }
          if (this.isDrawingMode) {
            this._onMouseDownInDrawingMode(m);
            return;
          }
          if (this._isMainEvent(m) && !this._currentTransform) {
            var f = this._pointer;
            this._previousPointer = f;
            var v = this._shouldRender(g),
              y = this._shouldGroup(m, g);
            if (
              (this._shouldClearSelection(m, g)
                ? this.discardActiveObject(m)
                : y && (this._handleGrouping(m, g), (g = this._activeObject)),
              this.selection &&
                (!g ||
                  (!g.selectable &&
                    !g.isEditing &&
                    g !== this._activeObject)) &&
                (this._groupSelector = {
                  ex: this._absolutePointer.x,
                  ey: this._absolutePointer.y,
                  top: 0,
                  left: 0,
                }),
              g)
            ) {
              var _ = g === this._activeObject;
              g.selectable &&
                g.activeOn === "down" &&
                this.setActiveObject(g, m);
              var x = g._findTargetCorner(
                this.getPointer(m, !0),
                e.util.isTouchEvent(m)
              );
              if (((g.__corner = x), g === this._activeObject && (x || !y))) {
                this._setupCurrentTransform(m, g, _);
                var b = g.controls[x],
                  f = this.getPointer(m),
                  S = b && b.getMouseDownHandler(m, g, b);
                S && S(m, this._currentTransform, f.x, f.y);
              }
            }
            this._handleEvent(m, "down"), (v || y) && this.requestRenderAll();
          }
        },
        _resetTransformEventData: function () {
          (this._target = null),
            (this._pointer = null),
            (this._absolutePointer = null);
        },
        _cacheTransformEventData: function (m) {
          this._resetTransformEventData(),
            (this._pointer = this.getPointer(m, !0)),
            (this._absolutePointer = this.restorePointerVpt(this._pointer)),
            (this._target = this._currentTransform
              ? this._currentTransform.target
              : this.findTarget(m) || null);
        },
        _beforeTransform: function (m) {
          var g = this._currentTransform;
          this.stateful && g.target.saveState(),
            this.fire("before:transform", { e: m, transform: g });
        },
        __onMouseMove: function (m) {
          this._handleEvent(m, "move:before"), this._cacheTransformEventData(m);
          var g, f;
          if (this.isDrawingMode) {
            this._onMouseMoveInDrawingMode(m);
            return;
          }
          if (this._isMainEvent(m)) {
            var v = this._groupSelector;
            v
              ? ((f = this._absolutePointer),
                (v.left = f.x - v.ex),
                (v.top = f.y - v.ey),
                this.renderTop())
              : this._currentTransform
              ? this._transformObject(m)
              : ((g = this.findTarget(m) || null),
                this._setCursorFromEvent(m, g),
                this._fireOverOutEvents(g, m)),
              this._handleEvent(m, "move"),
              this._resetTransformEventData();
          }
        },
        _fireOverOutEvents: function (m, g) {
          var f = this._hoveredTarget,
            v = this._hoveredTargets,
            y = this.targets,
            _ = Math.max(v.length, y.length);
          this.fireSyntheticInOutEvents(m, g, {
            oldTarget: f,
            evtOut: "mouseout",
            canvasEvtOut: "mouse:out",
            evtIn: "mouseover",
            canvasEvtIn: "mouse:over",
          });
          for (var x = 0; x < _; x++)
            this.fireSyntheticInOutEvents(y[x], g, {
              oldTarget: v[x],
              evtOut: "mouseout",
              evtIn: "mouseover",
            });
          (this._hoveredTarget = m),
            (this._hoveredTargets = this.targets.concat());
        },
        _fireEnterLeaveEvents: function (m, g) {
          var f = this._draggedoverTarget,
            v = this._hoveredTargets,
            y = this.targets,
            _ = Math.max(v.length, y.length);
          this.fireSyntheticInOutEvents(m, g, {
            oldTarget: f,
            evtOut: "dragleave",
            evtIn: "dragenter",
          });
          for (var x = 0; x < _; x++)
            this.fireSyntheticInOutEvents(y[x], g, {
              oldTarget: v[x],
              evtOut: "dragleave",
              evtIn: "dragenter",
            });
          this._draggedoverTarget = m;
        },
        fireSyntheticInOutEvents: function (m, g, f) {
          var v,
            y,
            _ = f.oldTarget,
            x,
            b,
            S = _ !== m,
            T = f.canvasEvtIn,
            w = f.canvasEvtOut;
          S &&
            ((v = { e: g, target: m, previousTarget: _ }),
            (y = { e: g, target: _, nextTarget: m })),
            (b = m && S),
            (x = _ && S),
            x && (w && this.fire(w, y), _.fire(f.evtOut, y)),
            b && (T && this.fire(T, v), m.fire(f.evtIn, v));
        },
        __onMouseWheel: function (m) {
          this._cacheTransformEventData(m),
            this._handleEvent(m, "wheel"),
            this._resetTransformEventData();
        },
        _transformObject: function (m) {
          var g = this.getPointer(m),
            f = this._currentTransform;
          (f.reset = !1),
            (f.shiftKey = m.shiftKey),
            (f.altKey = m[this.centeredKey]),
            this._performTransformAction(m, f, g),
            f.actionPerformed && this.requestRenderAll();
        },
        _performTransformAction: function (m, g, f) {
          var v = f.x,
            y = f.y,
            _ = g.action,
            x = !1,
            b = g.actionHandler;
          b && (x = b(m, g, v, y)),
            _ === "drag" &&
              x &&
              ((g.target.isMoving = !0),
              this.setCursor(g.target.moveCursor || this.moveCursor)),
            (g.actionPerformed = g.actionPerformed || x);
        },
        _fire: e.controlsUtils.fireEvent,
        _setCursorFromEvent: function (m, g) {
          if (!g) return this.setCursor(this.defaultCursor), !1;
          var f = g.hoverCursor || this.hoverCursor,
            v =
              this._activeObject &&
              this._activeObject.type === "activeSelection"
                ? this._activeObject
                : null,
            y =
              (!v || !v.contains(g)) &&
              g._findTargetCorner(this.getPointer(m, !0));
          y
            ? this.setCursor(this.getCornerCursor(y, g, m))
            : (g.subTargetCheck &&
                this.targets
                  .concat()
                  .reverse()
                  .map(function (_) {
                    f = _.hoverCursor || f;
                  }),
              this.setCursor(f));
        },
        getCornerCursor: function (m, g, f) {
          var v = g.controls[m];
          return v.cursorStyleHandler(f, v, g);
        },
      });
    })(),
    (function () {
      var a = Math.min,
        s = Math.max;
      e.util.object.extend(e.Canvas.prototype, {
        _shouldGroup: function (u, d) {
          var l = this._activeObject;
          return (
            l &&
            this._isSelectionKeyPressed(u) &&
            d &&
            d.selectable &&
            this.selection &&
            (l !== d || l.type === "activeSelection") &&
            !d.onSelect({ e: u })
          );
        },
        _handleGrouping: function (u, d) {
          var l = this._activeObject;
          l.__corner ||
            (d === l && ((d = this.findTarget(u, !0)), !d || !d.selectable)) ||
            (l && l.type === "activeSelection"
              ? this._updateActiveSelection(d, u)
              : this._createActiveSelection(d, u));
        },
        _updateActiveSelection: function (u, d) {
          var l = this._activeObject,
            c = l._objects.slice(0);
          l.contains(u)
            ? (l.removeWithUpdate(u),
              (this._hoveredTarget = u),
              (this._hoveredTargets = this.targets.concat()),
              l.size() === 1 && this._setActiveObject(l.item(0), d))
            : (l.addWithUpdate(u),
              (this._hoveredTarget = l),
              (this._hoveredTargets = this.targets.concat())),
            this._fireSelectionEvents(c, d);
        },
        _createActiveSelection: function (u, d) {
          var l = this.getActiveObjects(),
            c = this._createGroup(u);
          (this._hoveredTarget = c),
            this._setActiveObject(c, d),
            this._fireSelectionEvents(l, d);
        },
        _createGroup: function (u) {
          var d = this._objects,
            l = d.indexOf(this._activeObject) < d.indexOf(u),
            c = l ? [this._activeObject, u] : [u, this._activeObject];
          return (
            this._activeObject.isEditing && this._activeObject.exitEditing(),
            new e.ActiveSelection(c, { canvas: this })
          );
        },
        _groupSelectedObjects: function (u) {
          var d = this._collectObjects(u),
            l;
          d.length === 1
            ? this.setActiveObject(d[0], u)
            : d.length > 1 &&
              ((l = new e.ActiveSelection(d.reverse(), { canvas: this })),
              this.setActiveObject(l, u));
        },
        _collectObjects: function (u) {
          for (
            var d = [],
              l,
              c = this._groupSelector.ex,
              h = this._groupSelector.ey,
              m = c + this._groupSelector.left,
              g = h + this._groupSelector.top,
              f = new e.Point(a(c, m), a(h, g)),
              v = new e.Point(s(c, m), s(h, g)),
              y = !this.selectionFullyContained,
              _ = c === m && h === g,
              x = this._objects.length;
            x-- &&
            ((l = this._objects[x]),
            !(
              !(!l || !l.selectable || !l.visible) &&
              ((y && l.intersectsWithRect(f, v, !0)) ||
                l.isContainedWithinRect(f, v, !0) ||
                (y && l.containsPoint(f, null, !0)) ||
                (y && l.containsPoint(v, null, !0))) &&
              (d.push(l), _)
            ));

          );
          return (
            d.length > 1 &&
              (d = d.filter(function (b) {
                return !b.onSelect({ e: u });
              })),
            d
          );
        },
        _maybeGroupObjects: function (u) {
          this.selection &&
            this._groupSelector &&
            this._groupSelectedObjects(u),
            this.setCursor(this.defaultCursor),
            (this._groupSelector = null);
        },
      });
    })(),
    (function () {
      e.util.object.extend(e.StaticCanvas.prototype, {
        toDataURL: function (a) {
          a || (a = {});
          var s = a.format || "png",
            u = a.quality || 1,
            d =
              (a.multiplier || 1) *
              (a.enableRetinaScaling ? this.getRetinaScaling() : 1),
            l = this.toCanvasElement(d, a);
          return e.util.toDataURL(l, s, u);
        },
        toCanvasElement: function (a, s) {
          (a = a || 1), (s = s || {});
          var u = (s.width || this.width) * a,
            d = (s.height || this.height) * a,
            l = this.getZoom(),
            c = this.width,
            h = this.height,
            m = l * a,
            g = this.viewportTransform,
            f = (g[4] - (s.left || 0)) * a,
            v = (g[5] - (s.top || 0)) * a,
            y = this.interactive,
            _ = [m, 0, 0, m, f, v],
            x = this.enableRetinaScaling,
            b = e.util.createCanvasElement(),
            S = this.contextTop;
          return (
            (b.width = u),
            (b.height = d),
            (this.contextTop = null),
            (this.enableRetinaScaling = !1),
            (this.interactive = !1),
            (this.viewportTransform = _),
            (this.width = u),
            (this.height = d),
            this.calcViewportBoundaries(),
            this.renderCanvas(b.getContext("2d"), this._objects),
            (this.viewportTransform = g),
            (this.width = c),
            (this.height = h),
            this.calcViewportBoundaries(),
            (this.interactive = y),
            (this.enableRetinaScaling = x),
            (this.contextTop = S),
            b
          );
        },
      });
    })(),
    e.util.object.extend(e.StaticCanvas.prototype, {
      loadFromJSON: function (a, s, u) {
        if (a) {
          var d = typeof a == "string" ? JSON.parse(a) : e.util.object.clone(a),
            l = this,
            c = d.clipPath,
            h = this.renderOnAddRemove;
          return (
            (this.renderOnAddRemove = !1),
            delete d.clipPath,
            this._enlivenObjects(
              d.objects,
              function (m) {
                l.clear(),
                  l._setBgOverlay(d, function () {
                    c
                      ? l._enlivenObjects([c], function (g) {
                          (l.clipPath = g[0]),
                            l.__setupCanvas.call(l, d, m, h, s);
                        })
                      : l.__setupCanvas.call(l, d, m, h, s);
                  });
              },
              u
            ),
            this
          );
        }
      },
      __setupCanvas: function (a, s, u, d) {
        var l = this;
        s.forEach(function (c, h) {
          l.insertAt(c, h);
        }),
          (this.renderOnAddRemove = u),
          delete a.objects,
          delete a.backgroundImage,
          delete a.overlayImage,
          delete a.background,
          delete a.overlay,
          this._setOptions(a),
          this.renderAll(),
          d && d();
      },
      _setBgOverlay: function (a, s) {
        var u = {
          backgroundColor: !1,
          overlayColor: !1,
          backgroundImage: !1,
          overlayImage: !1,
        };
        if (
          !a.backgroundImage &&
          !a.overlayImage &&
          !a.background &&
          !a.overlay
        ) {
          s && s();
          return;
        }
        var d = function () {
          u.backgroundImage &&
            u.overlayImage &&
            u.backgroundColor &&
            u.overlayColor &&
            s &&
            s();
        };
        this.__setBgOverlay("backgroundImage", a.backgroundImage, u, d),
          this.__setBgOverlay("overlayImage", a.overlayImage, u, d),
          this.__setBgOverlay("backgroundColor", a.background, u, d),
          this.__setBgOverlay("overlayColor", a.overlay, u, d);
      },
      __setBgOverlay: function (a, s, u, d) {
        var l = this;
        if (!s) {
          (u[a] = !0), d && d();
          return;
        }
        a === "backgroundImage" || a === "overlayImage"
          ? e.util.enlivenObjects([s], function (c) {
              (l[a] = c[0]), (u[a] = !0), d && d();
            })
          : this["set" + e.util.string.capitalize(a, !0)](s, function () {
              (u[a] = !0), d && d();
            });
      },
      _enlivenObjects: function (a, s, u) {
        if (!a || a.length === 0) {
          s && s([]);
          return;
        }
        e.util.enlivenObjects(
          a,
          function (d) {
            s && s(d);
          },
          null,
          u
        );
      },
      _toDataURL: function (a, s) {
        this.clone(function (u) {
          s(u.toDataURL(a));
        });
      },
      _toDataURLWithMultiplier: function (a, s, u) {
        this.clone(function (d) {
          u(d.toDataURLWithMultiplier(a, s));
        });
      },
      clone: function (a, s) {
        var u = JSON.stringify(this.toJSON(s));
        this.cloneWithoutData(function (d) {
          d.loadFromJSON(u, function () {
            a && a(d);
          });
        });
      },
      cloneWithoutData: function (a) {
        var s = e.util.createCanvasElement();
        (s.width = this.width), (s.height = this.height);
        var u = new e.Canvas(s);
        this.backgroundImage
          ? (u.setBackgroundImage(this.backgroundImage.src, function () {
              u.renderAll(), a && a(u);
            }),
            (u.backgroundImageOpacity = this.backgroundImageOpacity),
            (u.backgroundImageStretch = this.backgroundImageStretch))
          : a && a(u);
      },
    }),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.extend,
        d = s.util.object.clone,
        l = s.util.toFixed,
        c = s.util.string.capitalize,
        h = s.util.degreesToRadians,
        m = !s.isLikelyNode,
        g = 2;
      s.Object ||
        ((s.Object = s.util.createClass(s.CommonMethods, {
          type: "object",
          originX: "left",
          originY: "top",
          top: 0,
          left: 0,
          width: 0,
          height: 0,
          scaleX: 1,
          scaleY: 1,
          flipX: !1,
          flipY: !1,
          opacity: 1,
          angle: 0,
          skewX: 0,
          skewY: 0,
          cornerSize: 13,
          touchCornerSize: 24,
          transparentCorners: !0,
          hoverCursor: null,
          moveCursor: null,
          padding: 0,
          borderColor: "rgb(178,204,255)",
          borderDashArray: null,
          cornerColor: "rgb(178,204,255)",
          cornerStrokeColor: null,
          cornerStyle: "rect",
          cornerDashArray: null,
          centeredScaling: !1,
          centeredRotation: !0,
          fill: "rgb(0,0,0)",
          fillRule: "nonzero",
          globalCompositeOperation: "source-over",
          backgroundColor: "",
          selectionBackgroundColor: "",
          stroke: null,
          strokeWidth: 1,
          strokeDashArray: null,
          strokeDashOffset: 0,
          strokeLineCap: "butt",
          strokeLineJoin: "miter",
          strokeMiterLimit: 4,
          shadow: null,
          borderOpacityWhenMoving: 0.4,
          borderScaleFactor: 1,
          minScaleLimit: 0,
          selectable: !0,
          evented: !0,
          visible: !0,
          hasControls: !0,
          hasBorders: !0,
          perPixelTargetFind: !1,
          includeDefaultValues: !0,
          lockMovementX: !1,
          lockMovementY: !1,
          lockRotation: !1,
          lockScalingX: !1,
          lockScalingY: !1,
          lockSkewingX: !1,
          lockSkewingY: !1,
          lockScalingFlip: !1,
          excludeFromExport: !1,
          objectCaching: m,
          statefullCache: !1,
          noScaleCache: !0,
          strokeUniform: !1,
          dirty: !0,
          __corner: 0,
          paintFirst: "fill",
          activeOn: "down",
          stateProperties:
            "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(
              " "
            ),
          cacheProperties:
            "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(
              " "
            ),
          colorProperties: "fill stroke backgroundColor".split(" "),
          clipPath: void 0,
          inverted: !1,
          absolutePositioned: !1,
          initialize: function (f) {
            f && this.setOptions(f);
          },
          _createCacheCanvas: function () {
            (this._cacheProperties = {}),
              (this._cacheCanvas = s.util.createCanvasElement()),
              (this._cacheContext = this._cacheCanvas.getContext("2d")),
              this._updateCacheCanvas(),
              (this.dirty = !0);
          },
          _limitCacheSize: function (f) {
            var v = s.perfLimitSizeTotal,
              y = f.width,
              _ = f.height,
              x = s.maxCacheSideLimit,
              b = s.minCacheSideLimit;
            if (y <= x && _ <= x && y * _ <= v)
              return y < b && (f.width = b), _ < b && (f.height = b), f;
            var S = y / _,
              T = s.util.limitDimsByArea(S, v),
              w = s.util.capValue,
              P = w(b, T.x, x),
              F = w(b, T.y, x);
            return (
              y > P && ((f.zoomX /= y / P), (f.width = P), (f.capped = !0)),
              _ > F && ((f.zoomY /= _ / F), (f.height = F), (f.capped = !0)),
              f
            );
          },
          _getCacheCanvasDimensions: function () {
            var f = this.getTotalObjectScaling(),
              v = this._getTransformedDimensions(0, 0),
              y = (v.x * f.scaleX) / this.scaleX,
              _ = (v.y * f.scaleY) / this.scaleY;
            return {
              width: y + g,
              height: _ + g,
              zoomX: f.scaleX,
              zoomY: f.scaleY,
              x: y,
              y: _,
            };
          },
          _updateCacheCanvas: function () {
            var f = this.canvas;
            if (this.noScaleCache && f && f._currentTransform) {
              var v = f._currentTransform.target,
                y = f._currentTransform.action;
              if (this === v && y.slice && y.slice(0, 5) === "scale") return !1;
            }
            var _ = this._cacheCanvas,
              x = this._limitCacheSize(this._getCacheCanvasDimensions()),
              b = s.minCacheSideLimit,
              S = x.width,
              T = x.height,
              w,
              P,
              F = x.zoomX,
              V = x.zoomY,
              J = S !== this.cacheWidth || T !== this.cacheHeight,
              z = this.zoomX !== F || this.zoomY !== V,
              B = J || z,
              G = 0,
              ie = 0,
              re = !1;
            if (J) {
              var j = this._cacheCanvas.width,
                C = this._cacheCanvas.height,
                R = S > j || T > C,
                A = (S < j * 0.9 || T < C * 0.9) && j > b && C > b;
              (re = R || A),
                R &&
                  !x.capped &&
                  (S > b || T > b) &&
                  ((G = S * 0.1), (ie = T * 0.1));
            }
            return (
              this instanceof s.Text &&
                this.path &&
                ((B = !0),
                (re = !0),
                (G += this.getHeightOfLine(0) * this.zoomX),
                (ie += this.getHeightOfLine(0) * this.zoomY)),
              B
                ? (re
                    ? ((_.width = Math.ceil(S + G)),
                      (_.height = Math.ceil(T + ie)))
                    : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0),
                      this._cacheContext.clearRect(0, 0, _.width, _.height)),
                  (w = x.x / 2),
                  (P = x.y / 2),
                  (this.cacheTranslationX = Math.round(_.width / 2 - w) + w),
                  (this.cacheTranslationY = Math.round(_.height / 2 - P) + P),
                  (this.cacheWidth = S),
                  (this.cacheHeight = T),
                  this._cacheContext.translate(
                    this.cacheTranslationX,
                    this.cacheTranslationY
                  ),
                  this._cacheContext.scale(F, V),
                  (this.zoomX = F),
                  (this.zoomY = V),
                  !0)
                : !1
            );
          },
          setOptions: function (f) {
            this._setOptions(f),
              this._initGradient(f.fill, "fill"),
              this._initGradient(f.stroke, "stroke"),
              this._initPattern(f.fill, "fill"),
              this._initPattern(f.stroke, "stroke");
          },
          transform: function (f) {
            var v =
                (this.group && !this.group._transformDone) ||
                (this.group && this.canvas && f === this.canvas.contextTop),
              y = this.calcTransformMatrix(!v);
            f.transform(y[0], y[1], y[2], y[3], y[4], y[5]);
          },
          toObject: function (f) {
            var v = s.Object.NUM_FRACTION_DIGITS,
              y = {
                type: this.type,
                version: s.version,
                originX: this.originX,
                originY: this.originY,
                left: l(this.left, v),
                top: l(this.top, v),
                width: l(this.width, v),
                height: l(this.height, v),
                fill:
                  this.fill && this.fill.toObject
                    ? this.fill.toObject()
                    : this.fill,
                stroke:
                  this.stroke && this.stroke.toObject
                    ? this.stroke.toObject()
                    : this.stroke,
                strokeWidth: l(this.strokeWidth, v),
                strokeDashArray: this.strokeDashArray
                  ? this.strokeDashArray.concat()
                  : this.strokeDashArray,
                strokeLineCap: this.strokeLineCap,
                strokeDashOffset: this.strokeDashOffset,
                strokeLineJoin: this.strokeLineJoin,
                strokeUniform: this.strokeUniform,
                strokeMiterLimit: l(this.strokeMiterLimit, v),
                scaleX: l(this.scaleX, v),
                scaleY: l(this.scaleY, v),
                angle: l(this.angle, v),
                flipX: this.flipX,
                flipY: this.flipY,
                opacity: l(this.opacity, v),
                shadow:
                  this.shadow && this.shadow.toObject
                    ? this.shadow.toObject()
                    : this.shadow,
                visible: this.visible,
                backgroundColor: this.backgroundColor,
                fillRule: this.fillRule,
                paintFirst: this.paintFirst,
                globalCompositeOperation: this.globalCompositeOperation,
                skewX: l(this.skewX, v),
                skewY: l(this.skewY, v),
              };
            return (
              this.clipPath &&
                !this.clipPath.excludeFromExport &&
                ((y.clipPath = this.clipPath.toObject(f)),
                (y.clipPath.inverted = this.clipPath.inverted),
                (y.clipPath.absolutePositioned =
                  this.clipPath.absolutePositioned)),
              s.util.populateWithProperties(this, y, f),
              this.includeDefaultValues || (y = this._removeDefaultValues(y)),
              y
            );
          },
          toDatalessObject: function (f) {
            return this.toObject(f);
          },
          _removeDefaultValues: function (f) {
            var v = s.util.getKlass(f.type).prototype,
              y = v.stateProperties;
            return (
              y.forEach(function (_) {
                _ === "left" ||
                  _ === "top" ||
                  (f[_] === v[_] && delete f[_],
                  Array.isArray(f[_]) &&
                    Array.isArray(v[_]) &&
                    f[_].length === 0 &&
                    v[_].length === 0 &&
                    delete f[_]);
              }),
              f
            );
          },
          toString: function () {
            return "#<fabric." + c(this.type) + ">";
          },
          getObjectScaling: function () {
            if (!this.group)
              return { scaleX: this.scaleX, scaleY: this.scaleY };
            var f = s.util.qrDecompose(this.calcTransformMatrix());
            return { scaleX: Math.abs(f.scaleX), scaleY: Math.abs(f.scaleY) };
          },
          getTotalObjectScaling: function () {
            var f = this.getObjectScaling(),
              v = f.scaleX,
              y = f.scaleY;
            if (this.canvas) {
              var _ = this.canvas.getZoom(),
                x = this.canvas.getRetinaScaling();
              (v *= _ * x), (y *= _ * x);
            }
            return { scaleX: v, scaleY: y };
          },
          getObjectOpacity: function () {
            var f = this.opacity;
            return this.group && (f *= this.group.getObjectOpacity()), f;
          },
          _set: function (f, v) {
            var y = f === "scaleX" || f === "scaleY",
              _ = this[f] !== v,
              x = !1;
            return (
              y && (v = this._constrainScale(v)),
              f === "scaleX" && v < 0
                ? ((this.flipX = !this.flipX), (v *= -1))
                : f === "scaleY" && v < 0
                ? ((this.flipY = !this.flipY), (v *= -1))
                : f === "shadow" && v && !(v instanceof s.Shadow)
                ? (v = new s.Shadow(v))
                : f === "dirty" && this.group && this.group.set("dirty", v),
              (this[f] = v),
              _ &&
                ((x = this.group && this.group.isOnACache()),
                this.cacheProperties.indexOf(f) > -1
                  ? ((this.dirty = !0), x && this.group.set("dirty", !0))
                  : x &&
                    this.stateProperties.indexOf(f) > -1 &&
                    this.group.set("dirty", !0)),
              this
            );
          },
          setOnGroup: function () {},
          getViewportTransform: function () {
            return this.canvas && this.canvas.viewportTransform
              ? this.canvas.viewportTransform
              : s.iMatrix.concat();
          },
          isNotVisible: function () {
            return (
              this.opacity === 0 ||
              (!this.width && !this.height && this.strokeWidth === 0) ||
              !this.visible
            );
          },
          render: function (f) {
            this.isNotVisible() ||
              (this.canvas &&
                this.canvas.skipOffscreen &&
                !this.group &&
                !this.isOnScreen()) ||
              (f.save(),
              this._setupCompositeOperation(f),
              this.drawSelectionBackground(f),
              this.transform(f),
              this._setOpacity(f),
              this._setShadow(f, this),
              this.shouldCache()
                ? (this.renderCache(), this.drawCacheOnCanvas(f))
                : (this._removeCacheCanvas(),
                  (this.dirty = !1),
                  this.drawObject(f),
                  this.objectCaching &&
                    this.statefullCache &&
                    this.saveState({ propertySet: "cacheProperties" })),
              f.restore());
          },
          renderCache: function (f) {
            (f = f || {}),
              (!this._cacheCanvas || !this._cacheContext) &&
                this._createCacheCanvas(),
              this.isCacheDirty() &&
                (this.statefullCache &&
                  this.saveState({ propertySet: "cacheProperties" }),
                this.drawObject(this._cacheContext, f.forClipping),
                (this.dirty = !1));
          },
          _removeCacheCanvas: function () {
            (this._cacheCanvas = null),
              (this._cacheContext = null),
              (this.cacheWidth = 0),
              (this.cacheHeight = 0);
          },
          hasStroke: function () {
            return (
              this.stroke &&
              this.stroke !== "transparent" &&
              this.strokeWidth !== 0
            );
          },
          hasFill: function () {
            return this.fill && this.fill !== "transparent";
          },
          needsItsOwnCache: function () {
            return !!(
              (this.paintFirst === "stroke" &&
                this.hasFill() &&
                this.hasStroke() &&
                typeof this.shadow == "object") ||
              this.clipPath
            );
          },
          shouldCache: function () {
            return (
              (this.ownCaching =
                this.needsItsOwnCache() ||
                (this.objectCaching &&
                  (!this.group || !this.group.isOnACache()))),
              this.ownCaching
            );
          },
          willDrawShadow: function () {
            return (
              !!this.shadow &&
              (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0)
            );
          },
          drawClipPathOnCache: function (f, v) {
            if (
              (f.save(),
              v.inverted
                ? (f.globalCompositeOperation = "destination-out")
                : (f.globalCompositeOperation = "destination-in"),
              v.absolutePositioned)
            ) {
              var y = s.util.invertTransform(this.calcTransformMatrix());
              f.transform(y[0], y[1], y[2], y[3], y[4], y[5]);
            }
            v.transform(f),
              f.scale(1 / v.zoomX, 1 / v.zoomY),
              f.drawImage(
                v._cacheCanvas,
                -v.cacheTranslationX,
                -v.cacheTranslationY
              ),
              f.restore();
          },
          drawObject: function (f, v) {
            var y = this.fill,
              _ = this.stroke;
            v
              ? ((this.fill = "black"),
                (this.stroke = ""),
                this._setClippingProperties(f))
              : this._renderBackground(f),
              this._render(f),
              this._drawClipPath(f, this.clipPath),
              (this.fill = y),
              (this.stroke = _);
          },
          _drawClipPath: function (f, v) {
            v &&
              ((v.canvas = this.canvas),
              v.shouldCache(),
              (v._transformDone = !0),
              v.renderCache({ forClipping: !0 }),
              this.drawClipPathOnCache(f, v));
          },
          drawCacheOnCanvas: function (f) {
            f.scale(1 / this.zoomX, 1 / this.zoomY),
              f.drawImage(
                this._cacheCanvas,
                -this.cacheTranslationX,
                -this.cacheTranslationY
              );
          },
          isCacheDirty: function (f) {
            if (this.isNotVisible()) return !1;
            if (
              this._cacheCanvas &&
              this._cacheContext &&
              !f &&
              this._updateCacheCanvas()
            )
              return !0;
            if (
              this.dirty ||
              (this.clipPath && this.clipPath.absolutePositioned) ||
              (this.statefullCache && this.hasStateChanged("cacheProperties"))
            ) {
              if (this._cacheCanvas && this._cacheContext && !f) {
                var v = this.cacheWidth / this.zoomX,
                  y = this.cacheHeight / this.zoomY;
                this._cacheContext.clearRect(-v / 2, -y / 2, v, y);
              }
              return !0;
            }
            return !1;
          },
          _renderBackground: function (f) {
            if (this.backgroundColor) {
              var v = this._getNonTransformedDimensions();
              (f.fillStyle = this.backgroundColor),
                f.fillRect(-v.x / 2, -v.y / 2, v.x, v.y),
                this._removeShadow(f);
            }
          },
          _setOpacity: function (f) {
            this.group && !this.group._transformDone
              ? (f.globalAlpha = this.getObjectOpacity())
              : (f.globalAlpha *= this.opacity);
          },
          _setStrokeStyles: function (f, v) {
            var y = v.stroke;
            y &&
              ((f.lineWidth = v.strokeWidth),
              (f.lineCap = v.strokeLineCap),
              (f.lineDashOffset = v.strokeDashOffset),
              (f.lineJoin = v.strokeLineJoin),
              (f.miterLimit = v.strokeMiterLimit),
              y.toLive
                ? y.gradientUnits === "percentage" ||
                  y.gradientTransform ||
                  y.patternTransform
                  ? this._applyPatternForTransformedGradient(f, y)
                  : ((f.strokeStyle = y.toLive(f, this)),
                    this._applyPatternGradientTransform(f, y))
                : (f.strokeStyle = v.stroke));
          },
          _setFillStyles: function (f, v) {
            var y = v.fill;
            y &&
              (y.toLive
                ? ((f.fillStyle = y.toLive(f, this)),
                  this._applyPatternGradientTransform(f, v.fill))
                : (f.fillStyle = y));
          },
          _setClippingProperties: function (f) {
            (f.globalAlpha = 1),
              (f.strokeStyle = "transparent"),
              (f.fillStyle = "#000000");
          },
          _setLineDash: function (f, v) {
            !v ||
              v.length === 0 ||
              (1 & v.length && v.push.apply(v, v), f.setLineDash(v));
          },
          _renderControls: function (f, v) {
            var y = this.getViewportTransform(),
              _ = this.calcTransformMatrix(),
              x,
              b,
              S;
            (v = v || {}),
              (b = typeof v.hasBorders < "u" ? v.hasBorders : this.hasBorders),
              (S =
                typeof v.hasControls < "u" ? v.hasControls : this.hasControls),
              (_ = s.util.multiplyTransformMatrices(y, _)),
              (x = s.util.qrDecompose(_)),
              f.save(),
              f.translate(x.translateX, x.translateY),
              (f.lineWidth = 1 * this.borderScaleFactor),
              this.group ||
                (f.globalAlpha = this.isMoving
                  ? this.borderOpacityWhenMoving
                  : 1),
              this.flipX && (x.angle -= 180),
              f.rotate(h(this.group ? x.angle : this.angle)),
              v.forActiveSelection || this.group
                ? b && this.drawBordersInGroup(f, x, v)
                : b && this.drawBorders(f, v),
              S && this.drawControls(f, v),
              f.restore();
          },
          _setShadow: function (f) {
            if (this.shadow) {
              var v = this.shadow,
                y = this.canvas,
                _,
                x = (y && y.viewportTransform[0]) || 1,
                b = (y && y.viewportTransform[3]) || 1;
              v.nonScaling
                ? (_ = { scaleX: 1, scaleY: 1 })
                : (_ = this.getObjectScaling()),
                y &&
                  y._isRetinaScaling() &&
                  ((x *= s.devicePixelRatio), (b *= s.devicePixelRatio)),
                (f.shadowColor = v.color),
                (f.shadowBlur =
                  (v.blur *
                    s.browserShadowBlurConstant *
                    (x + b) *
                    (_.scaleX + _.scaleY)) /
                  4),
                (f.shadowOffsetX = v.offsetX * x * _.scaleX),
                (f.shadowOffsetY = v.offsetY * b * _.scaleY);
            }
          },
          _removeShadow: function (f) {
            this.shadow &&
              ((f.shadowColor = ""),
              (f.shadowBlur = f.shadowOffsetX = f.shadowOffsetY = 0));
          },
          _applyPatternGradientTransform: function (f, v) {
            if (!v || !v.toLive) return { offsetX: 0, offsetY: 0 };
            var y = v.gradientTransform || v.patternTransform,
              _ = -this.width / 2 + v.offsetX || 0,
              x = -this.height / 2 + v.offsetY || 0;
            return (
              v.gradientUnits === "percentage"
                ? f.transform(this.width, 0, 0, this.height, _, x)
                : f.transform(1, 0, 0, 1, _, x),
              y && f.transform(y[0], y[1], y[2], y[3], y[4], y[5]),
              { offsetX: _, offsetY: x }
            );
          },
          _renderPaintInOrder: function (f) {
            this.paintFirst === "stroke"
              ? (this._renderStroke(f), this._renderFill(f))
              : (this._renderFill(f), this._renderStroke(f));
          },
          _render: function () {},
          _renderFill: function (f) {
            this.fill &&
              (f.save(),
              this._setFillStyles(f, this),
              this.fillRule === "evenodd" ? f.fill("evenodd") : f.fill(),
              f.restore());
          },
          _renderStroke: function (f) {
            if (!(!this.stroke || this.strokeWidth === 0)) {
              if (
                (this.shadow &&
                  !this.shadow.affectStroke &&
                  this._removeShadow(f),
                f.save(),
                this.strokeUniform && this.group)
              ) {
                var v = this.getObjectScaling();
                f.scale(1 / v.scaleX, 1 / v.scaleY);
              } else
                this.strokeUniform && f.scale(1 / this.scaleX, 1 / this.scaleY);
              this._setLineDash(f, this.strokeDashArray),
                this._setStrokeStyles(f, this),
                f.stroke(),
                f.restore();
            }
          },
          _applyPatternForTransformedGradient: function (f, v) {
            var y = this._limitCacheSize(this._getCacheCanvasDimensions()),
              _ = s.util.createCanvasElement(),
              x,
              b = this.canvas.getRetinaScaling(),
              S = y.x / this.scaleX / b,
              T = y.y / this.scaleY / b;
            (_.width = S),
              (_.height = T),
              (x = _.getContext("2d")),
              x.beginPath(),
              x.moveTo(0, 0),
              x.lineTo(S, 0),
              x.lineTo(S, T),
              x.lineTo(0, T),
              x.closePath(),
              x.translate(S / 2, T / 2),
              x.scale(y.zoomX / this.scaleX / b, y.zoomY / this.scaleY / b),
              this._applyPatternGradientTransform(x, v),
              (x.fillStyle = v.toLive(f)),
              x.fill(),
              f.translate(
                -this.width / 2 - this.strokeWidth / 2,
                -this.height / 2 - this.strokeWidth / 2
              ),
              f.scale((b * this.scaleX) / y.zoomX, (b * this.scaleY) / y.zoomY),
              (f.strokeStyle = x.createPattern(_, "no-repeat"));
          },
          _findCenterFromElement: function () {
            return {
              x: this.left + this.width / 2,
              y: this.top + this.height / 2,
            };
          },
          _assignTransformMatrixProps: function () {
            if (this.transformMatrix) {
              var f = s.util.qrDecompose(this.transformMatrix);
              (this.flipX = !1),
                (this.flipY = !1),
                this.set("scaleX", f.scaleX),
                this.set("scaleY", f.scaleY),
                (this.angle = f.angle),
                (this.skewX = f.skewX),
                (this.skewY = 0);
            }
          },
          _removeTransformMatrix: function (f) {
            var v = this._findCenterFromElement();
            this.transformMatrix &&
              (this._assignTransformMatrixProps(),
              (v = s.util.transformPoint(v, this.transformMatrix))),
              (this.transformMatrix = null),
              f &&
                ((this.scaleX *= f.scaleX),
                (this.scaleY *= f.scaleY),
                (this.cropX = f.cropX),
                (this.cropY = f.cropY),
                (v.x += f.offsetLeft),
                (v.y += f.offsetTop),
                (this.width = f.width),
                (this.height = f.height)),
              this.setPositionByOrigin(v, "center", "center");
          },
          clone: function (f, v) {
            var y = this.toObject(v);
            this.constructor.fromObject
              ? this.constructor.fromObject(y, f)
              : s.Object._fromObject("Object", y, f);
          },
          cloneAsImage: function (f, v) {
            var y = this.toCanvasElement(v);
            return f && f(new s.Image(y)), this;
          },
          toCanvasElement: function (f) {
            f || (f = {});
            var v = s.util,
              y = v.saveObjectTransform(this),
              _ = this.group,
              x = this.shadow,
              b = Math.abs,
              S =
                (f.multiplier || 1) *
                (f.enableRetinaScaling ? s.devicePixelRatio : 1);
            delete this.group,
              f.withoutTransform && v.resetObjectTransform(this),
              f.withoutShadow && (this.shadow = null);
            var T = s.util.createCanvasElement(),
              w = this.getBoundingRect(!0, !0),
              P = this.shadow,
              F,
              V = { x: 0, y: 0 },
              J,
              z,
              B;
            P &&
              ((J = P.blur),
              P.nonScaling
                ? (F = { scaleX: 1, scaleY: 1 })
                : (F = this.getObjectScaling()),
              (V.x = 2 * Math.round(b(P.offsetX) + J) * b(F.scaleX)),
              (V.y = 2 * Math.round(b(P.offsetY) + J) * b(F.scaleY))),
              (z = w.width + V.x),
              (B = w.height + V.y),
              (T.width = Math.ceil(z)),
              (T.height = Math.ceil(B));
            var G = new s.StaticCanvas(T, {
              enableRetinaScaling: !1,
              renderOnAddRemove: !1,
              skipOffscreen: !1,
            });
            f.format === "jpeg" && (G.backgroundColor = "#fff"),
              this.setPositionByOrigin(
                new s.Point(G.width / 2, G.height / 2),
                "center",
                "center"
              );
            var ie = this.canvas;
            G.add(this);
            var re = G.toCanvasElement(S || 1, f);
            return (
              (this.shadow = x),
              this.set("canvas", ie),
              _ && (this.group = _),
              this.set(y).setCoords(),
              (G._objects = []),
              G.dispose(),
              (G = null),
              re
            );
          },
          toDataURL: function (f) {
            return (
              f || (f = {}),
              s.util.toDataURL(
                this.toCanvasElement(f),
                f.format || "png",
                f.quality || 1
              )
            );
          },
          isType: function (f) {
            return arguments.length > 1
              ? Array.from(arguments).includes(this.type)
              : this.type === f;
          },
          complexity: function () {
            return 1;
          },
          toJSON: function (f) {
            return this.toObject(f);
          },
          rotate: function (f) {
            var v =
              (this.originX !== "center" || this.originY !== "center") &&
              this.centeredRotation;
            return (
              v && this._setOriginToCenter(),
              this.set("angle", f),
              v && this._resetOrigin(),
              this
            );
          },
          centerH: function () {
            return this.canvas && this.canvas.centerObjectH(this), this;
          },
          viewportCenterH: function () {
            return this.canvas && this.canvas.viewportCenterObjectH(this), this;
          },
          centerV: function () {
            return this.canvas && this.canvas.centerObjectV(this), this;
          },
          viewportCenterV: function () {
            return this.canvas && this.canvas.viewportCenterObjectV(this), this;
          },
          center: function () {
            return this.canvas && this.canvas.centerObject(this), this;
          },
          viewportCenter: function () {
            return this.canvas && this.canvas.viewportCenterObject(this), this;
          },
          getLocalPointer: function (f, v) {
            v = v || this.canvas.getPointer(f);
            var y = new s.Point(v.x, v.y),
              _ = this._getLeftTopCoords();
            return (
              this.angle && (y = s.util.rotatePoint(y, _, h(-this.angle))),
              { x: y.x - _.x, y: y.y - _.y }
            );
          },
          _setupCompositeOperation: function (f) {
            this.globalCompositeOperation &&
              (f.globalCompositeOperation = this.globalCompositeOperation);
          },
          dispose: function () {
            s.runningAnimations && s.runningAnimations.cancelByTarget(this);
          },
        })),
        s.util.createAccessors && s.util.createAccessors(s.Object),
        u(s.Object.prototype, s.Observable),
        (s.Object.NUM_FRACTION_DIGITS = 2),
        (s.Object.ENLIVEN_PROPS = ["clipPath"]),
        (s.Object._fromObject = function (f, v, y, _) {
          var x = s[f];
          (v = d(v, !0)),
            s.util.enlivenPatterns([v.fill, v.stroke], function (b) {
              typeof b[0] < "u" && (v.fill = b[0]),
                typeof b[1] < "u" && (v.stroke = b[1]),
                s.util.enlivenObjectEnlivables(v, v, function () {
                  var S = _ ? new x(v[_], v) : new x(v);
                  y && y(S);
                });
            });
        }),
        (s.Object.__uid = 0));
    })(n),
    (function () {
      var a = e.util.degreesToRadians,
        s = { left: -0.5, center: 0, right: 0.5 },
        u = { top: -0.5, center: 0, bottom: 0.5 };
      e.util.object.extend(e.Object.prototype, {
        translateToGivenOrigin: function (d, l, c, h, m) {
          var g = d.x,
            f = d.y,
            v,
            y,
            _;
          return (
            typeof l == "string" ? (l = s[l]) : (l -= 0.5),
            typeof h == "string" ? (h = s[h]) : (h -= 0.5),
            (v = h - l),
            typeof c == "string" ? (c = u[c]) : (c -= 0.5),
            typeof m == "string" ? (m = u[m]) : (m -= 0.5),
            (y = m - c),
            (v || y) &&
              ((_ = this._getTransformedDimensions()),
              (g = d.x + v * _.x),
              (f = d.y + y * _.y)),
            new e.Point(g, f)
          );
        },
        translateToCenterPoint: function (d, l, c) {
          var h = this.translateToGivenOrigin(d, l, c, "center", "center");
          return this.angle ? e.util.rotatePoint(h, d, a(this.angle)) : h;
        },
        translateToOriginPoint: function (d, l, c) {
          var h = this.translateToGivenOrigin(d, "center", "center", l, c);
          return this.angle ? e.util.rotatePoint(h, d, a(this.angle)) : h;
        },
        getCenterPoint: function () {
          var d = new e.Point(this.left, this.top);
          return this.translateToCenterPoint(d, this.originX, this.originY);
        },
        getPointByOrigin: function (d, l) {
          var c = this.getCenterPoint();
          return this.translateToOriginPoint(c, d, l);
        },
        toLocalPoint: function (d, l, c) {
          var h = this.getCenterPoint(),
            m,
            g;
          return (
            typeof l < "u" && typeof c < "u"
              ? (m = this.translateToGivenOrigin(h, "center", "center", l, c))
              : (m = new e.Point(this.left, this.top)),
            (g = new e.Point(d.x, d.y)),
            this.angle && (g = e.util.rotatePoint(g, h, -a(this.angle))),
            g.subtractEquals(m)
          );
        },
        setPositionByOrigin: function (d, l, c) {
          var h = this.translateToCenterPoint(d, l, c),
            m = this.translateToOriginPoint(h, this.originX, this.originY);
          this.set("left", m.x), this.set("top", m.y);
        },
        adjustPosition: function (d) {
          var l = a(this.angle),
            c = this.getScaledWidth(),
            h = e.util.cos(l) * c,
            m = e.util.sin(l) * c,
            g,
            f;
          typeof this.originX == "string"
            ? (g = s[this.originX])
            : (g = this.originX - 0.5),
            typeof d == "string" ? (f = s[d]) : (f = d - 0.5),
            (this.left += h * (f - g)),
            (this.top += m * (f - g)),
            this.setCoords(),
            (this.originX = d);
        },
        _setOriginToCenter: function () {
          (this._originalOriginX = this.originX),
            (this._originalOriginY = this.originY);
          var d = this.getCenterPoint();
          (this.originX = "center"),
            (this.originY = "center"),
            (this.left = d.x),
            (this.top = d.y);
        },
        _resetOrigin: function () {
          var d = this.translateToOriginPoint(
            this.getCenterPoint(),
            this._originalOriginX,
            this._originalOriginY
          );
          (this.originX = this._originalOriginX),
            (this.originY = this._originalOriginY),
            (this.left = d.x),
            (this.top = d.y),
            (this._originalOriginX = null),
            (this._originalOriginY = null);
        },
        _getLeftTopCoords: function () {
          return this.translateToOriginPoint(
            this.getCenterPoint(),
            "left",
            "top"
          );
        },
      });
    })(),
    (function () {
      function a(c) {
        return [
          new e.Point(c.tl.x, c.tl.y),
          new e.Point(c.tr.x, c.tr.y),
          new e.Point(c.br.x, c.br.y),
          new e.Point(c.bl.x, c.bl.y),
        ];
      }
      var s = e.util,
        u = s.degreesToRadians,
        d = s.multiplyTransformMatrices,
        l = s.transformPoint;
      s.object.extend(e.Object.prototype, {
        oCoords: null,
        aCoords: null,
        lineCoords: null,
        ownMatrixCache: null,
        matrixCache: null,
        controls: {},
        _getCoords: function (c, h) {
          return h
            ? c
              ? this.calcACoords()
              : this.calcLineCoords()
            : ((!this.aCoords || !this.lineCoords) && this.setCoords(!0),
              c ? this.aCoords : this.lineCoords);
        },
        getCoords: function (c, h) {
          return a(this._getCoords(c, h));
        },
        intersectsWithRect: function (c, h, m, g) {
          var f = this.getCoords(m, g),
            v = e.Intersection.intersectPolygonRectangle(f, c, h);
          return v.status === "Intersection";
        },
        intersectsWithObject: function (c, h, m) {
          var g = e.Intersection.intersectPolygonPolygon(
            this.getCoords(h, m),
            c.getCoords(h, m)
          );
          return (
            g.status === "Intersection" ||
            c.isContainedWithinObject(this, h, m) ||
            this.isContainedWithinObject(c, h, m)
          );
        },
        isContainedWithinObject: function (c, h, m) {
          for (
            var g = this.getCoords(h, m),
              f = h ? c.aCoords : c.lineCoords,
              v = 0,
              y = c._getImageLines(f);
            v < 4;
            v++
          )
            if (!c.containsPoint(g[v], y)) return !1;
          return !0;
        },
        isContainedWithinRect: function (c, h, m, g) {
          var f = this.getBoundingRect(m, g);
          return (
            f.left >= c.x &&
            f.left + f.width <= h.x &&
            f.top >= c.y &&
            f.top + f.height <= h.y
          );
        },
        containsPoint: function (c, v, m, g) {
          var f = this._getCoords(m, g),
            v = v || this._getImageLines(f),
            y = this._findCrossPoints(c, v);
          return y !== 0 && y % 2 === 1;
        },
        isOnScreen: function (c) {
          if (!this.canvas) return !1;
          var h = this.canvas.vptCoords.tl,
            m = this.canvas.vptCoords.br,
            g = this.getCoords(!0, c);
          return g.some(function (f) {
            return f.x <= m.x && f.x >= h.x && f.y <= m.y && f.y >= h.y;
          }) || this.intersectsWithRect(h, m, !0, c)
            ? !0
            : this._containsCenterOfCanvas(h, m, c);
        },
        _containsCenterOfCanvas: function (c, h, m) {
          var g = { x: (c.x + h.x) / 2, y: (c.y + h.y) / 2 };
          return !!this.containsPoint(g, null, !0, m);
        },
        isPartiallyOnScreen: function (c) {
          if (!this.canvas) return !1;
          var h = this.canvas.vptCoords.tl,
            m = this.canvas.vptCoords.br;
          if (this.intersectsWithRect(h, m, !0, c)) return !0;
          var g = this.getCoords(!0, c).every(function (f) {
            return (f.x >= m.x || f.x <= h.x) && (f.y >= m.y || f.y <= h.y);
          });
          return g && this._containsCenterOfCanvas(h, m, c);
        },
        _getImageLines: function (c) {
          var h = {
            topline: { o: c.tl, d: c.tr },
            rightline: { o: c.tr, d: c.br },
            bottomline: { o: c.br, d: c.bl },
            leftline: { o: c.bl, d: c.tl },
          };
          return h;
        },
        _findCrossPoints: function (c, h) {
          var m,
            g,
            f,
            v,
            y,
            _ = 0,
            x;
          for (var b in h)
            if (
              ((x = h[b]),
              !(x.o.y < c.y && x.d.y < c.y) &&
                !(x.o.y >= c.y && x.d.y >= c.y) &&
                (x.o.x === x.d.x && x.o.x >= c.x
                  ? (y = x.o.x)
                  : ((m = 0),
                    (g = (x.d.y - x.o.y) / (x.d.x - x.o.x)),
                    (f = c.y - m * c.x),
                    (v = x.o.y - g * x.o.x),
                    (y = -(f - v) / (m - g))),
                y >= c.x && (_ += 1),
                _ === 2))
            )
              break;
          return _;
        },
        getBoundingRect: function (c, h) {
          var m = this.getCoords(c, h);
          return s.makeBoundingBoxFromPoints(m);
        },
        getScaledWidth: function () {
          return this._getTransformedDimensions().x;
        },
        getScaledHeight: function () {
          return this._getTransformedDimensions().y;
        },
        _constrainScale: function (c) {
          return Math.abs(c) < this.minScaleLimit
            ? c < 0
              ? -this.minScaleLimit
              : this.minScaleLimit
            : c === 0
            ? 1e-4
            : c;
        },
        scale: function (c) {
          return (
            this._set("scaleX", c), this._set("scaleY", c), this.setCoords()
          );
        },
        scaleToWidth: function (c, h) {
          var m = this.getBoundingRect(h).width / this.getScaledWidth();
          return this.scale(c / this.width / m);
        },
        scaleToHeight: function (c, h) {
          var m = this.getBoundingRect(h).height / this.getScaledHeight();
          return this.scale(c / this.height / m);
        },
        calcLineCoords: function () {
          var c = this.getViewportTransform(),
            h = this.padding,
            m = u(this.angle),
            g = s.cos(m),
            f = s.sin(m),
            v = g * h,
            y = f * h,
            _ = v + y,
            x = v - y,
            b = this.calcACoords(),
            S = {
              tl: l(b.tl, c),
              tr: l(b.tr, c),
              bl: l(b.bl, c),
              br: l(b.br, c),
            };
          return (
            h &&
              ((S.tl.x -= x),
              (S.tl.y -= _),
              (S.tr.x += _),
              (S.tr.y -= x),
              (S.bl.x -= _),
              (S.bl.y += x),
              (S.br.x += x),
              (S.br.y += _)),
            S
          );
        },
        calcOCoords: function () {
          var c = this._calcRotateMatrix(),
            h = this._calcTranslateMatrix(),
            m = this.getViewportTransform(),
            g = d(m, h),
            f = d(g, c),
            f = d(f, [1 / m[0], 0, 0, 1 / m[3], 0, 0]),
            v = this._calculateCurrentDimensions(),
            y = {};
          return (
            this.forEachControl(function (_, x, b) {
              y[x] = _.positionHandler(v, f, b);
            }),
            y
          );
        },
        calcACoords: function () {
          var c = this._calcRotateMatrix(),
            h = this._calcTranslateMatrix(),
            m = d(h, c),
            g = this._getTransformedDimensions(),
            f = g.x / 2,
            v = g.y / 2;
          return {
            tl: l({ x: -f, y: -v }, m),
            tr: l({ x: f, y: -v }, m),
            bl: l({ x: -f, y: v }, m),
            br: l({ x: f, y: v }, m),
          };
        },
        setCoords: function (c) {
          return (
            (this.aCoords = this.calcACoords()),
            (this.lineCoords = this.group
              ? this.aCoords
              : this.calcLineCoords()),
            c
              ? this
              : ((this.oCoords = this.calcOCoords()),
                this._setCornerCoords && this._setCornerCoords(),
                this)
          );
        },
        _calcRotateMatrix: function () {
          return s.calcRotateMatrix(this);
        },
        _calcTranslateMatrix: function () {
          var c = this.getCenterPoint();
          return [1, 0, 0, 1, c.x, c.y];
        },
        transformMatrixKey: function (c) {
          var h = "_",
            m = "";
          return (
            !c && this.group && (m = this.group.transformMatrixKey(c) + h),
            m +
              this.top +
              h +
              this.left +
              h +
              this.scaleX +
              h +
              this.scaleY +
              h +
              this.skewX +
              h +
              this.skewY +
              h +
              this.angle +
              h +
              this.originX +
              h +
              this.originY +
              h +
              this.width +
              h +
              this.height +
              h +
              this.strokeWidth +
              this.flipX +
              this.flipY
          );
        },
        calcTransformMatrix: function (c) {
          var h = this.calcOwnMatrix();
          if (c || !this.group) return h;
          var m = this.transformMatrixKey(c),
            g = this.matrixCache || (this.matrixCache = {});
          return g.key === m
            ? g.value
            : (this.group && (h = d(this.group.calcTransformMatrix(!1), h)),
              (g.key = m),
              (g.value = h),
              h);
        },
        calcOwnMatrix: function () {
          var c = this.transformMatrixKey(!0),
            h = this.ownMatrixCache || (this.ownMatrixCache = {});
          if (h.key === c) return h.value;
          var m = this._calcTranslateMatrix(),
            g = {
              angle: this.angle,
              translateX: m[4],
              translateY: m[5],
              scaleX: this.scaleX,
              scaleY: this.scaleY,
              skewX: this.skewX,
              skewY: this.skewY,
              flipX: this.flipX,
              flipY: this.flipY,
            };
          return (h.key = c), (h.value = s.composeMatrix(g)), h.value;
        },
        _getNonTransformedDimensions: function () {
          var c = this.strokeWidth,
            h = this.width + c,
            m = this.height + c;
          return { x: h, y: m };
        },
        _getTransformedDimensions: function (c, h) {
          typeof c > "u" && (c = this.skewX),
            typeof h > "u" && (h = this.skewY);
          var m,
            g,
            f,
            v = c === 0 && h === 0;
          if (
            (this.strokeUniform
              ? ((g = this.width), (f = this.height))
              : ((m = this._getNonTransformedDimensions()),
                (g = m.x),
                (f = m.y)),
            v)
          )
            return this._finalizeDimensions(g * this.scaleX, f * this.scaleY);
          var y = s.sizeAfterTransform(g, f, {
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            skewX: c,
            skewY: h,
          });
          return this._finalizeDimensions(y.x, y.y);
        },
        _finalizeDimensions: function (c, h) {
          return this.strokeUniform
            ? { x: c + this.strokeWidth, y: h + this.strokeWidth }
            : { x: c, y: h };
        },
        _calculateCurrentDimensions: function () {
          var c = this.getViewportTransform(),
            h = this._getTransformedDimensions(),
            m = l(h, c, !0);
          return m.scalarAdd(2 * this.padding);
        },
      });
    })(),
    e.util.object.extend(e.Object.prototype, {
      sendToBack: function () {
        return (
          this.group
            ? e.StaticCanvas.prototype.sendToBack.call(this.group, this)
            : this.canvas && this.canvas.sendToBack(this),
          this
        );
      },
      bringToFront: function () {
        return (
          this.group
            ? e.StaticCanvas.prototype.bringToFront.call(this.group, this)
            : this.canvas && this.canvas.bringToFront(this),
          this
        );
      },
      sendBackwards: function (a) {
        return (
          this.group
            ? e.StaticCanvas.prototype.sendBackwards.call(this.group, this, a)
            : this.canvas && this.canvas.sendBackwards(this, a),
          this
        );
      },
      bringForward: function (a) {
        return (
          this.group
            ? e.StaticCanvas.prototype.bringForward.call(this.group, this, a)
            : this.canvas && this.canvas.bringForward(this, a),
          this
        );
      },
      moveTo: function (a) {
        return (
          this.group && this.group.type !== "activeSelection"
            ? e.StaticCanvas.prototype.moveTo.call(this.group, this, a)
            : this.canvas && this.canvas.moveTo(this, a),
          this
        );
      },
    }),
    (function () {
      function a(u, d) {
        if (d) {
          if (d.toLive) return u + ": url(#SVGID_" + d.id + "); ";
          var l = new e.Color(d),
            c = u + ": " + l.toRgb() + "; ",
            h = l.getAlpha();
          return h !== 1 && (c += u + "-opacity: " + h.toString() + "; "), c;
        } else return u + ": none; ";
      }
      var s = e.util.toFixed;
      e.util.object.extend(e.Object.prototype, {
        getSvgStyles: function (u) {
          var d = this.fillRule ? this.fillRule : "nonzero",
            l = this.strokeWidth ? this.strokeWidth : "0",
            c = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none",
            h = this.strokeDashOffset ? this.strokeDashOffset : "0",
            m = this.strokeLineCap ? this.strokeLineCap : "butt",
            g = this.strokeLineJoin ? this.strokeLineJoin : "miter",
            f = this.strokeMiterLimit ? this.strokeMiterLimit : "4",
            v = typeof this.opacity < "u" ? this.opacity : "1",
            y = this.visible ? "" : " visibility: hidden;",
            _ = u ? "" : this.getSvgFilter(),
            x = a("fill", this.fill),
            b = a("stroke", this.stroke);
          return [
            b,
            "stroke-width: ",
            l,
            "; ",
            "stroke-dasharray: ",
            c,
            "; ",
            "stroke-linecap: ",
            m,
            "; ",
            "stroke-dashoffset: ",
            h,
            "; ",
            "stroke-linejoin: ",
            g,
            "; ",
            "stroke-miterlimit: ",
            f,
            "; ",
            x,
            "fill-rule: ",
            d,
            "; ",
            "opacity: ",
            v,
            ";",
            _,
            y,
          ].join("");
        },
        getSvgSpanStyles: function (u, d) {
          var l = "; ",
            h = u.fontFamily
              ? "font-family: " +
                (u.fontFamily.indexOf("'") === -1 &&
                u.fontFamily.indexOf('"') === -1
                  ? "'" + u.fontFamily + "'"
                  : u.fontFamily) +
                l
              : "",
            c = u.strokeWidth ? "stroke-width: " + u.strokeWidth + l : "",
            h = h,
            m = u.fontSize ? "font-size: " + u.fontSize + "px" + l : "",
            g = u.fontStyle ? "font-style: " + u.fontStyle + l : "",
            f = u.fontWeight ? "font-weight: " + u.fontWeight + l : "",
            v = u.fill ? a("fill", u.fill) : "",
            y = u.stroke ? a("stroke", u.stroke) : "",
            _ = this.getSvgTextDecoration(u),
            x = u.deltaY ? "baseline-shift: " + -u.deltaY + "; " : "";
          return (
            _ && (_ = "text-decoration: " + _ + l),
            [y, c, h, m, g, f, _, v, x, d ? "white-space: pre; " : ""].join("")
          );
        },
        getSvgTextDecoration: function (u) {
          return ["overline", "underline", "line-through"]
            .filter(function (d) {
              return u[d.replace("-", "")];
            })
            .join(" ");
        },
        getSvgFilter: function () {
          return this.shadow
            ? "filter: url(#SVGID_" + this.shadow.id + ");"
            : "";
        },
        getSvgCommons: function () {
          return [
            this.id ? 'id="' + this.id + '" ' : "",
            this.clipPath
              ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" '
              : "",
          ].join("");
        },
        getSvgTransform: function (u, d) {
          var l = u ? this.calcTransformMatrix() : this.calcOwnMatrix(),
            c = 'transform="' + e.util.matrixToSVG(l);
          return c + (d || "") + '" ';
        },
        _setSVGBg: function (u) {
          if (this.backgroundColor) {
            var d = e.Object.NUM_FRACTION_DIGITS;
            u.push(
              "		<rect ",
              this._getFillAttributes(this.backgroundColor),
              ' x="',
              s(-this.width / 2, d),
              '" y="',
              s(-this.height / 2, d),
              '" width="',
              s(this.width, d),
              '" height="',
              s(this.height, d),
              `"></rect>
`
            );
          }
        },
        toSVG: function (u) {
          return this._createBaseSVGMarkup(this._toSVG(u), { reviver: u });
        },
        toClipPathSVG: function (u) {
          return (
            "	" +
            this._createBaseClipPathSVGMarkup(this._toSVG(u), { reviver: u })
          );
        },
        _createBaseClipPathSVGMarkup: function (u, d) {
          d = d || {};
          var l = d.reviver,
            c = d.additionalTransform || "",
            h = [this.getSvgTransform(!0, c), this.getSvgCommons()].join(""),
            m = u.indexOf("COMMON_PARTS");
          return (u[m] = h), l ? l(u.join("")) : u.join("");
        },
        _createBaseSVGMarkup: function (u, d) {
          d = d || {};
          var l = d.noStyle,
            c = d.reviver,
            h = l ? "" : 'style="' + this.getSvgStyles() + '" ',
            m = d.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "",
            g = this.clipPath,
            f = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "",
            v = g && g.absolutePositioned,
            y = this.stroke,
            _ = this.fill,
            x = this.shadow,
            b,
            S = [],
            T,
            w = u.indexOf("COMMON_PARTS"),
            P = d.additionalTransform;
          return (
            g &&
              ((g.clipPathId = "CLIPPATH_" + e.Object.__uid++),
              (T =
                '<clipPath id="' +
                g.clipPathId +
                `" >
` +
                g.toClipPathSVG(c) +
                `</clipPath>
`)),
            v &&
              S.push(
                "<g ",
                m,
                this.getSvgCommons(),
                ` >
`
              ),
            S.push(
              "<g ",
              this.getSvgTransform(!1),
              v ? "" : m + this.getSvgCommons(),
              ` >
`
            ),
            (b = [
              h,
              f,
              l ? "" : this.addPaintOrder(),
              " ",
              P ? 'transform="' + P + '" ' : "",
            ].join("")),
            (u[w] = b),
            _ && _.toLive && S.push(_.toSVG(this)),
            y && y.toLive && S.push(y.toSVG(this)),
            x && S.push(x.toSVG(this)),
            g && S.push(T),
            S.push(u.join("")),
            S.push(`</g>
`),
            v &&
              S.push(`</g>
`),
            c ? c(S.join("")) : S.join("")
          );
        },
        addPaintOrder: function () {
          return this.paintFirst !== "fill"
            ? ' paint-order="' + this.paintFirst + '" '
            : "";
        },
      });
    })(),
    (function () {
      var a = e.util.object.extend,
        s = "stateProperties";
      function u(l, c, h) {
        var m = {},
          g = !0;
        h.forEach(function (f) {
          m[f] = l[f];
        }),
          a(l[c], m, g);
      }
      function d(l, c, h) {
        if (l === c) return !0;
        if (Array.isArray(l)) {
          if (!Array.isArray(c) || l.length !== c.length) return !1;
          for (var m = 0, g = l.length; m < g; m++)
            if (!d(l[m], c[m])) return !1;
          return !0;
        } else if (l && typeof l == "object") {
          var f = Object.keys(l),
            v;
          if (
            !c ||
            typeof c != "object" ||
            (!h && f.length !== Object.keys(c).length)
          )
            return !1;
          for (var m = 0, g = f.length; m < g; m++)
            if (
              ((v = f[m]), !(v === "canvas" || v === "group") && !d(l[v], c[v]))
            )
              return !1;
          return !0;
        }
      }
      e.util.object.extend(e.Object.prototype, {
        hasStateChanged: function (l) {
          l = l || s;
          var c = "_" + l;
          return Object.keys(this[c]).length < this[l].length
            ? !0
            : !d(this[c], this, !0);
        },
        saveState: function (l) {
          var c = (l && l.propertySet) || s,
            h = "_" + c;
          return this[h]
            ? (u(this, h, this[c]),
              l && l.stateProperties && u(this, h, l.stateProperties),
              this)
            : this.setupState(l);
        },
        setupState: function (l) {
          l = l || {};
          var c = l.propertySet || s;
          return (
            (l.propertySet = c), (this["_" + c] = {}), this.saveState(l), this
          );
        },
      });
    })(),
    (function () {
      var a = e.util.degreesToRadians;
      e.util.object.extend(e.Object.prototype, {
        _findTargetCorner: function (s, u) {
          if (
            !this.hasControls ||
            this.group ||
            !this.canvas ||
            this.canvas._activeObject !== this
          )
            return !1;
          var d = s.x,
            l = s.y,
            c,
            h,
            m = Object.keys(this.oCoords),
            g = m.length - 1,
            f;
          for (this.__corner = 0; g >= 0; g--)
            if (
              ((f = m[g]),
              !!this.isControlVisible(f) &&
                ((h = this._getImageLines(
                  u ? this.oCoords[f].touchCorner : this.oCoords[f].corner
                )),
                (c = this._findCrossPoints({ x: d, y: l }, h)),
                c !== 0 && c % 2 === 1))
            )
              return (this.__corner = f), f;
          return !1;
        },
        forEachControl: function (s) {
          for (var u in this.controls) s(this.controls[u], u, this);
        },
        _setCornerCoords: function () {
          var s = this.oCoords;
          for (var u in s) {
            var d = this.controls[u];
            (s[u].corner = d.calcCornerCoords(
              this.angle,
              this.cornerSize,
              s[u].x,
              s[u].y,
              !1
            )),
              (s[u].touchCorner = d.calcCornerCoords(
                this.angle,
                this.touchCornerSize,
                s[u].x,
                s[u].y,
                !0
              ));
          }
        },
        drawSelectionBackground: function (s) {
          if (
            !this.selectionBackgroundColor ||
            (this.canvas && !this.canvas.interactive) ||
            (this.canvas && this.canvas._activeObject !== this)
          )
            return this;
          s.save();
          var u = this.getCenterPoint(),
            d = this._calculateCurrentDimensions(),
            l = this.canvas.viewportTransform;
          return (
            s.translate(u.x, u.y),
            s.scale(1 / l[0], 1 / l[3]),
            s.rotate(a(this.angle)),
            (s.fillStyle = this.selectionBackgroundColor),
            s.fillRect(-d.x / 2, -d.y / 2, d.x, d.y),
            s.restore(),
            this
          );
        },
        drawBorders: function (s, u) {
          u = u || {};
          var d = this._calculateCurrentDimensions(),
            l = this.borderScaleFactor,
            c = d.x + l,
            h = d.y + l,
            m = typeof u.hasControls < "u" ? u.hasControls : this.hasControls,
            g = !1;
          return (
            s.save(),
            (s.strokeStyle = u.borderColor || this.borderColor),
            this._setLineDash(s, u.borderDashArray || this.borderDashArray),
            s.strokeRect(-c / 2, -h / 2, c, h),
            m &&
              (s.beginPath(),
              this.forEachControl(function (f, v, y) {
                f.withConnection &&
                  f.getVisibility(y, v) &&
                  ((g = !0),
                  s.moveTo(f.x * c, f.y * h),
                  s.lineTo(f.x * c + f.offsetX, f.y * h + f.offsetY));
              }),
              g && s.stroke()),
            s.restore(),
            this
          );
        },
        drawBordersInGroup: function (s, u, d) {
          d = d || {};
          var l = e.util.sizeAfterTransform(this.width, this.height, u),
            c = this.strokeWidth,
            h = this.strokeUniform,
            m = this.borderScaleFactor,
            g = l.x + c * (h ? this.canvas.getZoom() : u.scaleX) + m,
            f = l.y + c * (h ? this.canvas.getZoom() : u.scaleY) + m;
          return (
            s.save(),
            this._setLineDash(s, d.borderDashArray || this.borderDashArray),
            (s.strokeStyle = d.borderColor || this.borderColor),
            s.strokeRect(-g / 2, -f / 2, g, f),
            s.restore(),
            this
          );
        },
        drawControls: function (s, u) {
          (u = u || {}), s.save();
          var d = this.canvas.getRetinaScaling(),
            l,
            c;
          return (
            s.setTransform(d, 0, 0, d, 0, 0),
            (s.strokeStyle = s.fillStyle = u.cornerColor || this.cornerColor),
            this.transparentCorners ||
              (s.strokeStyle = u.cornerStrokeColor || this.cornerStrokeColor),
            this._setLineDash(s, u.cornerDashArray || this.cornerDashArray),
            this.setCoords(),
            this.group && (l = this.group.calcTransformMatrix()),
            this.forEachControl(function (h, m, g) {
              (c = g.oCoords[m]),
                h.getVisibility(g, m) &&
                  (l && (c = e.util.transformPoint(c, l)),
                  h.render(s, c.x, c.y, u, g));
            }),
            s.restore(),
            this
          );
        },
        isControlVisible: function (s) {
          return this.controls[s] && this.controls[s].getVisibility(this, s);
        },
        setControlVisible: function (s, u) {
          return (
            this._controlsVisibility || (this._controlsVisibility = {}),
            (this._controlsVisibility[s] = u),
            this
          );
        },
        setControlsVisibility: function (s) {
          s || (s = {});
          for (var u in s) this.setControlVisible(u, s[u]);
          return this;
        },
        onDeselect: function () {},
        onSelect: function () {},
      });
    })(),
    e.util.object.extend(e.StaticCanvas.prototype, {
      FX_DURATION: 500,
      fxCenterObjectH: function (a, s) {
        s = s || {};
        var u = function () {},
          d = s.onComplete || u,
          l = s.onChange || u,
          c = this;
        return e.util.animate({
          target: this,
          startValue: a.left,
          endValue: this.getCenterPoint().x,
          duration: this.FX_DURATION,
          onChange: function (h) {
            a.set("left", h), c.requestRenderAll(), l();
          },
          onComplete: function () {
            a.setCoords(), d();
          },
        });
      },
      fxCenterObjectV: function (a, s) {
        s = s || {};
        var u = function () {},
          d = s.onComplete || u,
          l = s.onChange || u,
          c = this;
        return e.util.animate({
          target: this,
          startValue: a.top,
          endValue: this.getCenterPoint().y,
          duration: this.FX_DURATION,
          onChange: function (h) {
            a.set("top", h), c.requestRenderAll(), l();
          },
          onComplete: function () {
            a.setCoords(), d();
          },
        });
      },
      fxRemove: function (a, s) {
        s = s || {};
        var u = function () {},
          d = s.onComplete || u,
          l = s.onChange || u,
          c = this;
        return e.util.animate({
          target: this,
          startValue: a.opacity,
          endValue: 0,
          duration: this.FX_DURATION,
          onChange: function (h) {
            a.set("opacity", h), c.requestRenderAll(), l();
          },
          onComplete: function () {
            c.remove(a), d();
          },
        });
      },
    }),
    e.util.object.extend(e.Object.prototype, {
      animate: function () {
        if (arguments[0] && typeof arguments[0] == "object") {
          var a = [],
            s,
            u,
            d = [];
          for (s in arguments[0]) a.push(s);
          for (var l = 0, c = a.length; l < c; l++)
            (s = a[l]),
              (u = l !== c - 1),
              d.push(this._animate(s, arguments[0][s], arguments[1], u));
          return d;
        } else return this._animate.apply(this, arguments);
      },
      _animate: function (a, s, u, d) {
        var l = this,
          c;
        (s = s.toString()),
          u ? (u = e.util.object.clone(u)) : (u = {}),
          ~a.indexOf(".") && (c = a.split("."));
        var h =
            l.colorProperties.indexOf(a) > -1 ||
            (c && l.colorProperties.indexOf(c[1]) > -1),
          m = c ? this.get(c[0])[c[1]] : this.get(a);
        "from" in u || (u.from = m),
          h ||
            (~s.indexOf("=")
              ? (s = m + parseFloat(s.replace("=", "")))
              : (s = parseFloat(s)));
        var g = {
          target: this,
          startValue: u.from,
          endValue: s,
          byValue: u.by,
          easing: u.easing,
          duration: u.duration,
          abort:
            u.abort &&
            function (f, v, y) {
              return u.abort.call(l, f, v, y);
            },
          onChange: function (f, v, y) {
            c ? (l[c[0]][c[1]] = f) : l.set(a, f),
              !d && u.onChange && u.onChange(f, v, y);
          },
          onComplete: function (f, v, y) {
            d || (l.setCoords(), u.onComplete && u.onComplete(f, v, y));
          },
        };
        return h
          ? e.util.animateColor(g.startValue, g.endValue, g.duration, g)
          : e.util.animate(g);
      },
    }),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.extend,
        d = s.util.object.clone,
        l = { x1: 1, x2: 1, y1: 1, y2: 1 };
      if (s.Line) {
        s.warn("fabric.Line is already defined");
        return;
      }
      (s.Line = s.util.createClass(s.Object, {
        type: "line",
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        cacheProperties: s.Object.prototype.cacheProperties.concat(
          "x1",
          "x2",
          "y1",
          "y2"
        ),
        initialize: function (h, m) {
          h || (h = [0, 0, 0, 0]),
            this.callSuper("initialize", m),
            this.set("x1", h[0]),
            this.set("y1", h[1]),
            this.set("x2", h[2]),
            this.set("y2", h[3]),
            this._setWidthHeight(m);
        },
        _setWidthHeight: function (h) {
          h || (h = {}),
            (this.width = Math.abs(this.x2 - this.x1)),
            (this.height = Math.abs(this.y2 - this.y1)),
            (this.left = "left" in h ? h.left : this._getLeftToOriginX()),
            (this.top = "top" in h ? h.top : this._getTopToOriginY());
        },
        _set: function (h, m) {
          return (
            this.callSuper("_set", h, m),
            typeof l[h] < "u" && this._setWidthHeight(),
            this
          );
        },
        _getLeftToOriginX: c(
          { origin: "originX", axis1: "x1", axis2: "x2", dimension: "width" },
          { nearest: "left", center: "center", farthest: "right" }
        ),
        _getTopToOriginY: c(
          { origin: "originY", axis1: "y1", axis2: "y2", dimension: "height" },
          { nearest: "top", center: "center", farthest: "bottom" }
        ),
        _render: function (h) {
          h.beginPath();
          var m = this.calcLinePoints();
          h.moveTo(m.x1, m.y1),
            h.lineTo(m.x2, m.y2),
            (h.lineWidth = this.strokeWidth);
          var g = h.strokeStyle;
          (h.strokeStyle = this.stroke || h.fillStyle),
            this.stroke && this._renderStroke(h),
            (h.strokeStyle = g);
        },
        _findCenterFromElement: function () {
          return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 };
        },
        toObject: function (h) {
          return u(this.callSuper("toObject", h), this.calcLinePoints());
        },
        _getNonTransformedDimensions: function () {
          var h = this.callSuper("_getNonTransformedDimensions");
          return (
            this.strokeLineCap === "butt" &&
              (this.width === 0 && (h.y -= this.strokeWidth),
              this.height === 0 && (h.x -= this.strokeWidth)),
            h
          );
        },
        calcLinePoints: function () {
          var h = this.x1 <= this.x2 ? -1 : 1,
            m = this.y1 <= this.y2 ? -1 : 1,
            g = h * this.width * 0.5,
            f = m * this.height * 0.5,
            v = h * this.width * -0.5,
            y = m * this.height * -0.5;
          return { x1: g, x2: v, y1: f, y2: y };
        },
        _toSVG: function () {
          var h = this.calcLinePoints();
          return [
            "<line ",
            "COMMON_PARTS",
            'x1="',
            h.x1,
            '" y1="',
            h.y1,
            '" x2="',
            h.x2,
            '" y2="',
            h.y2,
            `" />
`,
          ];
        },
      })),
        (s.Line.ATTRIBUTE_NAMES = s.SHARED_ATTRIBUTES.concat(
          "x1 y1 x2 y2".split(" ")
        )),
        (s.Line.fromElement = function (h, m, g) {
          g = g || {};
          var f = s.parseAttributes(h, s.Line.ATTRIBUTE_NAMES),
            v = [f.x1 || 0, f.y1 || 0, f.x2 || 0, f.y2 || 0];
          m(new s.Line(v, u(f, g)));
        }),
        (s.Line.fromObject = function (h, m) {
          function g(v) {
            delete v.points, m && m(v);
          }
          var f = d(h, !0);
          (f.points = [h.x1, h.y1, h.x2, h.y2]),
            s.Object._fromObject("Line", f, g, "points");
        });
      function c(h, m) {
        var g = h.origin,
          f = h.axis1,
          v = h.axis2,
          y = h.dimension,
          _ = m.nearest,
          x = m.center,
          b = m.farthest;
        return function () {
          switch (this.get(g)) {
            case _:
              return Math.min(this.get(f), this.get(v));
            case x:
              return Math.min(this.get(f), this.get(v)) + 0.5 * this.get(y);
            case b:
              return Math.max(this.get(f), this.get(v));
          }
        };
      }
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.degreesToRadians;
      if (s.Circle) {
        s.warn("fabric.Circle is already defined.");
        return;
      }
      (s.Circle = s.util.createClass(s.Object, {
        type: "circle",
        radius: 0,
        startAngle: 0,
        endAngle: 360,
        cacheProperties: s.Object.prototype.cacheProperties.concat(
          "radius",
          "startAngle",
          "endAngle"
        ),
        _set: function (l, c) {
          return (
            this.callSuper("_set", l, c),
            l === "radius" && this.setRadius(c),
            this
          );
        },
        toObject: function (l) {
          return this.callSuper(
            "toObject",
            ["radius", "startAngle", "endAngle"].concat(l)
          );
        },
        _toSVG: function () {
          var l,
            c = 0,
            h = 0,
            m = (this.endAngle - this.startAngle) % 360;
          if (m === 0)
            l = [
              "<circle ",
              "COMMON_PARTS",
              'cx="' + c + '" cy="' + h + '" ',
              'r="',
              this.radius,
              `" />
`,
            ];
          else {
            var g = u(this.startAngle),
              f = u(this.endAngle),
              v = this.radius,
              y = s.util.cos(g) * v,
              _ = s.util.sin(g) * v,
              x = s.util.cos(f) * v,
              b = s.util.sin(f) * v,
              S = m > 180 ? "1" : "0";
            l = [
              '<path d="M ' + y + " " + _,
              " A " + v + " " + v,
              " 0 ",
              +S + " 1",
              " " + x + " " + b,
              '" ',
              "COMMON_PARTS",
              ` />
`,
            ];
          }
          return l;
        },
        _render: function (l) {
          l.beginPath(),
            l.arc(0, 0, this.radius, u(this.startAngle), u(this.endAngle), !1),
            this._renderPaintInOrder(l);
        },
        getRadiusX: function () {
          return this.get("radius") * this.get("scaleX");
        },
        getRadiusY: function () {
          return this.get("radius") * this.get("scaleY");
        },
        setRadius: function (l) {
          return (
            (this.radius = l), this.set("width", l * 2).set("height", l * 2)
          );
        },
      })),
        (s.Circle.ATTRIBUTE_NAMES = s.SHARED_ATTRIBUTES.concat(
          "cx cy r".split(" ")
        )),
        (s.Circle.fromElement = function (l, c) {
          var h = s.parseAttributes(l, s.Circle.ATTRIBUTE_NAMES);
          if (!d(h))
            throw new Error(
              "value of `r` attribute is required and can not be negative"
            );
          (h.left = (h.left || 0) - h.radius),
            (h.top = (h.top || 0) - h.radius),
            c(new s.Circle(h));
        });
      function d(l) {
        return "radius" in l && l.radius >= 0;
      }
      s.Circle.fromObject = function (l, c) {
        s.Object._fromObject("Circle", l, c);
      };
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {});
      if (s.Triangle) {
        s.warn("fabric.Triangle is already defined");
        return;
      }
      (s.Triangle = s.util.createClass(s.Object, {
        type: "triangle",
        width: 100,
        height: 100,
        _render: function (u) {
          var d = this.width / 2,
            l = this.height / 2;
          u.beginPath(),
            u.moveTo(-d, l),
            u.lineTo(0, -l),
            u.lineTo(d, l),
            u.closePath(),
            this._renderPaintInOrder(u);
        },
        _toSVG: function () {
          var u = this.width / 2,
            d = this.height / 2,
            l = [-u + " " + d, "0 " + -d, u + " " + d].join(",");
          return ["<polygon ", "COMMON_PARTS", 'points="', l, '" />'];
        },
      })),
        (s.Triangle.fromObject = function (u, d) {
          return s.Object._fromObject("Triangle", u, d);
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = Math.PI * 2;
      if (s.Ellipse) {
        s.warn("fabric.Ellipse is already defined.");
        return;
      }
      (s.Ellipse = s.util.createClass(s.Object, {
        type: "ellipse",
        rx: 0,
        ry: 0,
        cacheProperties: s.Object.prototype.cacheProperties.concat("rx", "ry"),
        initialize: function (d) {
          this.callSuper("initialize", d),
            this.set("rx", (d && d.rx) || 0),
            this.set("ry", (d && d.ry) || 0);
        },
        _set: function (d, l) {
          switch ((this.callSuper("_set", d, l), d)) {
            case "rx":
              (this.rx = l), this.set("width", l * 2);
              break;
            case "ry":
              (this.ry = l), this.set("height", l * 2);
              break;
          }
          return this;
        },
        getRx: function () {
          return this.get("rx") * this.get("scaleX");
        },
        getRy: function () {
          return this.get("ry") * this.get("scaleY");
        },
        toObject: function (d) {
          return this.callSuper("toObject", ["rx", "ry"].concat(d));
        },
        _toSVG: function () {
          return [
            "<ellipse ",
            "COMMON_PARTS",
            'cx="0" cy="0" ',
            'rx="',
            this.rx,
            '" ry="',
            this.ry,
            `" />
`,
          ];
        },
        _render: function (d) {
          d.beginPath(),
            d.save(),
            d.transform(1, 0, 0, this.ry / this.rx, 0, 0),
            d.arc(0, 0, this.rx, 0, u, !1),
            d.restore(),
            this._renderPaintInOrder(d);
        },
      })),
        (s.Ellipse.ATTRIBUTE_NAMES = s.SHARED_ATTRIBUTES.concat(
          "cx cy rx ry".split(" ")
        )),
        (s.Ellipse.fromElement = function (d, l) {
          var c = s.parseAttributes(d, s.Ellipse.ATTRIBUTE_NAMES);
          (c.left = (c.left || 0) - c.rx),
            (c.top = (c.top || 0) - c.ry),
            l(new s.Ellipse(c));
        }),
        (s.Ellipse.fromObject = function (d, l) {
          s.Object._fromObject("Ellipse", d, l);
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.extend;
      if (s.Rect) {
        s.warn("fabric.Rect is already defined");
        return;
      }
      (s.Rect = s.util.createClass(s.Object, {
        stateProperties: s.Object.prototype.stateProperties.concat("rx", "ry"),
        type: "rect",
        rx: 0,
        ry: 0,
        cacheProperties: s.Object.prototype.cacheProperties.concat("rx", "ry"),
        initialize: function (d) {
          this.callSuper("initialize", d), this._initRxRy();
        },
        _initRxRy: function () {
          this.rx && !this.ry
            ? (this.ry = this.rx)
            : this.ry && !this.rx && (this.rx = this.ry);
        },
        _render: function (d) {
          var l = this.rx ? Math.min(this.rx, this.width / 2) : 0,
            c = this.ry ? Math.min(this.ry, this.height / 2) : 0,
            h = this.width,
            m = this.height,
            g = -this.width / 2,
            f = -this.height / 2,
            v = l !== 0 || c !== 0,
            y = 1 - 0.5522847498;
          d.beginPath(),
            d.moveTo(g + l, f),
            d.lineTo(g + h - l, f),
            v &&
              d.bezierCurveTo(g + h - y * l, f, g + h, f + y * c, g + h, f + c),
            d.lineTo(g + h, f + m - c),
            v &&
              d.bezierCurveTo(
                g + h,
                f + m - y * c,
                g + h - y * l,
                f + m,
                g + h - l,
                f + m
              ),
            d.lineTo(g + l, f + m),
            v &&
              d.bezierCurveTo(g + y * l, f + m, g, f + m - y * c, g, f + m - c),
            d.lineTo(g, f + c),
            v && d.bezierCurveTo(g, f + y * c, g + y * l, f, g + l, f),
            d.closePath(),
            this._renderPaintInOrder(d);
        },
        toObject: function (d) {
          return this.callSuper("toObject", ["rx", "ry"].concat(d));
        },
        _toSVG: function () {
          var d = -this.width / 2,
            l = -this.height / 2;
          return [
            "<rect ",
            "COMMON_PARTS",
            'x="',
            d,
            '" y="',
            l,
            '" rx="',
            this.rx,
            '" ry="',
            this.ry,
            '" width="',
            this.width,
            '" height="',
            this.height,
            `" />
`,
          ];
        },
      })),
        (s.Rect.ATTRIBUTE_NAMES = s.SHARED_ATTRIBUTES.concat(
          "x y rx ry width height".split(" ")
        )),
        (s.Rect.fromElement = function (d, l, c) {
          if (!d) return l(null);
          c = c || {};
          var h = s.parseAttributes(d, s.Rect.ATTRIBUTE_NAMES);
          (h.left = h.left || 0),
            (h.top = h.top || 0),
            (h.height = h.height || 0),
            (h.width = h.width || 0);
          var m = new s.Rect(u(c ? s.util.object.clone(c) : {}, h));
          (m.visible = m.visible && m.width > 0 && m.height > 0), l(m);
        }),
        (s.Rect.fromObject = function (d, l) {
          return s.Object._fromObject("Rect", d, l);
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.extend,
        d = s.util.array.min,
        l = s.util.array.max,
        c = s.util.toFixed,
        h = s.util.projectStrokeOnPoints;
      if (s.Polyline) {
        s.warn("fabric.Polyline is already defined");
        return;
      }
      (s.Polyline = s.util.createClass(s.Object, {
        type: "polyline",
        points: null,
        exactBoundingBox: !1,
        cacheProperties: s.Object.prototype.cacheProperties.concat("points"),
        initialize: function (m, g) {
          (g = g || {}),
            (this.points = m || []),
            this.callSuper("initialize", g),
            this._setPositionDimensions(g);
        },
        _projectStrokeOnPoints: function () {
          return h(this.points, this, !0);
        },
        _setPositionDimensions: function (m) {
          var g = this._calcDimensions(m),
            f,
            v = this.exactBoundingBox ? this.strokeWidth : 0;
          (this.width = g.width - v),
            (this.height = g.height - v),
            m.fromSVG ||
              (f = this.translateToGivenOrigin(
                {
                  x: g.left - this.strokeWidth / 2 + v / 2,
                  y: g.top - this.strokeWidth / 2 + v / 2,
                },
                "left",
                "top",
                this.originX,
                this.originY
              )),
            typeof m.left > "u" && (this.left = m.fromSVG ? g.left : f.x),
            typeof m.top > "u" && (this.top = m.fromSVG ? g.top : f.y),
            (this.pathOffset = {
              x: g.left + this.width / 2 + v / 2,
              y: g.top + this.height / 2 + v / 2,
            });
        },
        _calcDimensions: function () {
          var m = this.exactBoundingBox
              ? this._projectStrokeOnPoints()
              : this.points,
            g = d(m, "x") || 0,
            f = d(m, "y") || 0,
            v = l(m, "x") || 0,
            y = l(m, "y") || 0,
            _ = v - g,
            x = y - f;
          return { left: g, top: f, width: _, height: x };
        },
        toObject: function (m) {
          return u(this.callSuper("toObject", m), {
            points: this.points.concat(),
          });
        },
        _toSVG: function () {
          for (
            var m = [],
              g = this.pathOffset.x,
              f = this.pathOffset.y,
              v = s.Object.NUM_FRACTION_DIGITS,
              y = 0,
              _ = this.points.length;
            y < _;
            y++
          )
            m.push(
              c(this.points[y].x - g, v),
              ",",
              c(this.points[y].y - f, v),
              " "
            );
          return [
            "<" + this.type + " ",
            "COMMON_PARTS",
            'points="',
            m.join(""),
            `" />
`,
          ];
        },
        commonRender: function (m) {
          var g,
            f = this.points.length,
            v = this.pathOffset.x,
            y = this.pathOffset.y;
          if (!f || isNaN(this.points[f - 1].y)) return !1;
          m.beginPath(), m.moveTo(this.points[0].x - v, this.points[0].y - y);
          for (var _ = 0; _ < f; _++)
            (g = this.points[_]), m.lineTo(g.x - v, g.y - y);
          return !0;
        },
        _render: function (m) {
          this.commonRender(m) && this._renderPaintInOrder(m);
        },
        complexity: function () {
          return this.get("points").length;
        },
      })),
        (s.Polyline.ATTRIBUTE_NAMES = s.SHARED_ATTRIBUTES.concat()),
        (s.Polyline.fromElementGenerator = function (m) {
          return function (g, f, v) {
            if (!g) return f(null);
            v || (v = {});
            var y = s.parsePointsAttribute(g.getAttribute("points")),
              _ = s.parseAttributes(g, s[m].ATTRIBUTE_NAMES);
            (_.fromSVG = !0), f(new s[m](y, u(_, v)));
          };
        }),
        (s.Polyline.fromElement = s.Polyline.fromElementGenerator("Polyline")),
        (s.Polyline.fromObject = function (m, g) {
          return s.Object._fromObject("Polyline", m, g, "points");
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.projectStrokeOnPoints;
      if (s.Polygon) {
        s.warn("fabric.Polygon is already defined");
        return;
      }
      (s.Polygon = s.util.createClass(s.Polyline, {
        type: "polygon",
        _projectStrokeOnPoints: function () {
          return u(this.points, this);
        },
        _render: function (d) {
          this.commonRender(d) && (d.closePath(), this._renderPaintInOrder(d));
        },
      })),
        (s.Polygon.ATTRIBUTE_NAMES = s.SHARED_ATTRIBUTES.concat()),
        (s.Polygon.fromElement = s.Polyline.fromElementGenerator("Polygon")),
        (s.Polygon.fromObject = function (d, l) {
          s.Object._fromObject("Polygon", d, l, "points");
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.array.min,
        d = s.util.array.max,
        l = s.util.object.extend,
        c = s.util.object.clone,
        h = s.util.toFixed;
      if (s.Path) {
        s.warn("fabric.Path is already defined");
        return;
      }
      (s.Path = s.util.createClass(s.Object, {
        type: "path",
        path: null,
        cacheProperties: s.Object.prototype.cacheProperties.concat(
          "path",
          "fillRule"
        ),
        stateProperties: s.Object.prototype.stateProperties.concat("path"),
        initialize: function (m, g) {
          (g = c(g || {})),
            delete g.path,
            this.callSuper("initialize", g),
            this._setPath(m || [], g);
        },
        _setPath: function (m, g) {
          (this.path = s.util.makePathSimpler(
            Array.isArray(m) ? m : s.util.parsePath(m)
          )),
            s.Polyline.prototype._setPositionDimensions.call(this, g || {});
        },
        _renderPathCommands: function (m) {
          var g,
            f = 0,
            v = 0,
            y = 0,
            _ = 0,
            x = 0,
            b = 0,
            S = -this.pathOffset.x,
            T = -this.pathOffset.y;
          m.beginPath();
          for (var w = 0, P = this.path.length; w < P; ++w)
            switch (((g = this.path[w]), g[0])) {
              case "L":
                (y = g[1]), (_ = g[2]), m.lineTo(y + S, _ + T);
                break;
              case "M":
                (y = g[1]),
                  (_ = g[2]),
                  (f = y),
                  (v = _),
                  m.moveTo(y + S, _ + T);
                break;
              case "C":
                (y = g[5]),
                  (_ = g[6]),
                  (x = g[3]),
                  (b = g[4]),
                  m.bezierCurveTo(
                    g[1] + S,
                    g[2] + T,
                    x + S,
                    b + T,
                    y + S,
                    _ + T
                  );
                break;
              case "Q":
                m.quadraticCurveTo(g[1] + S, g[2] + T, g[3] + S, g[4] + T),
                  (y = g[3]),
                  (_ = g[4]),
                  (x = g[1]),
                  (b = g[2]);
                break;
              case "z":
              case "Z":
                (y = f), (_ = v), m.closePath();
                break;
            }
        },
        _render: function (m) {
          this._renderPathCommands(m), this._renderPaintInOrder(m);
        },
        toString: function () {
          return (
            "#<fabric.Path (" +
            this.complexity() +
            '): { "top": ' +
            this.top +
            ', "left": ' +
            this.left +
            " }>"
          );
        },
        toObject: function (m) {
          return l(this.callSuper("toObject", m), {
            path: this.path.map(function (g) {
              return g.slice();
            }),
          });
        },
        toDatalessObject: function (m) {
          var g = this.toObject(["sourcePath"].concat(m));
          return g.sourcePath && delete g.path, g;
        },
        _toSVG: function () {
          var m = s.util.joinPath(this.path);
          return [
            "<path ",
            "COMMON_PARTS",
            'd="',
            m,
            '" stroke-linecap="round" ',
            `/>
`,
          ];
        },
        _getOffsetTransform: function () {
          var m = s.Object.NUM_FRACTION_DIGITS;
          return (
            " translate(" +
            h(-this.pathOffset.x, m) +
            ", " +
            h(-this.pathOffset.y, m) +
            ")"
          );
        },
        toClipPathSVG: function (m) {
          var g = this._getOffsetTransform();
          return (
            "	" +
            this._createBaseClipPathSVGMarkup(this._toSVG(), {
              reviver: m,
              additionalTransform: g,
            })
          );
        },
        toSVG: function (m) {
          var g = this._getOffsetTransform();
          return this._createBaseSVGMarkup(this._toSVG(), {
            reviver: m,
            additionalTransform: g,
          });
        },
        complexity: function () {
          return this.path.length;
        },
        _calcDimensions: function () {
          for (
            var m = [],
              g = [],
              f,
              v = 0,
              y = 0,
              _ = 0,
              x = 0,
              b,
              S = 0,
              T = this.path.length;
            S < T;
            ++S
          ) {
            switch (((f = this.path[S]), f[0])) {
              case "L":
                (_ = f[1]), (x = f[2]), (b = []);
                break;
              case "M":
                (_ = f[1]), (x = f[2]), (v = _), (y = x), (b = []);
                break;
              case "C":
                (b = s.util.getBoundsOfCurve(
                  _,
                  x,
                  f[1],
                  f[2],
                  f[3],
                  f[4],
                  f[5],
                  f[6]
                )),
                  (_ = f[5]),
                  (x = f[6]);
                break;
              case "Q":
                (b = s.util.getBoundsOfCurve(
                  _,
                  x,
                  f[1],
                  f[2],
                  f[1],
                  f[2],
                  f[3],
                  f[4]
                )),
                  (_ = f[3]),
                  (x = f[4]);
                break;
              case "z":
              case "Z":
                (_ = v), (x = y);
                break;
            }
            b.forEach(function (B) {
              m.push(B.x), g.push(B.y);
            }),
              m.push(_),
              g.push(x);
          }
          var w = u(m) || 0,
            P = u(g) || 0,
            F = d(m) || 0,
            V = d(g) || 0,
            J = F - w,
            z = V - P;
          return { left: w, top: P, width: J, height: z };
        },
      })),
        (s.Path.fromObject = function (m, g) {
          if (typeof m.sourcePath == "string") {
            var f = m.sourcePath;
            s.loadSVGFromURL(f, function (v) {
              var y = v[0];
              y.setOptions(m),
                m.clipPath
                  ? s.util.enlivenObjects([m.clipPath], function (_) {
                      (y.clipPath = _[0]), g && g(y);
                    })
                  : g && g(y);
            });
          } else s.Object._fromObject("Path", m, g, "path");
        }),
        (s.Path.ATTRIBUTE_NAMES = s.SHARED_ATTRIBUTES.concat(["d"])),
        (s.Path.fromElement = function (m, g, f) {
          var v = s.parseAttributes(m, s.Path.ATTRIBUTE_NAMES);
          (v.fromSVG = !0), g(new s.Path(v.d, l(v, f)));
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.array.min,
        d = s.util.array.max;
      s.Group ||
        ((s.Group = s.util.createClass(s.Object, s.Collection, {
          type: "group",
          strokeWidth: 0,
          subTargetCheck: !1,
          cacheProperties: [],
          useSetOnGroup: !1,
          initialize: function (l, c, h) {
            (c = c || {}),
              (this._objects = []),
              h && this.callSuper("initialize", c),
              (this._objects = l || []);
            for (var m = this._objects.length; m--; )
              this._objects[m].group = this;
            if (h) this._updateObjectsACoords();
            else {
              var g = c && c.centerPoint;
              c.originX !== void 0 && (this.originX = c.originX),
                c.originY !== void 0 && (this.originY = c.originY),
                g || this._calcBounds(),
                this._updateObjectsCoords(g),
                delete c.centerPoint,
                this.callSuper("initialize", c);
            }
            this.setCoords();
          },
          _updateObjectsACoords: function () {
            for (var l = !0, c = this._objects.length; c--; )
              this._objects[c].setCoords(l);
          },
          _updateObjectsCoords: function (c) {
            for (
              var c = c || this.getCenterPoint(), h = this._objects.length;
              h--;

            )
              this._updateObjectCoords(this._objects[h], c);
          },
          _updateObjectCoords: function (l, c) {
            var h = l.left,
              m = l.top,
              g = !0;
            l.set({ left: h - c.x, top: m - c.y }),
              (l.group = this),
              l.setCoords(g);
          },
          toString: function () {
            return "#<fabric.Group: (" + this.complexity() + ")>";
          },
          addWithUpdate: function (l) {
            var c = !!this.group;
            return (
              this._restoreObjectsState(),
              s.util.resetObjectTransform(this),
              l &&
                (c &&
                  s.util.removeTransformFromObject(
                    l,
                    this.group.calcTransformMatrix()
                  ),
                this._objects.push(l),
                (l.group = this),
                l._set("canvas", this.canvas)),
              this._calcBounds(),
              this._updateObjectsCoords(),
              (this.dirty = !0),
              c ? this.group.addWithUpdate() : this.setCoords(),
              this
            );
          },
          removeWithUpdate: function (l) {
            return (
              this._restoreObjectsState(),
              s.util.resetObjectTransform(this),
              this.remove(l),
              this._calcBounds(),
              this._updateObjectsCoords(),
              this.setCoords(),
              (this.dirty = !0),
              this
            );
          },
          _onObjectAdded: function (l) {
            (this.dirty = !0), (l.group = this), l._set("canvas", this.canvas);
          },
          _onObjectRemoved: function (l) {
            (this.dirty = !0), delete l.group;
          },
          _set: function (l, c) {
            var h = this._objects.length;
            if (this.useSetOnGroup)
              for (; h--; ) this._objects[h].setOnGroup(l, c);
            if (l === "canvas") for (; h--; ) this._objects[h]._set(l, c);
            s.Object.prototype._set.call(this, l, c);
          },
          toObject: function (l) {
            var c = this.includeDefaultValues,
              h = this._objects
                .filter(function (g) {
                  return !g.excludeFromExport;
                })
                .map(function (g) {
                  var f = g.includeDefaultValues;
                  g.includeDefaultValues = c;
                  var v = g.toObject(l);
                  return (g.includeDefaultValues = f), v;
                }),
              m = s.Object.prototype.toObject.call(this, l);
            return (m.objects = h), m;
          },
          toDatalessObject: function (l) {
            var c,
              h = this.sourcePath;
            if (h) c = h;
            else {
              var m = this.includeDefaultValues;
              c = this._objects.map(function (f) {
                var v = f.includeDefaultValues;
                f.includeDefaultValues = m;
                var y = f.toDatalessObject(l);
                return (f.includeDefaultValues = v), y;
              });
            }
            var g = s.Object.prototype.toDatalessObject.call(this, l);
            return (g.objects = c), g;
          },
          render: function (l) {
            (this._transformDone = !0),
              this.callSuper("render", l),
              (this._transformDone = !1);
          },
          shouldCache: function () {
            var l = s.Object.prototype.shouldCache.call(this);
            if (l) {
              for (var c = 0, h = this._objects.length; c < h; c++)
                if (this._objects[c].willDrawShadow())
                  return (this.ownCaching = !1), !1;
            }
            return l;
          },
          willDrawShadow: function () {
            if (s.Object.prototype.willDrawShadow.call(this)) return !0;
            for (var l = 0, c = this._objects.length; l < c; l++)
              if (this._objects[l].willDrawShadow()) return !0;
            return !1;
          },
          isOnACache: function () {
            return this.ownCaching || (this.group && this.group.isOnACache());
          },
          drawObject: function (l) {
            for (var c = 0, h = this._objects.length; c < h; c++)
              this._objects[c].render(l);
            this._drawClipPath(l, this.clipPath);
          },
          isCacheDirty: function (l) {
            if (this.callSuper("isCacheDirty", l)) return !0;
            if (!this.statefullCache) return !1;
            for (var c = 0, h = this._objects.length; c < h; c++)
              if (this._objects[c].isCacheDirty(!0)) {
                if (this._cacheCanvas) {
                  var m = this.cacheWidth / this.zoomX,
                    g = this.cacheHeight / this.zoomY;
                  this._cacheContext.clearRect(-m / 2, -g / 2, m, g);
                }
                return !0;
              }
            return !1;
          },
          _restoreObjectsState: function () {
            var l = this.calcOwnMatrix();
            return (
              this._objects.forEach(function (c) {
                s.util.addTransformToObject(c, l),
                  delete c.group,
                  c.setCoords();
              }),
              this
            );
          },
          destroy: function () {
            return (
              this._objects.forEach(function (l) {
                l.set("dirty", !0);
              }),
              this._restoreObjectsState()
            );
          },
          dispose: function () {
            this.callSuper("dispose"),
              this.forEachObject(function (l) {
                l.dispose && l.dispose();
              }),
              (this._objects = []);
          },
          toActiveSelection: function () {
            if (this.canvas) {
              var l = this._objects,
                c = this.canvas;
              this._objects = [];
              var h = this.toObject();
              delete h.objects;
              var m = new s.ActiveSelection([]);
              return (
                m.set(h),
                (m.type = "activeSelection"),
                c.remove(this),
                l.forEach(function (g) {
                  (g.group = m), (g.dirty = !0), c.add(g);
                }),
                (m.canvas = c),
                (m._objects = l),
                (c._activeObject = m),
                m.setCoords(),
                m
              );
            }
          },
          ungroupOnCanvas: function () {
            return this._restoreObjectsState();
          },
          setObjectsCoords: function () {
            var l = !0;
            return (
              this.forEachObject(function (c) {
                c.setCoords(l);
              }),
              this
            );
          },
          _calcBounds: function (l) {
            for (
              var c = [],
                h = [],
                m,
                g,
                f,
                v = ["tr", "br", "bl", "tl"],
                y = 0,
                _ = this._objects.length,
                x,
                b = v.length;
              y < _;
              ++y
            ) {
              for (m = this._objects[y], f = m.calcACoords(), x = 0; x < b; x++)
                (g = v[x]), c.push(f[g].x), h.push(f[g].y);
              m.aCoords = f;
            }
            this._getBounds(c, h, l);
          },
          _getBounds: function (l, c, h) {
            var m = new s.Point(u(l), u(c)),
              g = new s.Point(d(l), d(c)),
              f = m.y || 0,
              v = m.x || 0,
              y = g.x - m.x || 0,
              _ = g.y - m.y || 0;
            (this.width = y),
              (this.height = _),
              h || this.setPositionByOrigin({ x: v, y: f }, "left", "top");
          },
          _toSVG: function (l) {
            for (
              var c = [
                  "<g ",
                  "COMMON_PARTS",
                  ` >
`,
                ],
                h = 0,
                m = this._objects.length;
              h < m;
              h++
            )
              c.push("		", this._objects[h].toSVG(l));
            return (
              c.push(`</g>
`),
              c
            );
          },
          getSvgStyles: function () {
            var l =
                typeof this.opacity < "u" && this.opacity !== 1
                  ? "opacity: " + this.opacity + ";"
                  : "",
              c = this.visible ? "" : " visibility: hidden;";
            return [l, this.getSvgFilter(), c].join("");
          },
          toClipPathSVG: function (l) {
            for (var c = [], h = 0, m = this._objects.length; h < m; h++)
              c.push("	", this._objects[h].toClipPathSVG(l));
            return this._createBaseClipPathSVGMarkup(c, { reviver: l });
          },
        })),
        (s.Group.fromObject = function (l, c) {
          var h = l.objects,
            m = s.util.object.clone(l, !0);
          if ((delete m.objects, typeof h == "string")) {
            s.loadSVGFromURL(h, function (g) {
              var f = s.util.groupSVGElements(g, l, h),
                v = m.clipPath;
              delete m.clipPath,
                f.set(m),
                v
                  ? s.util.enlivenObjects([v], function (y) {
                      (f.clipPath = y[0]), c && c(f);
                    })
                  : c && c(f);
            });
            return;
          }
          s.util.enlivenObjects(h, function (g) {
            s.util.enlivenObjectEnlivables(l, m, function () {
              c && c(new s.Group(g, m, !0));
            });
          });
        }));
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {});
      s.ActiveSelection ||
        ((s.ActiveSelection = s.util.createClass(s.Group, {
          type: "activeSelection",
          initialize: function (u, d) {
            (d = d || {}), (this._objects = u || []);
            for (var l = this._objects.length; l--; )
              this._objects[l].group = this;
            d.originX && (this.originX = d.originX),
              d.originY && (this.originY = d.originY),
              this._calcBounds(),
              this._updateObjectsCoords(),
              s.Object.prototype.initialize.call(this, d),
              this.setCoords();
          },
          toGroup: function () {
            var u = this._objects.concat();
            this._objects = [];
            var d = s.Object.prototype.toObject.call(this),
              l = new s.Group([]);
            if (
              (delete d.type,
              l.set(d),
              u.forEach(function (h) {
                h.canvas.remove(h), (h.group = l);
              }),
              (l._objects = u),
              !this.canvas)
            )
              return l;
            var c = this.canvas;
            return c.add(l), (c._activeObject = l), l.setCoords(), l;
          },
          onDeselect: function () {
            return this.destroy(), !1;
          },
          toString: function () {
            return "#<fabric.ActiveSelection: (" + this.complexity() + ")>";
          },
          shouldCache: function () {
            return !1;
          },
          isOnACache: function () {
            return !1;
          },
          _renderControls: function (u, d, l) {
            u.save(),
              (u.globalAlpha = this.isMoving
                ? this.borderOpacityWhenMoving
                : 1),
              this.callSuper("_renderControls", u, d),
              (l = l || {}),
              typeof l.hasControls > "u" && (l.hasControls = !1),
              (l.forActiveSelection = !0);
            for (var c = 0, h = this._objects.length; c < h; c++)
              this._objects[c]._renderControls(u, l);
            u.restore();
          },
        })),
        (s.ActiveSelection.fromObject = function (u, d) {
          s.util.enlivenObjects(u.objects, function (l) {
            delete u.objects, d && d(new s.ActiveSelection(l, u, !0));
          });
        }));
    })(n),
    (function (a) {
      var s = e.util.object.extend;
      if ((a.fabric || (a.fabric = {}), a.fabric.Image)) {
        e.warn("fabric.Image is already defined.");
        return;
      }
      (e.Image = e.util.createClass(e.Object, {
        type: "image",
        strokeWidth: 0,
        srcFromAttribute: !1,
        _lastScaleX: 1,
        _lastScaleY: 1,
        _filterScalingX: 1,
        _filterScalingY: 1,
        minimumScaleTrigger: 0.5,
        stateProperties: e.Object.prototype.stateProperties.concat(
          "cropX",
          "cropY"
        ),
        cacheProperties: e.Object.prototype.cacheProperties.concat(
          "cropX",
          "cropY"
        ),
        cacheKey: "",
        cropX: 0,
        cropY: 0,
        imageSmoothing: !0,
        initialize: function (u, d) {
          d || (d = {}),
            (this.filters = []),
            (this.cacheKey = "texture" + e.Object.__uid++),
            this.callSuper("initialize", d),
            this._initElement(u, d);
        },
        getElement: function () {
          return this._element || {};
        },
        setElement: function (u, d) {
          return (
            this.removeTexture(this.cacheKey),
            this.removeTexture(this.cacheKey + "_filtered"),
            (this._element = u),
            (this._originalElement = u),
            this._initConfig(d),
            this.filters.length !== 0 && this.applyFilters(),
            this.resizeFilter && this.applyResizeFilters(),
            this
          );
        },
        removeTexture: function (u) {
          var d = e.filterBackend;
          d && d.evictCachesForKey && d.evictCachesForKey(u);
        },
        dispose: function () {
          this.callSuper("dispose"),
            this.removeTexture(this.cacheKey),
            this.removeTexture(this.cacheKey + "_filtered"),
            (this._cacheContext = void 0),
            [
              "_originalElement",
              "_element",
              "_filteredEl",
              "_cacheCanvas",
            ].forEach(
              function (u) {
                e.util.cleanUpJsdomNode(this[u]), (this[u] = void 0);
              }.bind(this)
            );
        },
        getCrossOrigin: function () {
          return (
            this._originalElement && (this._originalElement.crossOrigin || null)
          );
        },
        getOriginalSize: function () {
          var u = this.getElement();
          return {
            width: u.naturalWidth || u.width,
            height: u.naturalHeight || u.height,
          };
        },
        _stroke: function (u) {
          if (!(!this.stroke || this.strokeWidth === 0)) {
            var d = this.width / 2,
              l = this.height / 2;
            u.beginPath(),
              u.moveTo(-d, -l),
              u.lineTo(d, -l),
              u.lineTo(d, l),
              u.lineTo(-d, l),
              u.lineTo(-d, -l),
              u.closePath();
          }
        },
        toObject: function (u) {
          var d = [];
          this.filters.forEach(function (c) {
            c && d.push(c.toObject());
          });
          var l = s(this.callSuper("toObject", ["cropX", "cropY"].concat(u)), {
            src: this.getSrc(),
            crossOrigin: this.getCrossOrigin(),
            filters: d,
          });
          return (
            this.resizeFilter &&
              (l.resizeFilter = this.resizeFilter.toObject()),
            l
          );
        },
        hasCrop: function () {
          return (
            this.cropX ||
            this.cropY ||
            this.width < this._element.width ||
            this.height < this._element.height
          );
        },
        _toSVG: function () {
          var u = [],
            d = [],
            l,
            c = this._element,
            h = -this.width / 2,
            m = -this.height / 2,
            g = "",
            f = "";
          if (!c) return [];
          if (this.hasCrop()) {
            var v = e.Object.__uid++;
            u.push(
              '<clipPath id="imageCrop_' +
                v +
                `">
`,
              '	<rect x="' +
                h +
                '" y="' +
                m +
                '" width="' +
                this.width +
                '" height="' +
                this.height +
                `" />
`,
              `</clipPath>
`
            ),
              (g = ' clip-path="url(#imageCrop_' + v + ')" ');
          }
          if (
            (this.imageSmoothing || (f = '" image-rendering="optimizeSpeed'),
            d.push(
              "	<image ",
              "COMMON_PARTS",
              'xlink:href="',
              this.getSvgSrc(!0),
              '" x="',
              h - this.cropX,
              '" y="',
              m - this.cropY,
              '" width="',
              c.width || c.naturalWidth,
              '" height="',
              c.height || c.height,
              f,
              '"',
              g,
              `></image>
`
            ),
            this.stroke || this.strokeDashArray)
          ) {
            var y = this.fill;
            (this.fill = null),
              (l = [
                "	<rect ",
                'x="',
                h,
                '" y="',
                m,
                '" width="',
                this.width,
                '" height="',
                this.height,
                '" style="',
                this.getSvgStyles(),
                `"/>
`,
              ]),
              (this.fill = y);
          }
          return (
            this.paintFirst !== "fill"
              ? (u = u.concat(l, d))
              : (u = u.concat(d, l)),
            u
          );
        },
        getSrc: function (u) {
          var d = u ? this._element : this._originalElement;
          return d
            ? d.toDataURL
              ? d.toDataURL()
              : this.srcFromAttribute
              ? d.getAttribute("src")
              : d.src
            : this.src || "";
        },
        setSrc: function (u, d, l) {
          return (
            e.util.loadImage(
              u,
              function (c, h) {
                this.setElement(c, l), this._setWidthHeight(), d && d(this, h);
              },
              this,
              l && l.crossOrigin
            ),
            this
          );
        },
        toString: function () {
          return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
        },
        applyResizeFilters: function () {
          var u = this.resizeFilter,
            d = this.minimumScaleTrigger,
            l = this.getTotalObjectScaling(),
            c = l.scaleX,
            h = l.scaleY,
            m = this._filteredEl || this._originalElement;
          if ((this.group && this.set("dirty", !0), !u || (c > d && h > d))) {
            (this._element = m),
              (this._filterScalingX = 1),
              (this._filterScalingY = 1),
              (this._lastScaleX = c),
              (this._lastScaleY = h);
            return;
          }
          e.filterBackend || (e.filterBackend = e.initFilterBackend());
          var g = e.util.createCanvasElement(),
            f = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey,
            v = m.width,
            y = m.height;
          (g.width = v),
            (g.height = y),
            (this._element = g),
            (this._lastScaleX = u.scaleX = c),
            (this._lastScaleY = u.scaleY = h),
            e.filterBackend.applyFilters([u], m, v, y, this._element, f),
            (this._filterScalingX = g.width / this._originalElement.width),
            (this._filterScalingY = g.height / this._originalElement.height);
        },
        applyFilters: function (u) {
          if (
            ((u = u || this.filters || []),
            (u = u.filter(function (m) {
              return m && !m.isNeutralState();
            })),
            this.set("dirty", !0),
            this.removeTexture(this.cacheKey + "_filtered"),
            u.length === 0)
          )
            return (
              (this._element = this._originalElement),
              (this._filteredEl = null),
              (this._filterScalingX = 1),
              (this._filterScalingY = 1),
              this
            );
          var d = this._originalElement,
            l = d.naturalWidth || d.width,
            c = d.naturalHeight || d.height;
          if (this._element === this._originalElement) {
            var h = e.util.createCanvasElement();
            (h.width = l),
              (h.height = c),
              (this._element = h),
              (this._filteredEl = h);
          } else
            (this._element = this._filteredEl),
              this._filteredEl.getContext("2d").clearRect(0, 0, l, c),
              (this._lastScaleX = 1),
              (this._lastScaleY = 1);
          return (
            e.filterBackend || (e.filterBackend = e.initFilterBackend()),
            e.filterBackend.applyFilters(
              u,
              this._originalElement,
              l,
              c,
              this._element,
              this.cacheKey
            ),
            (this._originalElement.width !== this._element.width ||
              this._originalElement.height !== this._element.height) &&
              ((this._filterScalingX =
                this._element.width / this._originalElement.width),
              (this._filterScalingY =
                this._element.height / this._originalElement.height)),
            this
          );
        },
        _render: function (u) {
          e.util.setImageSmoothing(u, this.imageSmoothing),
            this.isMoving !== !0 &&
              this.resizeFilter &&
              this._needsResize() &&
              this.applyResizeFilters(),
            this._stroke(u),
            this._renderPaintInOrder(u);
        },
        drawCacheOnCanvas: function (u) {
          e.util.setImageSmoothing(u, this.imageSmoothing),
            e.Object.prototype.drawCacheOnCanvas.call(this, u);
        },
        shouldCache: function () {
          return this.needsItsOwnCache();
        },
        _renderFill: function (u) {
          var d = this._element;
          if (d) {
            var l = this._filterScalingX,
              c = this._filterScalingY,
              h = this.width,
              m = this.height,
              g = Math.min,
              f = Math.max,
              v = f(this.cropX, 0),
              y = f(this.cropY, 0),
              _ = d.naturalWidth || d.width,
              x = d.naturalHeight || d.height,
              b = v * l,
              S = y * c,
              T = g(h * l, _ - b),
              w = g(m * c, x - S),
              P = -h / 2,
              F = -m / 2,
              V = g(h, _ / l - v),
              J = g(m, x / c - y);
            d && u.drawImage(d, b, S, T, w, P, F, V, J);
          }
        },
        _needsResize: function () {
          var u = this.getTotalObjectScaling();
          return u.scaleX !== this._lastScaleX || u.scaleY !== this._lastScaleY;
        },
        _resetWidthHeight: function () {
          this.set(this.getOriginalSize());
        },
        _initElement: function (u, d) {
          this.setElement(e.util.getById(u), d),
            e.util.addClass(this.getElement(), e.Image.CSS_CANVAS);
        },
        _initConfig: function (u) {
          u || (u = {}), this.setOptions(u), this._setWidthHeight(u);
        },
        _initFilters: function (u, d) {
          u && u.length
            ? e.util.enlivenObjects(
                u,
                function (l) {
                  d && d(l);
                },
                "fabric.Image.filters"
              )
            : d && d();
        },
        _setWidthHeight: function (u) {
          u || (u = {});
          var d = this.getElement();
          (this.width = u.width || d.naturalWidth || d.width || 0),
            (this.height = u.height || d.naturalHeight || d.height || 0);
        },
        parsePreserveAspectRatioAttribute: function () {
          var u = e.util.parsePreserveAspectRatioAttribute(
              this.preserveAspectRatio || ""
            ),
            d = this._element.width,
            l = this._element.height,
            c = 1,
            h = 1,
            m = 0,
            g = 0,
            f = 0,
            v = 0,
            y,
            _ = this.width,
            x = this.height,
            b = { width: _, height: x };
          return (
            u && (u.alignX !== "none" || u.alignY !== "none")
              ? (u.meetOrSlice === "meet" &&
                  ((c = h = e.util.findScaleToFit(this._element, b)),
                  (y = (_ - d * c) / 2),
                  u.alignX === "Min" && (m = -y),
                  u.alignX === "Max" && (m = y),
                  (y = (x - l * h) / 2),
                  u.alignY === "Min" && (g = -y),
                  u.alignY === "Max" && (g = y)),
                u.meetOrSlice === "slice" &&
                  ((c = h = e.util.findScaleToCover(this._element, b)),
                  (y = d - _ / c),
                  u.alignX === "Mid" && (f = y / 2),
                  u.alignX === "Max" && (f = y),
                  (y = l - x / h),
                  u.alignY === "Mid" && (v = y / 2),
                  u.alignY === "Max" && (v = y),
                  (d = _ / c),
                  (l = x / h)))
              : ((c = _ / d), (h = x / l)),
            {
              width: d,
              height: l,
              scaleX: c,
              scaleY: h,
              offsetLeft: m,
              offsetTop: g,
              cropX: f,
              cropY: v,
            }
          );
        },
      })),
        (e.Image.CSS_CANVAS = "canvas-img"),
        (e.Image.prototype.getSvgSrc = e.Image.prototype.getSrc),
        (e.Image.fromObject = function (u, d) {
          var l = e.util.object.clone(u);
          e.util.loadImage(
            l.src,
            function (c, h) {
              if (h) {
                d && d(null, !0);
                return;
              }
              e.Image.prototype._initFilters.call(l, l.filters, function (m) {
                (l.filters = m || []),
                  e.Image.prototype._initFilters.call(
                    l,
                    [l.resizeFilter],
                    function (g) {
                      (l.resizeFilter = g[0]),
                        e.util.enlivenObjectEnlivables(l, l, function () {
                          var f = new e.Image(c, l);
                          d(f, !1);
                        });
                    }
                  );
              });
            },
            null,
            l.crossOrigin
          );
        }),
        (e.Image.fromURL = function (u, d, l) {
          e.util.loadImage(
            u,
            function (c, h) {
              d && d(new e.Image(c, l), h);
            },
            null,
            l && l.crossOrigin
          );
        }),
        (e.Image.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(
          "x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(
            " "
          )
        )),
        (e.Image.fromElement = function (u, d, l) {
          var c = e.parseAttributes(u, e.Image.ATTRIBUTE_NAMES);
          e.Image.fromURL(
            c["xlink:href"],
            d,
            s(l ? e.util.object.clone(l) : {}, c)
          );
        });
    })(n),
    e.util.object.extend(e.Object.prototype, {
      _getAngleValueForStraighten: function () {
        var a = this.angle % 360;
        return a > 0 ? Math.round((a - 1) / 90) * 90 : Math.round(a / 90) * 90;
      },
      straighten: function () {
        return this.rotate(this._getAngleValueForStraighten());
      },
      fxStraighten: function (a) {
        a = a || {};
        var s = function () {},
          u = a.onComplete || s,
          d = a.onChange || s,
          l = this;
        return e.util.animate({
          target: this,
          startValue: this.get("angle"),
          endValue: this._getAngleValueForStraighten(),
          duration: this.FX_DURATION,
          onChange: function (c) {
            l.rotate(c), d();
          },
          onComplete: function () {
            l.setCoords(), u();
          },
        });
      },
    }),
    e.util.object.extend(e.StaticCanvas.prototype, {
      straightenObject: function (a) {
        return a.straighten(), this.requestRenderAll(), this;
      },
      fxStraightenObject: function (a) {
        return a.fxStraighten({ onChange: this.requestRenderAllBound });
      },
    }),
    (function () {
      function a(u, d) {
        var l =
            "precision " +
            d +
            ` float;
void main(){}`,
          c = u.createShader(u.FRAGMENT_SHADER);
        return (
          u.shaderSource(c, l),
          u.compileShader(c),
          !!u.getShaderParameter(c, u.COMPILE_STATUS)
        );
      }
      (e.isWebglSupported = function (u) {
        if (e.isLikelyNode) return !1;
        u = u || e.WebglFilterBackend.prototype.tileSize;
        var d = document.createElement("canvas"),
          l = d.getContext("webgl") || d.getContext("experimental-webgl"),
          c = !1;
        if (l) {
          (e.maxTextureSize = l.getParameter(l.MAX_TEXTURE_SIZE)),
            (c = e.maxTextureSize >= u);
          for (var h = ["highp", "mediump", "lowp"], m = 0; m < 3; m++)
            if (a(l, h[m])) {
              e.webGlPrecision = h[m];
              break;
            }
        }
        return (this.isSupported = c), c;
      }),
        (e.WebglFilterBackend = s);
      function s(u) {
        u && u.tileSize && (this.tileSize = u.tileSize),
          this.setupGLContext(this.tileSize, this.tileSize),
          this.captureGPUInfo();
      }
      s.prototype = {
        tileSize: 2048,
        resources: {},
        setupGLContext: function (u, d) {
          this.dispose(),
            this.createWebGLCanvas(u, d),
            (this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])),
            this.chooseFastestCopyGLTo2DMethod(u, d);
        },
        chooseFastestCopyGLTo2DMethod: function (u, d) {
          var l = typeof window.performance < "u",
            c;
          try {
            new ImageData(1, 1), (c = !0);
          } catch {
            c = !1;
          }
          var h = typeof ArrayBuffer < "u",
            m = typeof Uint8ClampedArray < "u";
          if (l && c && h && m) {
            var g = e.util.createCanvasElement(),
              f = new ArrayBuffer(u * d * 4);
            if (e.forceGLPutImageData) {
              (this.imageBuffer = f), (this.copyGLTo2D = p);
              return;
            }
            var v = {
                imageBuffer: f,
                destinationWidth: u,
                destinationHeight: d,
                targetCanvas: g,
              },
              y,
              _,
              x;
            (g.width = u),
              (g.height = d),
              (y = window.performance.now()),
              o.call(v, this.gl, v),
              (_ = window.performance.now() - y),
              (y = window.performance.now()),
              p.call(v, this.gl, v),
              (x = window.performance.now() - y),
              _ > x
                ? ((this.imageBuffer = f), (this.copyGLTo2D = p))
                : (this.copyGLTo2D = o);
          }
        },
        createWebGLCanvas: function (u, d) {
          var l = e.util.createCanvasElement();
          (l.width = u), (l.height = d);
          var c = {
              alpha: !0,
              premultipliedAlpha: !1,
              depth: !1,
              stencil: !1,
              antialias: !1,
            },
            h = l.getContext("webgl", c);
          h || (h = l.getContext("experimental-webgl", c)),
            h && (h.clearColor(0, 0, 0, 0), (this.canvas = l), (this.gl = h));
        },
        applyFilters: function (u, d, l, c, h, m) {
          var g = this.gl,
            f;
          m && (f = this.getCachedTexture(m, d));
          var v = {
              originalWidth: d.width || d.originalWidth,
              originalHeight: d.height || d.originalHeight,
              sourceWidth: l,
              sourceHeight: c,
              destinationWidth: l,
              destinationHeight: c,
              context: g,
              sourceTexture: this.createTexture(g, l, c, !f && d),
              targetTexture: this.createTexture(g, l, c),
              originalTexture: f || this.createTexture(g, l, c, !f && d),
              passes: u.length,
              webgl: !0,
              aPosition: this.aPosition,
              programCache: this.programCache,
              pass: 0,
              filterBackend: this,
              targetCanvas: h,
            },
            y = g.createFramebuffer();
          return (
            g.bindFramebuffer(g.FRAMEBUFFER, y),
            u.forEach(function (_) {
              _ && _.applyTo(v);
            }),
            r(v),
            this.copyGLTo2D(g, v),
            g.bindTexture(g.TEXTURE_2D, null),
            g.deleteTexture(v.sourceTexture),
            g.deleteTexture(v.targetTexture),
            g.deleteFramebuffer(y),
            h.getContext("2d").setTransform(1, 0, 0, 1, 0, 0),
            v
          );
        },
        dispose: function () {
          this.canvas && ((this.canvas = null), (this.gl = null)),
            this.clearWebGLCaches();
        },
        clearWebGLCaches: function () {
          (this.programCache = {}), (this.textureCache = {});
        },
        createTexture: function (u, d, l, c, h) {
          var m = u.createTexture();
          return (
            u.bindTexture(u.TEXTURE_2D, m),
            u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, h || u.NEAREST),
            u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, h || u.NEAREST),
            u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE),
            u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE),
            c
              ? u.texImage2D(
                  u.TEXTURE_2D,
                  0,
                  u.RGBA,
                  u.RGBA,
                  u.UNSIGNED_BYTE,
                  c
                )
              : u.texImage2D(
                  u.TEXTURE_2D,
                  0,
                  u.RGBA,
                  d,
                  l,
                  0,
                  u.RGBA,
                  u.UNSIGNED_BYTE,
                  null
                ),
            m
          );
        },
        getCachedTexture: function (u, d) {
          if (this.textureCache[u]) return this.textureCache[u];
          var l = this.createTexture(this.gl, d.width, d.height, d);
          return (this.textureCache[u] = l), l;
        },
        evictCachesForKey: function (u) {
          this.textureCache[u] &&
            (this.gl.deleteTexture(this.textureCache[u]),
            delete this.textureCache[u]);
        },
        copyGLTo2D: o,
        captureGPUInfo: function () {
          if (this.gpuInfo) return this.gpuInfo;
          var u = this.gl,
            d = { renderer: "", vendor: "" };
          if (!u) return d;
          var l = u.getExtension("WEBGL_debug_renderer_info");
          if (l) {
            var c = u.getParameter(l.UNMASKED_RENDERER_WEBGL),
              h = u.getParameter(l.UNMASKED_VENDOR_WEBGL);
            c && (d.renderer = c.toLowerCase()),
              h && (d.vendor = h.toLowerCase());
          }
          return (this.gpuInfo = d), d;
        },
      };
    })();
  function r(a) {
    var s = a.targetCanvas,
      u = s.width,
      d = s.height,
      l = a.destinationWidth,
      c = a.destinationHeight;
    (u !== l || d !== c) && ((s.width = l), (s.height = c));
  }
  function o(a, s) {
    var u = a.canvas,
      d = s.targetCanvas,
      l = d.getContext("2d");
    l.translate(0, d.height), l.scale(1, -1);
    var c = u.height - d.height;
    l.drawImage(u, 0, c, d.width, d.height, 0, 0, d.width, d.height);
  }
  function p(a, s) {
    var u = s.targetCanvas,
      d = u.getContext("2d"),
      l = s.destinationWidth,
      c = s.destinationHeight,
      h = l * c * 4,
      m = new Uint8Array(this.imageBuffer, 0, h),
      g = new Uint8ClampedArray(this.imageBuffer, 0, h);
    a.readPixels(0, 0, l, c, a.RGBA, a.UNSIGNED_BYTE, m);
    var f = new ImageData(g, l, c);
    d.putImageData(f, 0, 0);
  }
  (function () {
    var a = function () {};
    e.Canvas2dFilterBackend = s;
    function s() {}
    s.prototype = {
      evictCachesForKey: a,
      dispose: a,
      clearWebGLCaches: a,
      resources: {},
      applyFilters: function (u, d, l, c, h) {
        var m = h.getContext("2d");
        m.drawImage(d, 0, 0, l, c);
        var g = m.getImageData(0, 0, l, c),
          f = m.getImageData(0, 0, l, c),
          v = {
            sourceWidth: l,
            sourceHeight: c,
            imageData: g,
            originalEl: d,
            originalImageData: f,
            canvasEl: h,
            ctx: m,
            filterBackend: this,
          };
        return (
          u.forEach(function (y) {
            y.applyTo(v);
          }),
          (v.imageData.width !== l || v.imageData.height !== c) &&
            ((h.width = v.imageData.width), (h.height = v.imageData.height)),
          m.putImageData(v.imageData, 0, 0),
          v
        );
      },
    };
  })(),
    (e.Image = e.Image || {}),
    (e.Image.filters = e.Image.filters || {}),
    (e.Image.filters.BaseFilter = e.util.createClass({
      type: "BaseFilter",
      vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
void main() {
vTexCoord = aPosition;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`,
      fragmentSource: `precision highp float;
varying vec2 vTexCoord;
uniform sampler2D uTexture;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
}`,
      initialize: function (a) {
        a && this.setOptions(a);
      },
      setOptions: function (a) {
        for (var s in a) this[s] = a[s];
      },
      createProgram: function (a, s, u) {
        (s = s || this.fragmentSource),
          (u = u || this.vertexSource),
          e.webGlPrecision !== "highp" &&
            (s = s.replace(
              /precision highp float/g,
              "precision " + e.webGlPrecision + " float"
            ));
        var d = a.createShader(a.VERTEX_SHADER);
        if (
          (a.shaderSource(d, u),
          a.compileShader(d),
          !a.getShaderParameter(d, a.COMPILE_STATUS))
        )
          throw new Error(
            "Vertex shader compile error for " +
              this.type +
              ": " +
              a.getShaderInfoLog(d)
          );
        var l = a.createShader(a.FRAGMENT_SHADER);
        if (
          (a.shaderSource(l, s),
          a.compileShader(l),
          !a.getShaderParameter(l, a.COMPILE_STATUS))
        )
          throw new Error(
            "Fragment shader compile error for " +
              this.type +
              ": " +
              a.getShaderInfoLog(l)
          );
        var c = a.createProgram();
        if (
          (a.attachShader(c, d),
          a.attachShader(c, l),
          a.linkProgram(c),
          !a.getProgramParameter(c, a.LINK_STATUS))
        )
          throw new Error(
            'Shader link error for "${this.type}" ' + a.getProgramInfoLog(c)
          );
        var h = this.getAttributeLocations(a, c),
          m = this.getUniformLocations(a, c) || {};
        return (
          (m.uStepW = a.getUniformLocation(c, "uStepW")),
          (m.uStepH = a.getUniformLocation(c, "uStepH")),
          { program: c, attributeLocations: h, uniformLocations: m }
        );
      },
      getAttributeLocations: function (a, s) {
        return { aPosition: a.getAttribLocation(s, "aPosition") };
      },
      getUniformLocations: function () {
        return {};
      },
      sendAttributeData: function (a, s, u) {
        var d = s.aPosition,
          l = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, l),
          a.enableVertexAttribArray(d),
          a.vertexAttribPointer(d, 2, a.FLOAT, !1, 0, 0),
          a.bufferData(a.ARRAY_BUFFER, u, a.STATIC_DRAW);
      },
      _setupFrameBuffer: function (a) {
        var s = a.context,
          u,
          d;
        a.passes > 1
          ? ((u = a.destinationWidth),
            (d = a.destinationHeight),
            (a.sourceWidth !== u || a.sourceHeight !== d) &&
              (s.deleteTexture(a.targetTexture),
              (a.targetTexture = a.filterBackend.createTexture(s, u, d))),
            s.framebufferTexture2D(
              s.FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              s.TEXTURE_2D,
              a.targetTexture,
              0
            ))
          : (s.bindFramebuffer(s.FRAMEBUFFER, null), s.finish());
      },
      _swapTextures: function (a) {
        a.passes--, a.pass++;
        var s = a.targetTexture;
        (a.targetTexture = a.sourceTexture), (a.sourceTexture = s);
      },
      isNeutralState: function () {
        var a = this.mainParameter,
          s = e.Image.filters[this.type].prototype;
        if (a)
          if (Array.isArray(s[a])) {
            for (var u = s[a].length; u--; )
              if (this[a][u] !== s[a][u]) return !1;
            return !0;
          } else return s[a] === this[a];
        else return !1;
      },
      applyTo: function (a) {
        a.webgl
          ? (this._setupFrameBuffer(a),
            this.applyToWebGL(a),
            this._swapTextures(a))
          : this.applyTo2d(a);
      },
      retrieveShader: function (a) {
        return (
          a.programCache.hasOwnProperty(this.type) ||
            (a.programCache[this.type] = this.createProgram(a.context)),
          a.programCache[this.type]
        );
      },
      applyToWebGL: function (a) {
        var s = a.context,
          u = this.retrieveShader(a);
        a.pass === 0 && a.originalTexture
          ? s.bindTexture(s.TEXTURE_2D, a.originalTexture)
          : s.bindTexture(s.TEXTURE_2D, a.sourceTexture),
          s.useProgram(u.program),
          this.sendAttributeData(s, u.attributeLocations, a.aPosition),
          s.uniform1f(u.uniformLocations.uStepW, 1 / a.sourceWidth),
          s.uniform1f(u.uniformLocations.uStepH, 1 / a.sourceHeight),
          this.sendUniformData(s, u.uniformLocations),
          s.viewport(0, 0, a.destinationWidth, a.destinationHeight),
          s.drawArrays(s.TRIANGLE_STRIP, 0, 4);
      },
      bindAdditionalTexture: function (a, s, u) {
        a.activeTexture(u),
          a.bindTexture(a.TEXTURE_2D, s),
          a.activeTexture(a.TEXTURE0);
      },
      unbindAdditionalTexture: function (a, s) {
        a.activeTexture(s),
          a.bindTexture(a.TEXTURE_2D, null),
          a.activeTexture(a.TEXTURE0);
      },
      getMainParameter: function () {
        return this[this.mainParameter];
      },
      setMainParameter: function (a) {
        this[this.mainParameter] = a;
      },
      sendUniformData: function () {},
      createHelpLayer: function (a) {
        if (!a.helpLayer) {
          var s = document.createElement("canvas");
          (s.width = a.sourceWidth),
            (s.height = a.sourceHeight),
            (a.helpLayer = s);
        }
      },
      toObject: function () {
        var a = { type: this.type },
          s = this.mainParameter;
        return s && (a[s] = this[s]), a;
      },
      toJSON: function () {
        return this.toObject();
      },
    })),
    (e.Image.filters.BaseFilter.fromObject = function (a, s) {
      var u = new e.Image.filters[a.type](a);
      return s && s(u), u;
    }),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.ColorMatrix = d(u.BaseFilter, {
        type: "ColorMatrix",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
uniform mat4 uColorMatrix;
uniform vec4 uConstants;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color *= uColorMatrix;
color += uConstants;
gl_FragColor = color;
}`,
        matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
        mainParameter: "matrix",
        colorsOnly: !0,
        initialize: function (l) {
          this.callSuper("initialize", l), (this.matrix = this.matrix.slice(0));
        },
        applyTo2d: function (l) {
          var c = l.imageData,
            h = c.data,
            m = h.length,
            g = this.matrix,
            f,
            v,
            y,
            _,
            x,
            b = this.colorsOnly;
          for (x = 0; x < m; x += 4)
            (f = h[x]),
              (v = h[x + 1]),
              (y = h[x + 2]),
              b
                ? ((h[x] = f * g[0] + v * g[1] + y * g[2] + g[4] * 255),
                  (h[x + 1] = f * g[5] + v * g[6] + y * g[7] + g[9] * 255),
                  (h[x + 2] = f * g[10] + v * g[11] + y * g[12] + g[14] * 255))
                : ((_ = h[x + 3]),
                  (h[x] =
                    f * g[0] + v * g[1] + y * g[2] + _ * g[3] + g[4] * 255),
                  (h[x + 1] =
                    f * g[5] + v * g[6] + y * g[7] + _ * g[8] + g[9] * 255),
                  (h[x + 2] =
                    f * g[10] +
                    v * g[11] +
                    y * g[12] +
                    _ * g[13] +
                    g[14] * 255),
                  (h[x + 3] =
                    f * g[15] +
                    v * g[16] +
                    y * g[17] +
                    _ * g[18] +
                    g[19] * 255));
        },
        getUniformLocations: function (l, c) {
          return {
            uColorMatrix: l.getUniformLocation(c, "uColorMatrix"),
            uConstants: l.getUniformLocation(c, "uConstants"),
          };
        },
        sendUniformData: function (l, c) {
          var h = this.matrix,
            m = [
              h[0],
              h[1],
              h[2],
              h[3],
              h[5],
              h[6],
              h[7],
              h[8],
              h[10],
              h[11],
              h[12],
              h[13],
              h[15],
              h[16],
              h[17],
              h[18],
            ],
            g = [h[4], h[9], h[14], h[19]];
          l.uniformMatrix4fv(c.uColorMatrix, !1, m),
            l.uniform4fv(c.uConstants, g);
        },
      })),
        (s.Image.filters.ColorMatrix.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Brightness = d(u.BaseFilter, {
        type: "Brightness",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBrightness;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += uBrightness;
gl_FragColor = color;
}`,
        brightness: 0,
        mainParameter: "brightness",
        applyTo2d: function (l) {
          if (this.brightness !== 0) {
            var c = l.imageData,
              h = c.data,
              m,
              g = h.length,
              f = Math.round(this.brightness * 255);
            for (m = 0; m < g; m += 4)
              (h[m] = h[m] + f),
                (h[m + 1] = h[m + 1] + f),
                (h[m + 2] = h[m + 2] + f);
          }
        },
        getUniformLocations: function (l, c) {
          return { uBrightness: l.getUniformLocation(c, "uBrightness") };
        },
        sendUniformData: function (l, c) {
          l.uniform1f(c.uBrightness, this.brightness);
        },
      })),
        (s.Image.filters.Brightness.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.extend,
        d = s.Image.filters,
        l = s.util.createClass;
      (d.Convolute = l(d.BaseFilter, {
        type: "Convolute",
        opaque: !1,
        matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],
        fragmentSource: {
          Convolute_3_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
}
}
gl_FragColor = color;
}`,
          Convolute_3_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[9];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 3.0; h+=1.0) {
for (float w = 0.0; w < 3.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`,
          Convolute_5_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
}
}
gl_FragColor = color;
}`,
          Convolute_5_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[25];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 5.0; h+=1.0) {
for (float w = 0.0; w < 5.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`,
          Convolute_7_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
}
}
gl_FragColor = color;
}`,
          Convolute_7_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[49];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 7.0; h+=1.0) {
for (float w = 0.0; w < 7.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`,
          Convolute_9_1: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 0);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
}
}
gl_FragColor = color;
}`,
          Convolute_9_0: `precision highp float;
uniform sampler2D uTexture;
uniform float uMatrix[81];
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
vec4 color = vec4(0, 0, 0, 1);
for (float h = 0.0; h < 9.0; h+=1.0) {
for (float w = 0.0; w < 9.0; w+=1.0) {
vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
}
}
float alpha = texture2D(uTexture, vTexCoord).a;
gl_FragColor = color;
gl_FragColor.a = alpha;
}`,
        },
        retrieveShader: function (c) {
          var h = Math.sqrt(this.matrix.length),
            m = this.type + "_" + h + "_" + (this.opaque ? 1 : 0),
            g = this.fragmentSource[m];
          return (
            c.programCache.hasOwnProperty(m) ||
              (c.programCache[m] = this.createProgram(c.context, g)),
            c.programCache[m]
          );
        },
        applyTo2d: function (c) {
          var h = c.imageData,
            m = h.data,
            g = this.matrix,
            f = Math.round(Math.sqrt(g.length)),
            v = Math.floor(f / 2),
            y = h.width,
            _ = h.height,
            x = c.ctx.createImageData(y, _),
            b = x.data,
            S = this.opaque ? 1 : 0,
            T,
            w,
            P,
            F,
            V,
            J,
            z,
            B,
            G,
            ie,
            re,
            j,
            C;
          for (re = 0; re < _; re++)
            for (ie = 0; ie < y; ie++) {
              for (
                V = (re * y + ie) * 4, T = 0, w = 0, P = 0, F = 0, C = 0;
                C < f;
                C++
              )
                for (j = 0; j < f; j++)
                  (z = re + C - v),
                    (J = ie + j - v),
                    !(z < 0 || z >= _ || J < 0 || J >= y) &&
                      ((B = (z * y + J) * 4),
                      (G = g[C * f + j]),
                      (T += m[B] * G),
                      (w += m[B + 1] * G),
                      (P += m[B + 2] * G),
                      S || (F += m[B + 3] * G));
              (b[V] = T),
                (b[V + 1] = w),
                (b[V + 2] = P),
                S ? (b[V + 3] = m[V + 3]) : (b[V + 3] = F);
            }
          c.imageData = x;
        },
        getUniformLocations: function (c, h) {
          return {
            uMatrix: c.getUniformLocation(h, "uMatrix"),
            uOpaque: c.getUniformLocation(h, "uOpaque"),
            uHalfSize: c.getUniformLocation(h, "uHalfSize"),
            uSize: c.getUniformLocation(h, "uSize"),
          };
        },
        sendUniformData: function (c, h) {
          c.uniform1fv(h.uMatrix, this.matrix);
        },
        toObject: function () {
          return u(this.callSuper("toObject"), {
            opaque: this.opaque,
            matrix: this.matrix,
          });
        },
      })),
        (s.Image.filters.Convolute.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Grayscale = d(u.BaseFilter, {
        type: "Grayscale",
        fragmentSource: {
          average: `precision highp float;
uniform sampler2D uTexture;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float average = (color.r + color.b + color.g) / 3.0;
gl_FragColor = vec4(average, average, average, color.a);
}`,
          lightness: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
gl_FragColor = vec4(average, average, average, col.a);
}`,
          luminosity: `precision highp float;
uniform sampler2D uTexture;
uniform int uMode;
varying vec2 vTexCoord;
void main() {
vec4 col = texture2D(uTexture, vTexCoord);
float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
gl_FragColor = vec4(average, average, average, col.a);
}`,
        },
        mode: "average",
        mainParameter: "mode",
        applyTo2d: function (l) {
          var c = l.imageData,
            h = c.data,
            m,
            g = h.length,
            f,
            v = this.mode;
          for (m = 0; m < g; m += 4)
            v === "average"
              ? (f = (h[m] + h[m + 1] + h[m + 2]) / 3)
              : v === "lightness"
              ? (f =
                  (Math.min(h[m], h[m + 1], h[m + 2]) +
                    Math.max(h[m], h[m + 1], h[m + 2])) /
                  2)
              : v === "luminosity" &&
                (f = 0.21 * h[m] + 0.72 * h[m + 1] + 0.07 * h[m + 2]),
              (h[m] = f),
              (h[m + 1] = f),
              (h[m + 2] = f);
        },
        retrieveShader: function (l) {
          var c = this.type + "_" + this.mode;
          if (!l.programCache.hasOwnProperty(c)) {
            var h = this.fragmentSource[this.mode];
            l.programCache[c] = this.createProgram(l.context, h);
          }
          return l.programCache[c];
        },
        getUniformLocations: function (l, c) {
          return { uMode: l.getUniformLocation(c, "uMode") };
        },
        sendUniformData: function (l, c) {
          var h = 1;
          l.uniform1i(c.uMode, h);
        },
        isNeutralState: function () {
          return !1;
        },
      })),
        (s.Image.filters.Grayscale.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Invert = d(u.BaseFilter, {
        type: "Invert",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform int uInvert;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
if (uInvert == 1) {
gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
} else {
gl_FragColor = color;
}
}`,
        invert: !0,
        mainParameter: "invert",
        applyTo2d: function (l) {
          var c = l.imageData,
            h = c.data,
            m,
            g = h.length;
          for (m = 0; m < g; m += 4)
            (h[m] = 255 - h[m]),
              (h[m + 1] = 255 - h[m + 1]),
              (h[m + 2] = 255 - h[m + 2]);
        },
        isNeutralState: function () {
          return !this.invert;
        },
        getUniformLocations: function (l, c) {
          return { uInvert: l.getUniformLocation(c, "uInvert") };
        },
        sendUniformData: function (l, c) {
          l.uniform1i(c.uInvert, this.invert);
        },
      })),
        (s.Image.filters.Invert.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.extend,
        d = s.Image.filters,
        l = s.util.createClass;
      (d.Noise = l(d.BaseFilter, {
        type: "Noise",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uStepH;
uniform float uNoise;
uniform float uSeed;
varying vec2 vTexCoord;
float rand(vec2 co, float seed, float vScale) {
return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
}
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
gl_FragColor = color;
}`,
        mainParameter: "noise",
        noise: 0,
        applyTo2d: function (c) {
          if (this.noise !== 0) {
            var h = c.imageData,
              m = h.data,
              g,
              f = m.length,
              v = this.noise,
              y;
            for (g = 0, f = m.length; g < f; g += 4)
              (y = (0.5 - Math.random()) * v),
                (m[g] += y),
                (m[g + 1] += y),
                (m[g + 2] += y);
          }
        },
        getUniformLocations: function (c, h) {
          return {
            uNoise: c.getUniformLocation(h, "uNoise"),
            uSeed: c.getUniformLocation(h, "uSeed"),
          };
        },
        sendUniformData: function (c, h) {
          c.uniform1f(h.uNoise, this.noise / 255),
            c.uniform1f(h.uSeed, Math.random());
        },
        toObject: function () {
          return u(this.callSuper("toObject"), { noise: this.noise });
        },
      })),
        (s.Image.filters.Noise.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Pixelate = d(u.BaseFilter, {
        type: "Pixelate",
        blocksize: 4,
        mainParameter: "blocksize",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uBlocksize;
uniform float uStepW;
uniform float uStepH;
varying vec2 vTexCoord;
void main() {
float blockW = uBlocksize * uStepW;
float blockH = uBlocksize * uStepW;
int posX = int(vTexCoord.x / blockW);
int posY = int(vTexCoord.y / blockH);
float fposX = float(posX);
float fposY = float(posY);
vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
vec4 color = texture2D(uTexture, squareCoords);
gl_FragColor = color;
}`,
        applyTo2d: function (l) {
          var c = l.imageData,
            h = c.data,
            m = c.height,
            g = c.width,
            f,
            v,
            y,
            _,
            x,
            b,
            S,
            T,
            w,
            P,
            F;
          for (v = 0; v < m; v += this.blocksize)
            for (y = 0; y < g; y += this.blocksize)
              for (
                f = v * 4 * g + y * 4,
                  _ = h[f],
                  x = h[f + 1],
                  b = h[f + 2],
                  S = h[f + 3],
                  P = Math.min(v + this.blocksize, m),
                  F = Math.min(y + this.blocksize, g),
                  T = v;
                T < P;
                T++
              )
                for (w = y; w < F; w++)
                  (f = T * 4 * g + w * 4),
                    (h[f] = _),
                    (h[f + 1] = x),
                    (h[f + 2] = b),
                    (h[f + 3] = S);
        },
        isNeutralState: function () {
          return this.blocksize === 1;
        },
        getUniformLocations: function (l, c) {
          return {
            uBlocksize: l.getUniformLocation(c, "uBlocksize"),
            uStepW: l.getUniformLocation(c, "uStepW"),
            uStepH: l.getUniformLocation(c, "uStepH"),
          };
        },
        sendUniformData: function (l, c) {
          l.uniform1f(c.uBlocksize, this.blocksize);
        },
      })),
        (s.Image.filters.Pixelate.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.extend,
        d = s.Image.filters,
        l = s.util.createClass;
      (d.RemoveColor = l(d.BaseFilter, {
        type: "RemoveColor",
        color: "#FFFFFF",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
gl_FragColor = texture2D(uTexture, vTexCoord);
if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
gl_FragColor.a = 0.0;
}
}`,
        distance: 0.02,
        useAlpha: !1,
        applyTo2d: function (c) {
          var h = c.imageData,
            m = h.data,
            g,
            f = this.distance * 255,
            v,
            y,
            _,
            x = new s.Color(this.color).getSource(),
            b = [x[0] - f, x[1] - f, x[2] - f],
            S = [x[0] + f, x[1] + f, x[2] + f];
          for (g = 0; g < m.length; g += 4)
            (v = m[g]),
              (y = m[g + 1]),
              (_ = m[g + 2]),
              v > b[0] &&
                y > b[1] &&
                _ > b[2] &&
                v < S[0] &&
                y < S[1] &&
                _ < S[2] &&
                (m[g + 3] = 0);
        },
        getUniformLocations: function (c, h) {
          return {
            uLow: c.getUniformLocation(h, "uLow"),
            uHigh: c.getUniformLocation(h, "uHigh"),
          };
        },
        sendUniformData: function (c, h) {
          var m = new s.Color(this.color).getSource(),
            g = parseFloat(this.distance),
            f = [0 + m[0] / 255 - g, 0 + m[1] / 255 - g, 0 + m[2] / 255 - g, 1],
            v = [m[0] / 255 + g, m[1] / 255 + g, m[2] / 255 + g, 1];
          c.uniform4fv(h.uLow, f), c.uniform4fv(h.uHigh, v);
        },
        toObject: function () {
          return u(this.callSuper("toObject"), {
            color: this.color,
            distance: this.distance,
          });
        },
      })),
        (s.Image.filters.RemoveColor.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass,
        l = {
          Brownie: [
            0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0,
            -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0,
          ],
          Vintage: [
            0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259,
            0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0,
          ],
          Kodachrome: [
            1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352,
            -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0,
            0, 1, 0,
          ],
          Technicolor: [
            1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589,
            -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0,
            0, 1, 0,
          ],
          Polaroid: [
            1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016,
            -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0,
          ],
          Sepia: [
            0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534,
            0.131, 0, 0, 0, 0, 0, 1, 0,
          ],
          BlackWhite: [
            1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0,
            0, 0, 1, 0,
          ],
        };
      for (var c in l)
        (u[c] = d(u.ColorMatrix, {
          type: c,
          matrix: l[c],
          mainParameter: !1,
          colorsOnly: !0,
        })),
          (s.Image.filters[c].fromObject =
            s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric,
        u = s.Image.filters,
        d = s.util.createClass;
      (u.BlendColor = d(u.BaseFilter, {
        type: "BlendColor",
        color: "#F95C63",
        mode: "multiply",
        alpha: 1,
        fragmentSource: {
          multiply: `gl_FragColor.rgb *= uColor.rgb;
`,
          screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`,
          add: `gl_FragColor.rgb += uColor.rgb;
`,
          diff: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`,
          subtract: `gl_FragColor.rgb -= uColor.rgb;
`,
          lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`,
          darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`,
          exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`,
          overlay: `if (uColor.r < 0.5) {
gl_FragColor.r *= 2.0 * uColor.r;
} else {
gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
}
if (uColor.g < 0.5) {
gl_FragColor.g *= 2.0 * uColor.g;
} else {
gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
}
if (uColor.b < 0.5) {
gl_FragColor.b *= 2.0 * uColor.b;
} else {
gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
}
`,
          tint: `gl_FragColor.rgb *= (1.0 - uColor.a);
gl_FragColor.rgb += uColor.rgb;
`,
        },
        buildSource: function (l) {
          return (
            `precision highp float;
uniform sampler2D uTexture;
uniform vec4 uColor;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
gl_FragColor = color;
if (color.a > 0.0) {
` +
            this.fragmentSource[l] +
            `}
}`
          );
        },
        retrieveShader: function (l) {
          var c = this.type + "_" + this.mode,
            h;
          return (
            l.programCache.hasOwnProperty(c) ||
              ((h = this.buildSource(this.mode)),
              (l.programCache[c] = this.createProgram(l.context, h))),
            l.programCache[c]
          );
        },
        applyTo2d: function (l) {
          var c = l.imageData,
            h = c.data,
            m = h.length,
            g,
            f,
            v,
            y,
            _,
            x,
            b,
            S = 1 - this.alpha;
          (b = new s.Color(this.color).getSource()),
            (g = b[0] * this.alpha),
            (f = b[1] * this.alpha),
            (v = b[2] * this.alpha);
          for (var T = 0; T < m; T += 4)
            switch (((y = h[T]), (_ = h[T + 1]), (x = h[T + 2]), this.mode)) {
              case "multiply":
                (h[T] = (y * g) / 255),
                  (h[T + 1] = (_ * f) / 255),
                  (h[T + 2] = (x * v) / 255);
                break;
              case "screen":
                (h[T] = 255 - ((255 - y) * (255 - g)) / 255),
                  (h[T + 1] = 255 - ((255 - _) * (255 - f)) / 255),
                  (h[T + 2] = 255 - ((255 - x) * (255 - v)) / 255);
                break;
              case "add":
                (h[T] = y + g), (h[T + 1] = _ + f), (h[T + 2] = x + v);
                break;
              case "diff":
              case "difference":
                (h[T] = Math.abs(y - g)),
                  (h[T + 1] = Math.abs(_ - f)),
                  (h[T + 2] = Math.abs(x - v));
                break;
              case "subtract":
                (h[T] = y - g), (h[T + 1] = _ - f), (h[T + 2] = x - v);
                break;
              case "darken":
                (h[T] = Math.min(y, g)),
                  (h[T + 1] = Math.min(_, f)),
                  (h[T + 2] = Math.min(x, v));
                break;
              case "lighten":
                (h[T] = Math.max(y, g)),
                  (h[T + 1] = Math.max(_, f)),
                  (h[T + 2] = Math.max(x, v));
                break;
              case "overlay":
                (h[T] =
                  g < 128
                    ? (2 * y * g) / 255
                    : 255 - (2 * (255 - y) * (255 - g)) / 255),
                  (h[T + 1] =
                    f < 128
                      ? (2 * _ * f) / 255
                      : 255 - (2 * (255 - _) * (255 - f)) / 255),
                  (h[T + 2] =
                    v < 128
                      ? (2 * x * v) / 255
                      : 255 - (2 * (255 - x) * (255 - v)) / 255);
                break;
              case "exclusion":
                (h[T] = g + y - (2 * g * y) / 255),
                  (h[T + 1] = f + _ - (2 * f * _) / 255),
                  (h[T + 2] = v + x - (2 * v * x) / 255);
                break;
              case "tint":
                (h[T] = g + y * S),
                  (h[T + 1] = f + _ * S),
                  (h[T + 2] = v + x * S);
            }
        },
        getUniformLocations: function (l, c) {
          return { uColor: l.getUniformLocation(c, "uColor") };
        },
        sendUniformData: function (l, c) {
          var h = new s.Color(this.color).getSource();
          (h[0] = (this.alpha * h[0]) / 255),
            (h[1] = (this.alpha * h[1]) / 255),
            (h[2] = (this.alpha * h[2]) / 255),
            (h[3] = this.alpha),
            l.uniform4fv(c.uColor, h);
        },
        toObject: function () {
          return {
            type: this.type,
            color: this.color,
            mode: this.mode,
            alpha: this.alpha,
          };
        },
      })),
        (s.Image.filters.BlendColor.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric,
        u = s.Image.filters,
        d = s.util.createClass;
      (u.BlendImage = d(u.BaseFilter, {
        type: "BlendImage",
        image: null,
        mode: "multiply",
        alpha: 1,
        vertexSource: `attribute vec2 aPosition;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
uniform mat3 uTransformMatrix;
void main() {
vTexCoord = aPosition;
vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
}`,
        fragmentSource: {
          multiply: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.rgba *= color2.rgba;
gl_FragColor = color;
}`,
          mask: `precision highp float;
uniform sampler2D uTexture;
uniform sampler2D uImage;
uniform vec4 uColor;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec4 color2 = texture2D(uImage, vTexCoord2);
color.a = color2.a;
gl_FragColor = color;
}`,
        },
        retrieveShader: function (l) {
          var c = this.type + "_" + this.mode,
            h = this.fragmentSource[this.mode];
          return (
            l.programCache.hasOwnProperty(c) ||
              (l.programCache[c] = this.createProgram(l.context, h)),
            l.programCache[c]
          );
        },
        applyToWebGL: function (l) {
          var c = l.context,
            h = this.createTexture(l.filterBackend, this.image);
          this.bindAdditionalTexture(c, h, c.TEXTURE1),
            this.callSuper("applyToWebGL", l),
            this.unbindAdditionalTexture(c, c.TEXTURE1);
        },
        createTexture: function (l, c) {
          return l.getCachedTexture(c.cacheKey, c._element);
        },
        calculateMatrix: function () {
          var l = this.image,
            c = l._element.width,
            h = l._element.height;
          return [
            1 / l.scaleX,
            0,
            0,
            0,
            1 / l.scaleY,
            0,
            -l.left / c,
            -l.top / h,
            1,
          ];
        },
        applyTo2d: function (l) {
          var c = l.imageData,
            h = l.filterBackend.resources,
            m = c.data,
            g = m.length,
            f = c.width,
            v = c.height,
            y,
            _,
            x,
            b,
            S,
            T,
            w,
            P,
            F,
            V,
            J = this.image,
            z;
          h.blendImage || (h.blendImage = s.util.createCanvasElement()),
            (F = h.blendImage),
            (V = F.getContext("2d")),
            F.width !== f || F.height !== v
              ? ((F.width = f), (F.height = v))
              : V.clearRect(0, 0, f, v),
            V.setTransform(J.scaleX, 0, 0, J.scaleY, J.left, J.top),
            V.drawImage(J._element, 0, 0, f, v),
            (z = V.getImageData(0, 0, f, v).data);
          for (var B = 0; B < g; B += 4)
            switch (
              ((S = m[B]),
              (T = m[B + 1]),
              (w = m[B + 2]),
              (P = m[B + 3]),
              (y = z[B]),
              (_ = z[B + 1]),
              (x = z[B + 2]),
              (b = z[B + 3]),
              this.mode)
            ) {
              case "multiply":
                (m[B] = (S * y) / 255),
                  (m[B + 1] = (T * _) / 255),
                  (m[B + 2] = (w * x) / 255),
                  (m[B + 3] = (P * b) / 255);
                break;
              case "mask":
                m[B + 3] = b;
                break;
            }
        },
        getUniformLocations: function (l, c) {
          return {
            uTransformMatrix: l.getUniformLocation(c, "uTransformMatrix"),
            uImage: l.getUniformLocation(c, "uImage"),
          };
        },
        sendUniformData: function (l, c) {
          var h = this.calculateMatrix();
          l.uniform1i(c.uImage, 1),
            l.uniformMatrix3fv(c.uTransformMatrix, !1, h);
        },
        toObject: function () {
          return {
            type: this.type,
            image: this.image && this.image.toObject(),
            mode: this.mode,
            alpha: this.alpha,
          };
        },
      })),
        (s.Image.filters.BlendImage.fromObject = function (l, c) {
          s.Image.fromObject(l.image, function (h) {
            var m = s.util.object.clone(l);
            (m.image = h), c(new s.Image.filters.BlendImage(m));
          });
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = Math.pow,
        d = Math.floor,
        l = Math.sqrt,
        c = Math.abs,
        h = Math.round,
        m = Math.sin,
        g = Math.ceil,
        f = s.Image.filters,
        v = s.util.createClass;
      (f.Resize = v(f.BaseFilter, {
        type: "Resize",
        resizeType: "hermite",
        scaleX: 1,
        scaleY: 1,
        lanczosLobes: 3,
        getUniformLocations: function (y, _) {
          return {
            uDelta: y.getUniformLocation(_, "uDelta"),
            uTaps: y.getUniformLocation(_, "uTaps"),
          };
        },
        sendUniformData: function (y, _) {
          y.uniform2fv(
            _.uDelta,
            this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]
          ),
            y.uniform1fv(_.uTaps, this.taps);
        },
        retrieveShader: function (y) {
          var _ = this.getFilterWindow(),
            x = this.type + "_" + _;
          if (!y.programCache.hasOwnProperty(x)) {
            var b = this.generateShader(_);
            y.programCache[x] = this.createProgram(y.context, b);
          }
          return y.programCache[x];
        },
        getFilterWindow: function () {
          var y = this.tempScale;
          return Math.ceil(this.lanczosLobes / y);
        },
        getTaps: function () {
          for (
            var y = this.lanczosCreate(this.lanczosLobes),
              _ = this.tempScale,
              x = this.getFilterWindow(),
              b = new Array(x),
              S = 1;
            S <= x;
            S++
          )
            b[S - 1] = y(S * _);
          return b;
        },
        generateShader: function (b) {
          for (
            var _ = new Array(b), x = this.fragmentSourceTOP, b, S = 1;
            S <= b;
            S++
          )
            _[S - 1] = S + ".0 * uDelta";
          return (
            (x +=
              "uniform float uTaps[" +
              b +
              `];
`),
            (x += `void main() {
`),
            (x += `  vec4 color = texture2D(uTexture, vTexCoord);
`),
            (x += `  float sum = 1.0;
`),
            _.forEach(function (T, w) {
              (x +=
                "  color += texture2D(uTexture, vTexCoord + " +
                T +
                ") * uTaps[" +
                w +
                `];
`),
                (x +=
                  "  color += texture2D(uTexture, vTexCoord - " +
                  T +
                  ") * uTaps[" +
                  w +
                  `];
`),
                (x +=
                  "  sum += 2.0 * uTaps[" +
                  w +
                  `];
`);
            }),
            (x += `  gl_FragColor = color / sum;
`),
            (x += "}"),
            x
          );
        },
        fragmentSourceTOP: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
`,
        applyTo: function (y) {
          y.webgl
            ? (y.passes++,
              (this.width = y.sourceWidth),
              (this.horizontal = !0),
              (this.dW = Math.round(this.width * this.scaleX)),
              (this.dH = y.sourceHeight),
              (this.tempScale = this.dW / this.width),
              (this.taps = this.getTaps()),
              (y.destinationWidth = this.dW),
              this._setupFrameBuffer(y),
              this.applyToWebGL(y),
              this._swapTextures(y),
              (y.sourceWidth = y.destinationWidth),
              (this.height = y.sourceHeight),
              (this.horizontal = !1),
              (this.dH = Math.round(this.height * this.scaleY)),
              (this.tempScale = this.dH / this.height),
              (this.taps = this.getTaps()),
              (y.destinationHeight = this.dH),
              this._setupFrameBuffer(y),
              this.applyToWebGL(y),
              this._swapTextures(y),
              (y.sourceHeight = y.destinationHeight))
            : this.applyTo2d(y);
        },
        isNeutralState: function () {
          return this.scaleX === 1 && this.scaleY === 1;
        },
        lanczosCreate: function (y) {
          return function (_) {
            if (_ >= y || _ <= -y) return 0;
            if (_ < 11920929e-14 && _ > -11920929e-14) return 1;
            _ *= Math.PI;
            var x = _ / y;
            return ((m(_) / _) * m(x)) / x;
          };
        },
        applyTo2d: function (y) {
          var _ = y.imageData,
            x = this.scaleX,
            b = this.scaleY;
          (this.rcpScaleX = 1 / x), (this.rcpScaleY = 1 / b);
          var S = _.width,
            T = _.height,
            w = h(S * x),
            P = h(T * b),
            F;
          this.resizeType === "sliceHack"
            ? (F = this.sliceByTwo(y, S, T, w, P))
            : this.resizeType === "hermite"
            ? (F = this.hermiteFastResize(y, S, T, w, P))
            : this.resizeType === "bilinear"
            ? (F = this.bilinearFiltering(y, S, T, w, P))
            : this.resizeType === "lanczos" &&
              (F = this.lanczosResize(y, S, T, w, P)),
            (y.imageData = F);
        },
        sliceByTwo: function (y, _, x, b, S) {
          var T = y.imageData,
            w = 0.5,
            P = !1,
            F = !1,
            V = _ * w,
            J = x * w,
            z = s.filterBackend.resources,
            B,
            G,
            ie = 0,
            re = 0,
            j = _,
            C = 0;
          for (
            z.sliceByTwo || (z.sliceByTwo = document.createElement("canvas")),
              B = z.sliceByTwo,
              (B.width < _ * 1.5 || B.height < x) &&
                ((B.width = _ * 1.5), (B.height = x)),
              G = B.getContext("2d"),
              G.clearRect(0, 0, _ * 1.5, x),
              G.putImageData(T, 0, 0),
              b = d(b),
              S = d(S);
            !P || !F;

          )
            (_ = V),
              (x = J),
              b < d(V * w) ? (V = d(V * w)) : ((V = b), (P = !0)),
              S < d(J * w) ? (J = d(J * w)) : ((J = S), (F = !0)),
              G.drawImage(B, ie, re, _, x, j, C, V, J),
              (ie = j),
              (re = C),
              (C += J);
          return G.getImageData(ie, re, b, S);
        },
        lanczosResize: function (y, _, x, b, S) {
          function T(A) {
            var O, H, I, E, k, $, Y, X, ee, he, pe;
            for (C.x = (A + 0.5) * J, R.x = d(C.x), O = 0; O < S; O++) {
              for (
                C.y = (O + 0.5) * z,
                  R.y = d(C.y),
                  k = 0,
                  $ = 0,
                  Y = 0,
                  X = 0,
                  ee = 0,
                  H = R.x - ie;
                H <= R.x + ie;
                H++
              )
                if (!(H < 0 || H >= _)) {
                  (he = d(1e3 * c(H - C.x))), j[he] || (j[he] = {});
                  for (var Z = R.y - re; Z <= R.y + re; Z++)
                    Z < 0 ||
                      Z >= x ||
                      ((pe = d(1e3 * c(Z - C.y))),
                      j[he][pe] ||
                        (j[he][pe] = V(l(u(he * B, 2) + u(pe * G, 2)) / 1e3)),
                      (I = j[he][pe]),
                      I > 0 &&
                        ((E = (Z * _ + H) * 4),
                        (k += I),
                        ($ += I * w[E]),
                        (Y += I * w[E + 1]),
                        (X += I * w[E + 2]),
                        (ee += I * w[E + 3])));
                }
              (E = (O * b + A) * 4),
                (F[E] = $ / k),
                (F[E + 1] = Y / k),
                (F[E + 2] = X / k),
                (F[E + 3] = ee / k);
            }
            return ++A < b ? T(A) : P;
          }
          var w = y.imageData.data,
            P = y.ctx.createImageData(b, S),
            F = P.data,
            V = this.lanczosCreate(this.lanczosLobes),
            J = this.rcpScaleX,
            z = this.rcpScaleY,
            B = 2 / this.rcpScaleX,
            G = 2 / this.rcpScaleY,
            ie = g((J * this.lanczosLobes) / 2),
            re = g((z * this.lanczosLobes) / 2),
            j = {},
            C = {},
            R = {};
          return T(0);
        },
        bilinearFiltering: function (y, _, x, b, S) {
          var T,
            w,
            P,
            F,
            V,
            J,
            z,
            B,
            G,
            ie,
            re,
            j,
            C = 0,
            R,
            A = this.rcpScaleX,
            O = this.rcpScaleY,
            H = 4 * (_ - 1),
            I = y.imageData,
            E = I.data,
            k = y.ctx.createImageData(b, S),
            $ = k.data;
          for (z = 0; z < S; z++)
            for (B = 0; B < b; B++)
              for (
                V = d(A * B),
                  J = d(O * z),
                  G = A * B - V,
                  ie = O * z - J,
                  R = 4 * (J * _ + V),
                  re = 0;
                re < 4;
                re++
              )
                (T = E[R + re]),
                  (w = E[R + 4 + re]),
                  (P = E[R + H + re]),
                  (F = E[R + H + 4 + re]),
                  (j =
                    T * (1 - G) * (1 - ie) +
                    w * G * (1 - ie) +
                    P * ie * (1 - G) +
                    F * G * ie),
                  ($[C++] = j);
          return k;
        },
        hermiteFastResize: function (y, _, x, b, S) {
          for (
            var T = this.rcpScaleX,
              w = this.rcpScaleY,
              P = g(T / 2),
              F = g(w / 2),
              V = y.imageData,
              J = V.data,
              z = y.ctx.createImageData(b, S),
              B = z.data,
              G = 0;
            G < S;
            G++
          )
            for (var ie = 0; ie < b; ie++) {
              for (
                var re = (ie + G * b) * 4,
                  j = 0,
                  C = 0,
                  R = 0,
                  A = 0,
                  O = 0,
                  H = 0,
                  I = 0,
                  E = (G + 0.5) * w,
                  k = d(G * w);
                k < (G + 1) * w;
                k++
              )
                for (
                  var $ = c(E - (k + 0.5)) / F,
                    Y = (ie + 0.5) * T,
                    X = $ * $,
                    ee = d(ie * T);
                  ee < (ie + 1) * T;
                  ee++
                ) {
                  var he = c(Y - (ee + 0.5)) / P,
                    pe = l(X + he * he);
                  (pe > 1 && pe < -1) ||
                    ((j = 2 * pe * pe * pe - 3 * pe * pe + 1),
                    j > 0 &&
                      ((he = 4 * (ee + k * _)),
                      (I += j * J[he + 3]),
                      (R += j),
                      J[he + 3] < 255 && (j = (j * J[he + 3]) / 250),
                      (A += j * J[he]),
                      (O += j * J[he + 1]),
                      (H += j * J[he + 2]),
                      (C += j)));
                }
              (B[re] = A / C),
                (B[re + 1] = O / C),
                (B[re + 2] = H / C),
                (B[re + 3] = I / R);
            }
          return z;
        },
        toObject: function () {
          return {
            type: this.type,
            scaleX: this.scaleX,
            scaleY: this.scaleY,
            resizeType: this.resizeType,
            lanczosLobes: this.lanczosLobes,
          };
        },
      })),
        (s.Image.filters.Resize.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Contrast = d(u.BaseFilter, {
        type: "Contrast",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uContrast;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
gl_FragColor = color;
}`,
        contrast: 0,
        mainParameter: "contrast",
        applyTo2d: function (l) {
          if (this.contrast !== 0) {
            var c = l.imageData,
              h,
              g,
              m = c.data,
              g = m.length,
              f = Math.floor(this.contrast * 255),
              v = (259 * (f + 255)) / (255 * (259 - f));
            for (h = 0; h < g; h += 4)
              (m[h] = v * (m[h] - 128) + 128),
                (m[h + 1] = v * (m[h + 1] - 128) + 128),
                (m[h + 2] = v * (m[h + 2] - 128) + 128);
          }
        },
        getUniformLocations: function (l, c) {
          return { uContrast: l.getUniformLocation(c, "uContrast") };
        },
        sendUniformData: function (l, c) {
          l.uniform1f(c.uContrast, this.contrast);
        },
      })),
        (s.Image.filters.Contrast.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Saturation = d(u.BaseFilter, {
        type: "Saturation",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uSaturation;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float rgMax = max(color.r, color.g);
float rgbMax = max(rgMax, color.b);
color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
gl_FragColor = color;
}`,
        saturation: 0,
        mainParameter: "saturation",
        applyTo2d: function (l) {
          if (this.saturation !== 0) {
            var c = l.imageData,
              h = c.data,
              m = h.length,
              g = -this.saturation,
              f,
              v;
            for (f = 0; f < m; f += 4)
              (v = Math.max(h[f], h[f + 1], h[f + 2])),
                (h[f] += v !== h[f] ? (v - h[f]) * g : 0),
                (h[f + 1] += v !== h[f + 1] ? (v - h[f + 1]) * g : 0),
                (h[f + 2] += v !== h[f + 2] ? (v - h[f + 2]) * g : 0);
          }
        },
        getUniformLocations: function (l, c) {
          return { uSaturation: l.getUniformLocation(c, "uSaturation") };
        },
        sendUniformData: function (l, c) {
          l.uniform1f(c.uSaturation, -this.saturation);
        },
      })),
        (s.Image.filters.Saturation.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Vibrance = d(u.BaseFilter, {
        type: "Vibrance",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform float uVibrance;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
float max = max(color.r, max(color.g, color.b));
float avg = (color.r + color.g + color.b) / 3.0;
float amt = (abs(max - avg) * 2.0) * uVibrance;
color.r += max != color.r ? (max - color.r) * amt : 0.00;
color.g += max != color.g ? (max - color.g) * amt : 0.00;
color.b += max != color.b ? (max - color.b) * amt : 0.00;
gl_FragColor = color;
}`,
        vibrance: 0,
        mainParameter: "vibrance",
        applyTo2d: function (l) {
          if (this.vibrance !== 0) {
            var c = l.imageData,
              h = c.data,
              m = h.length,
              g = -this.vibrance,
              f,
              v,
              y,
              _;
            for (f = 0; f < m; f += 4)
              (v = Math.max(h[f], h[f + 1], h[f + 2])),
                (y = (h[f] + h[f + 1] + h[f + 2]) / 3),
                (_ = ((Math.abs(v - y) * 2) / 255) * g),
                (h[f] += v !== h[f] ? (v - h[f]) * _ : 0),
                (h[f + 1] += v !== h[f + 1] ? (v - h[f + 1]) * _ : 0),
                (h[f + 2] += v !== h[f + 2] ? (v - h[f + 2]) * _ : 0);
          }
        },
        getUniformLocations: function (l, c) {
          return { uVibrance: l.getUniformLocation(c, "uVibrance") };
        },
        sendUniformData: function (l, c) {
          l.uniform1f(c.uVibrance, -this.vibrance);
        },
      })),
        (s.Image.filters.Vibrance.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Blur = d(u.BaseFilter, {
        type: "Blur",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec2 uDelta;
varying vec2 vTexCoord;
const float nSamples = 15.0;
vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
float random(vec3 scale) {
return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
}
void main() {
vec4 color = vec4(0.0);
float total = 0.0;
float offset = random(v3offset);
for (float t = -nSamples; t <= nSamples; t++) {
float percent = (t + offset - 0.5) / nSamples;
float weight = 1.0 - abs(percent);
color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
total += weight;
}
gl_FragColor = color / total;
}`,
        blur: 0,
        mainParameter: "blur",
        applyTo: function (l) {
          l.webgl
            ? ((this.aspectRatio = l.sourceWidth / l.sourceHeight),
              l.passes++,
              this._setupFrameBuffer(l),
              (this.horizontal = !0),
              this.applyToWebGL(l),
              this._swapTextures(l),
              this._setupFrameBuffer(l),
              (this.horizontal = !1),
              this.applyToWebGL(l),
              this._swapTextures(l))
            : this.applyTo2d(l);
        },
        applyTo2d: function (l) {
          l.imageData = this.simpleBlur(l);
        },
        simpleBlur: function (l) {
          var c = l.filterBackend.resources,
            h,
            m,
            g = l.imageData.width,
            f = l.imageData.height;
          c.blurLayer1 ||
            ((c.blurLayer1 = s.util.createCanvasElement()),
            (c.blurLayer2 = s.util.createCanvasElement())),
            (h = c.blurLayer1),
            (m = c.blurLayer2),
            (h.width !== g || h.height !== f) &&
              ((m.width = h.width = g), (m.height = h.height = f));
          var v = h.getContext("2d"),
            y = m.getContext("2d"),
            _ = 15,
            x,
            b,
            S,
            T,
            w = this.blur * 0.06 * 0.5;
          for (
            v.putImageData(l.imageData, 0, 0), y.clearRect(0, 0, g, f), T = -_;
            T <= _;
            T++
          )
            (x = (Math.random() - 0.5) / 4),
              (b = T / _),
              (S = w * b * g + x),
              (y.globalAlpha = 1 - Math.abs(b)),
              y.drawImage(h, S, x),
              v.drawImage(m, 0, 0),
              (y.globalAlpha = 1),
              y.clearRect(0, 0, m.width, m.height);
          for (T = -_; T <= _; T++)
            (x = (Math.random() - 0.5) / 4),
              (b = T / _),
              (S = w * b * f + x),
              (y.globalAlpha = 1 - Math.abs(b)),
              y.drawImage(h, x, S),
              v.drawImage(m, 0, 0),
              (y.globalAlpha = 1),
              y.clearRect(0, 0, m.width, m.height);
          l.ctx.drawImage(h, 0, 0);
          var P = l.ctx.getImageData(0, 0, h.width, h.height);
          return (v.globalAlpha = 1), v.clearRect(0, 0, h.width, h.height), P;
        },
        getUniformLocations: function (l, c) {
          return { delta: l.getUniformLocation(c, "uDelta") };
        },
        sendUniformData: function (l, c) {
          var h = this.chooseRightDelta();
          l.uniform2fv(c.delta, h);
        },
        chooseRightDelta: function () {
          var l = 1,
            c = [0, 0],
            h;
          return (
            this.horizontal
              ? this.aspectRatio > 1 && (l = 1 / this.aspectRatio)
              : this.aspectRatio < 1 && (l = this.aspectRatio),
            (h = l * this.blur * 0.12),
            this.horizontal ? (c[0] = h) : (c[1] = h),
            c
          );
        },
      })),
        (u.Blur.fromObject = s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Gamma = d(u.BaseFilter, {
        type: "Gamma",
        fragmentSource: `precision highp float;
uniform sampler2D uTexture;
uniform vec3 uGamma;
varying vec2 vTexCoord;
void main() {
vec4 color = texture2D(uTexture, vTexCoord);
vec3 correction = (1.0 / uGamma);
color.r = pow(color.r, correction.r);
color.g = pow(color.g, correction.g);
color.b = pow(color.b, correction.b);
gl_FragColor = color;
gl_FragColor.rgb *= color.a;
}`,
        gamma: [1, 1, 1],
        mainParameter: "gamma",
        initialize: function (l) {
          (this.gamma = [1, 1, 1]),
            u.BaseFilter.prototype.initialize.call(this, l);
        },
        applyTo2d: function (l) {
          var c = l.imageData,
            h = c.data,
            m = this.gamma,
            g = h.length,
            f = 1 / m[0],
            v = 1 / m[1],
            y = 1 / m[2],
            _;
          for (
            this.rVals ||
              ((this.rVals = new Uint8Array(256)),
              (this.gVals = new Uint8Array(256)),
              (this.bVals = new Uint8Array(256))),
              _ = 0,
              g = 256;
            _ < g;
            _++
          )
            (this.rVals[_] = Math.pow(_ / 255, f) * 255),
              (this.gVals[_] = Math.pow(_ / 255, v) * 255),
              (this.bVals[_] = Math.pow(_ / 255, y) * 255);
          for (_ = 0, g = h.length; _ < g; _ += 4)
            (h[_] = this.rVals[h[_]]),
              (h[_ + 1] = this.gVals[h[_ + 1]]),
              (h[_ + 2] = this.bVals[h[_ + 2]]);
        },
        getUniformLocations: function (l, c) {
          return { uGamma: l.getUniformLocation(c, "uGamma") };
        },
        sendUniformData: function (l, c) {
          l.uniform3fv(c.uGamma, this.gamma);
        },
      })),
        (s.Image.filters.Gamma.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.Composed = d(u.BaseFilter, {
        type: "Composed",
        subFilters: [],
        initialize: function (l) {
          this.callSuper("initialize", l),
            (this.subFilters = this.subFilters.slice(0));
        },
        applyTo: function (l) {
          (l.passes += this.subFilters.length - 1),
            this.subFilters.forEach(function (c) {
              c.applyTo(l);
            });
        },
        toObject: function () {
          return s.util.object.extend(this.callSuper("toObject"), {
            subFilters: this.subFilters.map(function (l) {
              return l.toObject();
            }),
          });
        },
        isNeutralState: function () {
          return !this.subFilters.some(function (l) {
            return !l.isNeutralState();
          });
        },
      })),
        (s.Image.filters.Composed.fromObject = function (l, c) {
          var h = l.subFilters || [],
            m = h.map(function (f) {
              return new s.Image.filters[f.type](f);
            }),
            g = new s.Image.filters.Composed({ subFilters: m });
          return c && c(g), g;
        });
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.Image.filters,
        d = s.util.createClass;
      (u.HueRotation = d(u.ColorMatrix, {
        type: "HueRotation",
        rotation: 0,
        mainParameter: "rotation",
        calculateMatrix: function () {
          var l = this.rotation * Math.PI,
            c = s.util.cos(l),
            h = s.util.sin(l),
            m = 1 / 3,
            g = Math.sqrt(m) * h,
            f = 1 - c;
          (this.matrix = [
            1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
          ]),
            (this.matrix[0] = c + f / 3),
            (this.matrix[1] = m * f - g),
            (this.matrix[2] = m * f + g),
            (this.matrix[5] = m * f + g),
            (this.matrix[6] = c + m * f),
            (this.matrix[7] = m * f - g),
            (this.matrix[10] = m * f - g),
            (this.matrix[11] = m * f + g),
            (this.matrix[12] = c + m * f);
        },
        isNeutralState: function (l) {
          return (
            this.calculateMatrix(),
            u.BaseFilter.prototype.isNeutralState.call(this, l)
          );
        },
        applyTo: function (l) {
          this.calculateMatrix(), u.BaseFilter.prototype.applyTo.call(this, l);
        },
      })),
        (s.Image.filters.HueRotation.fromObject =
          s.Image.filters.BaseFilter.fromObject);
    })(n),
    (function (a) {
      var s = a.fabric || (a.fabric = {}),
        u = s.util.object.clone;
      if (s.Text) {
        s.warn("fabric.Text is already defined");
        return;
      }
      var d =
        "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(
          " "
        );
      (s.Text = s.util.createClass(s.Object, {
        _dimensionAffectingProps: [
          "fontSize",
          "fontWeight",
          "fontFamily",
          "fontStyle",
          "lineHeight",
          "text",
          "charSpacing",
          "textAlign",
          "styles",
          "path",
          "pathStartOffset",
          "pathSide",
          "pathAlign",
        ],
        _reNewline: /\r?\n/,
        _reSpacesAndTabs: /[ \t\r]/g,
        _reSpaceAndTab: /[ \t\r]/,
        _reWords: /\S+/g,
        type: "text",
        fontSize: 40,
        fontWeight: "normal",
        fontFamily: "Times New Roman",
        underline: !1,
        overline: !1,
        linethrough: !1,
        textAlign: "left",
        fontStyle: "normal",
        lineHeight: 1.16,
        superscript: { size: 0.6, baseline: -0.35 },
        subscript: { size: 0.6, baseline: 0.11 },
        textBackgroundColor: "",
        stateProperties: s.Object.prototype.stateProperties.concat(d),
        cacheProperties: s.Object.prototype.cacheProperties.concat(d),
        stroke: null,
        shadow: null,
        path: null,
        pathStartOffset: 0,
        pathSide: "left",
        pathAlign: "baseline",
        _fontSizeFraction: 0.222,
        offsets: { underline: 0.1, linethrough: -0.315, overline: -0.88 },
        _fontSizeMult: 1.13,
        charSpacing: 0,
        styles: null,
        _measuringContext: null,
        deltaY: 0,
        direction: "ltr",
        _styleProperties: [
          "stroke",
          "strokeWidth",
          "fill",
          "fontFamily",
          "fontSize",
          "fontWeight",
          "fontStyle",
          "underline",
          "overline",
          "linethrough",
          "deltaY",
          "textBackgroundColor",
        ],
        __charBounds: [],
        CACHE_FONT_SIZE: 400,
        MIN_TEXT_WIDTH: 2,
        initialize: function (l, c) {
          (this.styles = c ? c.styles || {} : {}),
            (this.text = l),
            (this.__skipDimension = !0),
            this.callSuper("initialize", c),
            this.path && this.setPathInfo(),
            (this.__skipDimension = !1),
            this.initDimensions(),
            this.setCoords(),
            this.setupState({ propertySet: "_dimensionAffectingProps" });
        },
        setPathInfo: function () {
          var l = this.path;
          l && (l.segmentsInfo = s.util.getPathSegmentsInfo(l.path));
        },
        getMeasuringContext: function () {
          return (
            s._measuringContext ||
              (s._measuringContext =
                (this.canvas && this.canvas.contextCache) ||
                s.util.createCanvasElement().getContext("2d")),
            s._measuringContext
          );
        },
        _splitText: function () {
          var l = this._splitTextIntoLines(this.text);
          return (
            (this.textLines = l.lines),
            (this._textLines = l.graphemeLines),
            (this._unwrappedTextLines = l._unwrappedLines),
            (this._text = l.graphemeText),
            l
          );
        },
        initDimensions: function () {
          this.__skipDimension ||
            (this._splitText(),
            this._clearCache(),
            this.path
              ? ((this.width = this.path.width),
                (this.height = this.path.height))
              : ((this.width =
                  this.calcTextWidth() ||
                  this.cursorWidth ||
                  this.MIN_TEXT_WIDTH),
                (this.height = this.calcTextHeight())),
            this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(),
            this.saveState({ propertySet: "_dimensionAffectingProps" }));
        },
        enlargeSpaces: function () {
          for (
            var l, c, h, m, g, f, v, y = 0, _ = this._textLines.length;
            y < _;
            y++
          )
            if (
              !(
                this.textAlign !== "justify" &&
                (y === _ - 1 || this.isEndOfWrapping(y))
              ) &&
              ((m = 0),
              (g = this._textLines[y]),
              (c = this.getLineWidth(y)),
              c < this.width &&
                (v = this.textLines[y].match(this._reSpacesAndTabs)))
            ) {
              (h = v.length), (l = (this.width - c) / h);
              for (var x = 0, b = g.length; x <= b; x++)
                (f = this.__charBounds[y][x]),
                  this._reSpaceAndTab.test(g[x])
                    ? ((f.width += l),
                      (f.kernedWidth += l),
                      (f.left += m),
                      (m += l))
                    : (f.left += m);
            }
        },
        isEndOfWrapping: function (l) {
          return l === this._textLines.length - 1;
        },
        missingNewlineOffset: function () {
          return 1;
        },
        toString: function () {
          return (
            "#<fabric.Text (" +
            this.complexity() +
            '): { "text": "' +
            this.text +
            '", "fontFamily": "' +
            this.fontFamily +
            '" }>'
          );
        },
        _getCacheCanvasDimensions: function () {
          var l = this.callSuper("_getCacheCanvasDimensions"),
            c = this.fontSize;
          return (l.width += c * l.zoomX), (l.height += c * l.zoomY), l;
        },
        _render: function (l) {
          var c = this.path;
          c && !c.isNotVisible() && c._render(l),
            this._setTextStyles(l),
            this._renderTextLinesBackground(l),
            this._renderTextDecoration(l, "underline"),
            this._renderText(l),
            this._renderTextDecoration(l, "overline"),
            this._renderTextDecoration(l, "linethrough");
        },
        _renderText: function (l) {
          this.paintFirst === "stroke"
            ? (this._renderTextStroke(l), this._renderTextFill(l))
            : (this._renderTextFill(l), this._renderTextStroke(l));
        },
        _setTextStyles: function (l, c, h) {
          if (((l.textBaseline = "alphabetical"), this.path))
            switch (this.pathAlign) {
              case "center":
                l.textBaseline = "middle";
                break;
              case "ascender":
                l.textBaseline = "top";
                break;
              case "descender":
                l.textBaseline = "bottom";
                break;
            }
          l.font = this._getFontDeclaration(c, h);
        },
        calcTextWidth: function () {
          for (
            var l = this.getLineWidth(0), c = 1, h = this._textLines.length;
            c < h;
            c++
          ) {
            var m = this.getLineWidth(c);
            m > l && (l = m);
          }
          return l;
        },
        _renderTextLine: function (l, c, h, m, g, f) {
          this._renderChars(l, c, h, m, g, f);
        },
        _renderTextLinesBackground: function (l) {
          if (
            !(
              !this.textBackgroundColor && !this.styleHas("textBackgroundColor")
            )
          ) {
            for (
              var c,
                h,
                m = l.fillStyle,
                g,
                f,
                v = this._getLeftOffset(),
                y = this._getTopOffset(),
                _ = 0,
                x = 0,
                b,
                S,
                T = this.path,
                w,
                P = 0,
                F = this._textLines.length;
              P < F;
              P++
            ) {
              if (
                ((c = this.getHeightOfLine(P)),
                !this.textBackgroundColor &&
                  !this.styleHas("textBackgroundColor", P))
              ) {
                y += c;
                continue;
              }
              (g = this._textLines[P]),
                (h = this._getLineLeftOffset(P)),
                (x = 0),
                (_ = 0),
                (f = this.getValueOfPropertyAt(P, 0, "textBackgroundColor"));
              for (var V = 0, J = g.length; V < J; V++)
                (b = this.__charBounds[P][V]),
                  (S = this.getValueOfPropertyAt(P, V, "textBackgroundColor")),
                  T
                    ? (l.save(),
                      l.translate(b.renderLeft, b.renderTop),
                      l.rotate(b.angle),
                      (l.fillStyle = S),
                      S &&
                        l.fillRect(
                          -b.width / 2,
                          (-c / this.lineHeight) * (1 - this._fontSizeFraction),
                          b.width,
                          c / this.lineHeight
                        ),
                      l.restore())
                    : S !== f
                    ? ((w = v + h + _),
                      this.direction === "rtl" && (w = this.width - w - x),
                      (l.fillStyle = f),
                      f && l.fillRect(w, y, x, c / this.lineHeight),
                      (_ = b.left),
                      (x = b.width),
                      (f = S))
                    : (x += b.kernedWidth);
              S &&
                !T &&
                ((w = v + h + _),
                this.direction === "rtl" && (w = this.width - w - x),
                (l.fillStyle = S),
                l.fillRect(w, y, x, c / this.lineHeight)),
                (y += c);
            }
            (l.fillStyle = m), this._removeShadow(l);
          }
        },
        getFontCache: function (l) {
          var c = l.fontFamily.toLowerCase();
          s.charWidthsCache[c] || (s.charWidthsCache[c] = {});
          var h = s.charWidthsCache[c],
            m =
              l.fontStyle.toLowerCase() +
              "_" +
              (l.fontWeight + "").toLowerCase();
          return h[m] || (h[m] = {}), h[m];
        },
        _measureChar: function (l, c, h, m) {
          var g = this.getFontCache(c),
            f = this._getFontDeclaration(c),
            v = this._getFontDeclaration(m),
            y = h + l,
            _ = f === v,
            x,
            b,
            S,
            T = c.fontSize / this.CACHE_FONT_SIZE,
            w;
          if (
            (h && g[h] !== void 0 && (S = g[h]),
            g[l] !== void 0 && (w = x = g[l]),
            _ && g[y] !== void 0 && ((b = g[y]), (w = b - S)),
            x === void 0 || S === void 0 || b === void 0)
          ) {
            var P = this.getMeasuringContext();
            this._setTextStyles(P, c, !0);
          }
          return (
            x === void 0 && ((w = x = P.measureText(l).width), (g[l] = x)),
            S === void 0 &&
              _ &&
              h &&
              ((S = P.measureText(h).width), (g[h] = S)),
            _ &&
              b === void 0 &&
              ((b = P.measureText(y).width), (g[y] = b), (w = b - S)),
            { width: x * T, kernedWidth: w * T }
          );
        },
        getHeightOfChar: function (l, c) {
          return this.getValueOfPropertyAt(l, c, "fontSize");
        },
        measureLine: function (l) {
          var c = this._measureLine(l);
          return (
            this.charSpacing !== 0 &&
              (c.width -= this._getWidthOfCharSpacing()),
            c.width < 0 && (c.width = 0),
            c
          );
        },
        _measureLine: function (l) {
          var c = 0,
            h,
            m,
            g = this._textLines[l],
            f,
            v,
            y = 0,
            _ = new Array(g.length),
            x = 0,
            b,
            S,
            T = this.path,
            w = this.pathSide === "right";
          for (this.__charBounds[l] = _, h = 0; h < g.length; h++)
            (m = g[h]),
              (v = this._getGraphemeBox(m, l, h, f)),
              (_[h] = v),
              (c += v.kernedWidth),
              (f = m);
          if (
            ((_[h] = {
              left: v ? v.left + v.width : 0,
              width: 0,
              kernedWidth: 0,
              height: this.fontSize,
            }),
            T)
          ) {
            switch (
              ((S = T.segmentsInfo[T.segmentsInfo.length - 1].length),
              (b = s.util.getPointOnPath(T.path, 0, T.segmentsInfo)),
              (b.x += T.pathOffset.x),
              (b.y += T.pathOffset.y),
              this.textAlign)
            ) {
              case "left":
                x = w ? S - c : 0;
                break;
              case "center":
                x = (S - c) / 2;
                break;
              case "right":
                x = w ? 0 : S - c;
                break;
            }
            for (
              x += this.pathStartOffset * (w ? -1 : 1),
                h = w ? g.length - 1 : 0;
              w ? h >= 0 : h < g.length;
              w ? h-- : h++
            )
              (v = _[h]),
                x > S ? (x %= S) : x < 0 && (x += S),
                this._setGraphemeOnPath(x, v, b),
                (x += v.kernedWidth);
          }
          return { width: c, numOfSpaces: y };
        },
        _setGraphemeOnPath: function (l, c, h) {
          var m = l + c.kernedWidth / 2,
            g = this.path,
            f = s.util.getPointOnPath(g.path, m, g.segmentsInfo);
          (c.renderLeft = f.x - h.x),
            (c.renderTop = f.y - h.y),
            (c.angle = f.angle + (this.pathSide === "right" ? Math.PI : 0));
        },
        _getGraphemeBox: function (l, c, h, m, g) {
          var f = this.getCompleteStyleDeclaration(c, h),
            v = m ? this.getCompleteStyleDeclaration(c, h - 1) : {},
            y = this._measureChar(l, f, m, v),
            _ = y.kernedWidth,
            x = y.width,
            b;
          this.charSpacing !== 0 &&
            ((b = this._getWidthOfCharSpacing()), (x += b), (_ += b));
          var S = {
            width: x,
            left: 0,
            height: f.fontSize,
            kernedWidth: _,
            deltaY: f.deltaY,
          };
          if (h > 0 && !g) {
            var T = this.__charBounds[c][h - 1];
            S.left = T.left + T.width + y.kernedWidth - y.width;
          }
          return S;
        },
        getHeightOfLine: function (l) {
          if (this.__lineHeights[l]) return this.__lineHeights[l];
          for (
            var c = this._textLines[l],
              h = this.getHeightOfChar(l, 0),
              m = 1,
              g = c.length;
            m < g;
            m++
          )
            h = Math.max(this.getHeightOfChar(l, m), h);
          return (this.__lineHeights[l] =
            h * this.lineHeight * this._fontSizeMult);
        },
        calcTextHeight: function () {
          for (var l, c = 0, h = 0, m = this._textLines.length; h < m; h++)
            (l = this.getHeightOfLine(h)),
              (c += h === m - 1 ? l / this.lineHeight : l);
          return c;
        },
        _getLeftOffset: function () {
          return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
        },
        _getTopOffset: function () {
          return -this.height / 2;
        },
        _renderTextCommon: function (l, c) {
          l.save();
          for (
            var h = 0,
              m = this._getLeftOffset(),
              g = this._getTopOffset(),
              f = 0,
              v = this._textLines.length;
            f < v;
            f++
          ) {
            var y = this.getHeightOfLine(f),
              _ = y / this.lineHeight,
              x = this._getLineLeftOffset(f);
            this._renderTextLine(c, l, this._textLines[f], m + x, g + h + _, f),
              (h += y);
          }
          l.restore();
        },
        _renderTextFill: function (l) {
          (!this.fill && !this.styleHas("fill")) ||
            this._renderTextCommon(l, "fillText");
        },
        _renderTextStroke: function (l) {
          ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) ||
            (this.shadow && !this.shadow.affectStroke && this._removeShadow(l),
            l.save(),
            this._setLineDash(l, this.strokeDashArray),
            l.beginPath(),
            this._renderTextCommon(l, "strokeText"),
            l.closePath(),
            l.restore());
        },
        _renderChars: function (l, c, h, m, g, f) {
          var v = this.getHeightOfLine(f),
            y = this.textAlign.indexOf("justify") !== -1,
            _,
            x,
            b = "",
            S,
            T = 0,
            w,
            P = this.path,
            F = !y && this.charSpacing === 0 && this.isEmptyStyles(f) && !P,
            V = this.direction === "ltr",
            J = this.direction === "ltr" ? 1 : -1,
            z,
            B = c.canvas.getAttribute("dir");
          if (
            (c.save(),
            B !== this.direction &&
              (c.canvas.setAttribute("dir", V ? "ltr" : "rtl"),
              (c.direction = V ? "ltr" : "rtl"),
              (c.textAlign = V ? "left" : "right")),
            (g -= (v * this._fontSizeFraction) / this.lineHeight),
            F)
          ) {
            this._renderChar(l, c, f, 0, h.join(""), m, g, v), c.restore();
            return;
          }
          for (var G = 0, ie = h.length - 1; G <= ie; G++)
            (w = G === ie || this.charSpacing || P),
              (b += h[G]),
              (S = this.__charBounds[f][G]),
              T === 0
                ? ((m += J * (S.kernedWidth - S.width)), (T += S.width))
                : (T += S.kernedWidth),
              y && !w && this._reSpaceAndTab.test(h[G]) && (w = !0),
              w ||
                ((_ = _ || this.getCompleteStyleDeclaration(f, G)),
                (x = this.getCompleteStyleDeclaration(f, G + 1)),
                (w = s.util.hasStyleChanged(_, x, !1))),
              w &&
                (P
                  ? (c.save(),
                    c.translate(S.renderLeft, S.renderTop),
                    c.rotate(S.angle),
                    this._renderChar(l, c, f, G, b, -T / 2, 0, v),
                    c.restore())
                  : ((z = m), this._renderChar(l, c, f, G, b, z, g, v)),
                (b = ""),
                (_ = x),
                (m += J * T),
                (T = 0));
          c.restore();
        },
        _applyPatternGradientTransformText: function (l) {
          var c = s.util.createCanvasElement(),
            h,
            m = this.width + this.strokeWidth,
            g = this.height + this.strokeWidth;
          return (
            (c.width = m),
            (c.height = g),
            (h = c.getContext("2d")),
            h.beginPath(),
            h.moveTo(0, 0),
            h.lineTo(m, 0),
            h.lineTo(m, g),
            h.lineTo(0, g),
            h.closePath(),
            h.translate(m / 2, g / 2),
            (h.fillStyle = l.toLive(h)),
            this._applyPatternGradientTransform(h, l),
            h.fill(),
            h.createPattern(c, "no-repeat")
          );
        },
        handleFiller: function (l, c, h) {
          var m, g;
          return h.toLive
            ? h.gradientUnits === "percentage" ||
              h.gradientTransform ||
              h.patternTransform
              ? ((m = -this.width / 2),
                (g = -this.height / 2),
                l.translate(m, g),
                (l[c] = this._applyPatternGradientTransformText(h)),
                { offsetX: m, offsetY: g })
              : ((l[c] = h.toLive(l, this)),
                this._applyPatternGradientTransform(l, h))
            : ((l[c] = h), { offsetX: 0, offsetY: 0 });
        },
        _setStrokeStyles: function (l, c) {
          return (
            (l.lineWidth = c.strokeWidth),
            (l.lineCap = this.strokeLineCap),
            (l.lineDashOffset = this.strokeDashOffset),
            (l.lineJoin = this.strokeLineJoin),
            (l.miterLimit = this.strokeMiterLimit),
            this.handleFiller(l, "strokeStyle", c.stroke)
          );
        },
        _setFillStyles: function (l, c) {
          return this.handleFiller(l, "fillStyle", c.fill);
        },
        _renderChar: function (l, c, h, m, g, f, v) {
          var y = this._getStyleDeclaration(h, m),
            _ = this.getCompleteStyleDeclaration(h, m),
            x = l === "fillText" && _.fill,
            b = l === "strokeText" && _.stroke && _.strokeWidth,
            S,
            T;
          (!b && !x) ||
            (c.save(),
            x && (S = this._setFillStyles(c, _)),
            b && (T = this._setStrokeStyles(c, _)),
            (c.font = this._getFontDeclaration(_)),
            y && y.textBackgroundColor && this._removeShadow(c),
            y && y.deltaY && (v += y.deltaY),
            x && c.fillText(g, f - S.offsetX, v - S.offsetY),
            b && c.strokeText(g, f - T.offsetX, v - T.offsetY),
            c.restore());
        },
        setSuperscript: function (l, c) {
          return this._setScript(l, c, this.superscript);
        },
        setSubscript: function (l, c) {
          return this._setScript(l, c, this.subscript);
        },
        _setScript: function (l, c, h) {
          var m = this.get2DCursorLocation(l, !0),
            g = this.getValueOfPropertyAt(m.lineIndex, m.charIndex, "fontSize"),
            f = this.getValueOfPropertyAt(m.lineIndex, m.charIndex, "deltaY"),
            v = { fontSize: g * h.size, deltaY: f + g * h.baseline };
          return this.setSelectionStyles(v, l, c), this;
        },
        _getLineLeftOffset: function (l) {
          var c = this.getLineWidth(l),
            h = this.width - c,
            m = this.textAlign,
            g = this.direction,
            v,
            f = 0,
            v = this.isEndOfWrapping(l);
          return m === "justify" ||
            (m === "justify-center" && !v) ||
            (m === "justify-right" && !v) ||
            (m === "justify-left" && !v)
            ? 0
            : (m === "center" && (f = h / 2),
              m === "right" && (f = h),
              m === "justify-center" && (f = h / 2),
              m === "justify-right" && (f = h),
              g === "rtl" && (f -= h),
              f);
        },
        _clearCache: function () {
          (this.__lineWidths = []),
            (this.__lineHeights = []),
            (this.__charBounds = []);
        },
        _shouldClearDimensionCache: function () {
          var l = this._forceClearCache;
          return (
            l || (l = this.hasStateChanged("_dimensionAffectingProps")),
            l && ((this.dirty = !0), (this._forceClearCache = !1)),
            l
          );
        },
        getLineWidth: function (l) {
          if (this.__lineWidths[l] !== void 0) return this.__lineWidths[l];
          var c = this.measureLine(l),
            h = c.width;
          return (this.__lineWidths[l] = h), h;
        },
        _getWidthOfCharSpacing: function () {
          return this.charSpacing !== 0
            ? (this.fontSize * this.charSpacing) / 1e3
            : 0;
        },
        getValueOfPropertyAt: function (l, c, h) {
          var m = this._getStyleDeclaration(l, c);
          return m && typeof m[h] < "u" ? m[h] : this[h];
        },
        _renderTextDecoration: function (l, c) {
          if (!(!this[c] && !this.styleHas(c))) {
            for (
              var h,
                m,
                g,
                f,
                v,
                y,
                _,
                x,
                b = this._getLeftOffset(),
                S = this._getTopOffset(),
                T,
                w,
                P,
                F,
                V,
                J,
                z,
                B,
                G = this.path,
                ie = this._getWidthOfCharSpacing(),
                re = this.offsets[c],
                j = 0,
                C = this._textLines.length;
              j < C;
              j++
            ) {
              if (
                ((h = this.getHeightOfLine(j)),
                !this[c] && !this.styleHas(c, j))
              ) {
                S += h;
                continue;
              }
              (_ = this._textLines[j]),
                (J = h / this.lineHeight),
                (f = this._getLineLeftOffset(j)),
                (w = 0),
                (P = 0),
                (x = this.getValueOfPropertyAt(j, 0, c)),
                (B = this.getValueOfPropertyAt(j, 0, "fill")),
                (T = S + J * (1 - this._fontSizeFraction)),
                (m = this.getHeightOfChar(j, 0)),
                (v = this.getValueOfPropertyAt(j, 0, "deltaY"));
              for (var R = 0, A = _.length; R < A; R++)
                if (
                  ((F = this.__charBounds[j][R]),
                  (V = this.getValueOfPropertyAt(j, R, c)),
                  (z = this.getValueOfPropertyAt(j, R, "fill")),
                  (g = this.getHeightOfChar(j, R)),
                  (y = this.getValueOfPropertyAt(j, R, "deltaY")),
                  G && V && z)
                )
                  l.save(),
                    (l.fillStyle = B),
                    l.translate(F.renderLeft, F.renderTop),
                    l.rotate(F.angle),
                    l.fillRect(
                      -F.kernedWidth / 2,
                      re * g + y,
                      F.kernedWidth,
                      this.fontSize / 15
                    ),
                    l.restore();
                else if ((V !== x || z !== B || g !== m || y !== v) && P > 0) {
                  var O = b + f + w;
                  this.direction === "rtl" && (O = this.width - O - P),
                    x &&
                      B &&
                      ((l.fillStyle = B),
                      l.fillRect(O, T + re * m + v, P, this.fontSize / 15)),
                    (w = F.left),
                    (P = F.width),
                    (x = V),
                    (B = z),
                    (m = g),
                    (v = y);
                } else P += F.kernedWidth;
              var O = b + f + w;
              this.direction === "rtl" && (O = this.width - O - P),
                (l.fillStyle = z),
                V &&
                  z &&
                  l.fillRect(O, T + re * m + v, P - ie, this.fontSize / 15),
                (S += h);
            }
            this._removeShadow(l);
          }
        },
        _getFontDeclaration: function (l, c) {
          var h = l || this,
            m = this.fontFamily,
            g = s.Text.genericFonts.indexOf(m.toLowerCase()) > -1,
            f =
              m === void 0 ||
              m.indexOf("'") > -1 ||
              m.indexOf(",") > -1 ||
              m.indexOf('"') > -1 ||
              g
                ? h.fontFamily
                : '"' + h.fontFamily + '"';
          return [
            s.isLikelyNode ? h.fontWeight : h.fontStyle,
            s.isLikelyNode ? h.fontStyle : h.fontWeight,
            c ? this.CACHE_FONT_SIZE + "px" : h.fontSize + "px",
            f,
          ].join(" ");
        },
        render: function (l) {
          this.visible &&
            ((this.canvas &&
              this.canvas.skipOffscreen &&
              !this.group &&
              !this.isOnScreen()) ||
              (this._shouldClearDimensionCache() && this.initDimensions(),
              this.callSuper("render", l)));
        },
        _splitTextIntoLines: function (l) {
          for (
            var c = l.split(this._reNewline),
              h = new Array(c.length),
              m = [
                `
`,
              ],
              g = [],
              f = 0;
            f < c.length;
            f++
          )
            (h[f] = s.util.string.graphemeSplit(c[f])), (g = g.concat(h[f], m));
          return (
            g.pop(),
            { _unwrappedLines: h, lines: c, graphemeText: g, graphemeLines: h }
          );
        },
        toObject: function (l) {
          var c = d.concat(l),
            h = this.callSuper("toObject", c);
          return (
            (h.styles = s.util.stylesToArray(this.styles, this.text)),
            h.path && (h.path = this.path.toObject()),
            h
          );
        },
        set: function (l, c) {
          this.callSuper("set", l, c);
          var h = !1,
            m = !1;
          if (typeof l == "object")
            for (var g in l)
              g === "path" && this.setPathInfo(),
                (h = h || this._dimensionAffectingProps.indexOf(g) !== -1),
                (m = m || g === "path");
          else
            (h = this._dimensionAffectingProps.indexOf(l) !== -1),
              (m = l === "path");
          return (
            m && this.setPathInfo(),
            h && (this.initDimensions(), this.setCoords()),
            this
          );
        },
        complexity: function () {
          return 1;
        },
      })),
        (s.Text.ATTRIBUTE_NAMES = s.SHARED_ATTRIBUTES.concat(
          "x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(
            " "
          )
        )),
        (s.Text.DEFAULT_SVG_FONT_SIZE = 16),
        (s.Text.fromElement = function (l, c, h) {
          if (!l) return c(null);
          var m = s.parseAttributes(l, s.Text.ATTRIBUTE_NAMES),
            g = m.textAnchor || "left";
          if (
            ((h = s.util.object.extend(h ? u(h) : {}, m)),
            (h.top = h.top || 0),
            (h.left = h.left || 0),
            m.textDecoration)
          ) {
            var f = m.textDecoration;
            f.indexOf("underline") !== -1 && (h.underline = !0),
              f.indexOf("overline") !== -1 && (h.overline = !0),
              f.indexOf("line-through") !== -1 && (h.linethrough = !0),
              delete h.textDecoration;
          }
          "dx" in m && (h.left += m.dx),
            "dy" in m && (h.top += m.dy),
            "fontSize" in h || (h.fontSize = s.Text.DEFAULT_SVG_FONT_SIZE);
          var v = "";
          "textContent" in l
            ? (v = l.textContent)
            : "firstChild" in l &&
              l.firstChild !== null &&
              "data" in l.firstChild &&
              l.firstChild.data !== null &&
              (v = l.firstChild.data),
            (v = v.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "));
          var y = h.strokeWidth;
          h.strokeWidth = 0;
          var _ = new s.Text(v, h),
            x = _.getScaledHeight() / _.height,
            b = (_.height + _.strokeWidth) * _.lineHeight - _.height,
            S = b * x,
            T = _.getScaledHeight() + S,
            w = 0;
          g === "center" && (w = _.getScaledWidth() / 2),
            g === "right" && (w = _.getScaledWidth()),
            _.set({
              left: _.left - w,
              top:
                _.top -
                (T - _.fontSize * (0.07 + _._fontSizeFraction)) / _.lineHeight,
              strokeWidth: typeof y < "u" ? y : 1,
            }),
            c(_);
        }),
        (s.Text.fromObject = function (l, c) {
          var h = u(l),
            m = l.path;
          return (
            delete h.path,
            s.Object._fromObject(
              "Text",
              h,
              function (g) {
                (g.styles = s.util.stylesFromArray(l.styles, l.text)),
                  m
                    ? s.Object._fromObject(
                        "Path",
                        m,
                        function (f) {
                          g.set("path", f), c(g);
                        },
                        "path"
                      )
                    : c(g);
              },
              "text"
            )
          );
        }),
        (s.Text.genericFonts = [
          "sans-serif",
          "serif",
          "cursive",
          "fantasy",
          "monospace",
        ]),
        s.util.createAccessors && s.util.createAccessors(s.Text);
    })(n),
    (function () {
      e.util.object.extend(e.Text.prototype, {
        isEmptyStyles: function (a) {
          if (!this.styles || (typeof a < "u" && !this.styles[a])) return !0;
          var s = typeof a > "u" ? this.styles : { line: this.styles[a] };
          for (var u in s) for (var d in s[u]) for (var l in s[u][d]) return !1;
          return !0;
        },
        styleHas: function (a, s) {
          if (
            !this.styles ||
            !a ||
            a === "" ||
            (typeof s < "u" && !this.styles[s])
          )
            return !1;
          var u = typeof s > "u" ? this.styles : { 0: this.styles[s] };
          for (var d in u)
            for (var l in u[d]) if (typeof u[d][l][a] < "u") return !0;
          return !1;
        },
        cleanStyle: function (a) {
          if (!this.styles || !a || a === "") return !1;
          var s = this.styles,
            u = 0,
            d,
            l,
            c = !0,
            h = 0,
            m;
          for (var g in s) {
            d = 0;
            for (var f in s[g]) {
              var m = s[g][f],
                v = m.hasOwnProperty(a);
              u++,
                v
                  ? (l ? m[a] !== l && (c = !1) : (l = m[a]),
                    m[a] === this[a] && delete m[a])
                  : (c = !1),
                Object.keys(m).length !== 0 ? d++ : delete s[g][f];
            }
            d === 0 && delete s[g];
          }
          for (var y = 0; y < this._textLines.length; y++)
            h += this._textLines[y].length;
          c && u === h && ((this[a] = l), this.removeStyle(a));
        },
        removeStyle: function (a) {
          if (!(!this.styles || !a || a === "")) {
            var s = this.styles,
              u,
              d,
              l;
            for (d in s) {
              u = s[d];
              for (l in u)
                delete u[l][a], Object.keys(u[l]).length === 0 && delete u[l];
              Object.keys(u).length === 0 && delete s[d];
            }
          }
        },
        _extendStyles: function (a, s) {
          var u = this.get2DCursorLocation(a);
          this._getLineStyle(u.lineIndex) || this._setLineStyle(u.lineIndex),
            this._getStyleDeclaration(u.lineIndex, u.charIndex) ||
              this._setStyleDeclaration(u.lineIndex, u.charIndex, {}),
            e.util.object.extend(
              this._getStyleDeclaration(u.lineIndex, u.charIndex),
              s
            );
        },
        get2DCursorLocation: function (a, s) {
          typeof a > "u" && (a = this.selectionStart);
          for (
            var u = s ? this._unwrappedTextLines : this._textLines,
              d = u.length,
              l = 0;
            l < d;
            l++
          ) {
            if (a <= u[l].length) return { lineIndex: l, charIndex: a };
            a -= u[l].length + this.missingNewlineOffset(l);
          }
          return {
            lineIndex: l - 1,
            charIndex: u[l - 1].length < a ? u[l - 1].length : a,
          };
        },
        getSelectionStyles: function (a, s, u) {
          typeof a > "u" && (a = this.selectionStart || 0),
            typeof s > "u" && (s = this.selectionEnd || a);
          for (var d = [], l = a; l < s; l++)
            d.push(this.getStyleAtPosition(l, u));
          return d;
        },
        getStyleAtPosition: function (a, s) {
          var u = this.get2DCursorLocation(a),
            d = s
              ? this.getCompleteStyleDeclaration(u.lineIndex, u.charIndex)
              : this._getStyleDeclaration(u.lineIndex, u.charIndex);
          return d || {};
        },
        setSelectionStyles: function (a, s, u) {
          typeof s > "u" && (s = this.selectionStart || 0),
            typeof u > "u" && (u = this.selectionEnd || s);
          for (var d = s; d < u; d++) this._extendStyles(d, a);
          return (this._forceClearCache = !0), this;
        },
        _getStyleDeclaration: function (a, s) {
          var u = this.styles && this.styles[a];
          return u ? u[s] : null;
        },
        getCompleteStyleDeclaration: function (a, s) {
          for (
            var u = this._getStyleDeclaration(a, s) || {}, d = {}, l, c = 0;
            c < this._styleProperties.length;
            c++
          )
            (l = this._styleProperties[c]),
              (d[l] = typeof u[l] > "u" ? this[l] : u[l]);
          return d;
        },
        _setStyleDeclaration: function (a, s, u) {
          this.styles[a][s] = u;
        },
        _deleteStyleDeclaration: function (a, s) {
          delete this.styles[a][s];
        },
        _getLineStyle: function (a) {
          return !!this.styles[a];
        },
        _setLineStyle: function (a) {
          this.styles[a] = {};
        },
        _deleteLineStyle: function (a) {
          delete this.styles[a];
        },
      });
    })(),
    (function () {
      function a(s) {
        s.textDecoration &&
          (s.textDecoration.indexOf("underline") > -1 && (s.underline = !0),
          s.textDecoration.indexOf("line-through") > -1 && (s.linethrough = !0),
          s.textDecoration.indexOf("overline") > -1 && (s.overline = !0),
          delete s.textDecoration);
      }
      (e.IText = e.util.createClass(e.Text, e.Observable, {
        type: "i-text",
        selectionStart: 0,
        selectionEnd: 0,
        selectionColor: "rgba(17,119,255,0.3)",
        isEditing: !1,
        editable: !0,
        editingBorderColor: "rgba(102,153,255,0.25)",
        cursorWidth: 2,
        cursorColor: "",
        cursorDelay: 1e3,
        cursorDuration: 600,
        caching: !0,
        hiddenTextareaContainer: null,
        _reSpace: /\s|\n/,
        _currentCursorOpacity: 0,
        _selectionDirection: null,
        _abortCursorAnimation: !1,
        __widthOfSpace: [],
        inCompositionMode: !1,
        initialize: function (s, u) {
          this.callSuper("initialize", s, u), this.initBehavior();
        },
        setSelectionStart: function (s) {
          (s = Math.max(s, 0)), this._updateAndFire("selectionStart", s);
        },
        setSelectionEnd: function (s) {
          (s = Math.min(s, this.text.length)),
            this._updateAndFire("selectionEnd", s);
        },
        _updateAndFire: function (s, u) {
          this[s] !== u && (this._fireSelectionChanged(), (this[s] = u)),
            this._updateTextarea();
        },
        _fireSelectionChanged: function () {
          this.fire("selection:changed"),
            this.canvas &&
              this.canvas.fire("text:selection:changed", { target: this });
        },
        initDimensions: function () {
          this.isEditing && this.initDelayedCursor(),
            this.clearContextTop(),
            this.callSuper("initDimensions");
        },
        render: function (s) {
          this.clearContextTop(),
            this.callSuper("render", s),
            (this.cursorOffsetCache = {}),
            this.renderCursorOrSelection();
        },
        _render: function (s) {
          this.callSuper("_render", s);
        },
        clearContextTop: function (s) {
          if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) {
            var u = this.canvas.contextTop,
              d = this.canvas.viewportTransform;
            u.save(),
              u.transform(d[0], d[1], d[2], d[3], d[4], d[5]),
              this.transform(u),
              this._clearTextArea(u),
              s || u.restore();
          }
        },
        renderCursorOrSelection: function () {
          if (!(!this.isEditing || !this.canvas || !this.canvas.contextTop)) {
            var s = this._getCursorBoundaries(),
              u = this.canvas.contextTop;
            this.clearContextTop(!0),
              this.selectionStart === this.selectionEnd
                ? this.renderCursor(s, u)
                : this.renderSelection(s, u),
              u.restore();
          }
        },
        _clearTextArea: function (s) {
          var u = this.width + 4,
            d = this.height + 4;
          s.clearRect(-u / 2, -d / 2, u, d);
        },
        _getCursorBoundaries: function (s) {
          typeof s > "u" && (s = this.selectionStart);
          var u = this._getLeftOffset(),
            d = this._getTopOffset(),
            l = this._getCursorBoundariesOffsets(s);
          return { left: u, top: d, leftOffset: l.left, topOffset: l.top };
        },
        _getCursorBoundariesOffsets: function (s) {
          if (this.cursorOffsetCache && "top" in this.cursorOffsetCache)
            return this.cursorOffsetCache;
          var u,
            d,
            l,
            c = 0,
            h = 0,
            m,
            g = this.get2DCursorLocation(s);
          (l = g.charIndex), (d = g.lineIndex);
          for (var f = 0; f < d; f++) c += this.getHeightOfLine(f);
          u = this._getLineLeftOffset(d);
          var v = this.__charBounds[d][l];
          return (
            v && (h = v.left),
            this.charSpacing !== 0 &&
              l === this._textLines[d].length &&
              (h -= this._getWidthOfCharSpacing()),
            (m = { top: c, left: u + (h > 0 ? h : 0) }),
            this.direction === "rtl" && (m.left *= -1),
            (this.cursorOffsetCache = m),
            this.cursorOffsetCache
          );
        },
        renderCursor: function (s, u) {
          var d = this.get2DCursorLocation(),
            l = d.lineIndex,
            c = d.charIndex > 0 ? d.charIndex - 1 : 0,
            h = this.getValueOfPropertyAt(l, c, "fontSize"),
            m = this.scaleX * this.canvas.getZoom(),
            g = this.cursorWidth / m,
            f = s.topOffset,
            v = this.getValueOfPropertyAt(l, c, "deltaY");
          (f +=
            ((1 - this._fontSizeFraction) * this.getHeightOfLine(l)) /
              this.lineHeight -
            h * (1 - this._fontSizeFraction)),
            this.inCompositionMode && this.renderSelection(s, u),
            (u.fillStyle =
              this.cursorColor || this.getValueOfPropertyAt(l, c, "fill")),
            (u.globalAlpha = this.__isMousedown
              ? 1
              : this._currentCursorOpacity),
            u.fillRect(s.left + s.leftOffset - g / 2, f + s.top + v, g, h);
        },
        renderSelection: function (s, u) {
          for (
            var d = this.inCompositionMode
                ? this.hiddenTextarea.selectionStart
                : this.selectionStart,
              l = this.inCompositionMode
                ? this.hiddenTextarea.selectionEnd
                : this.selectionEnd,
              c = this.textAlign.indexOf("justify") !== -1,
              h = this.get2DCursorLocation(d),
              m = this.get2DCursorLocation(l),
              g = h.lineIndex,
              f = m.lineIndex,
              v = h.charIndex < 0 ? 0 : h.charIndex,
              y = m.charIndex < 0 ? 0 : m.charIndex,
              _ = g;
            _ <= f;
            _++
          ) {
            var x = this._getLineLeftOffset(_) || 0,
              b = this.getHeightOfLine(_),
              S = 0,
              T = 0,
              w = 0;
            if (
              (_ === g && (T = this.__charBounds[g][v].left), _ >= g && _ < f)
            )
              w =
                c && !this.isEndOfWrapping(_)
                  ? this.width
                  : this.getLineWidth(_) || 5;
            else if (_ === f)
              if (y === 0) w = this.__charBounds[f][y].left;
              else {
                var P = this._getWidthOfCharSpacing();
                w =
                  this.__charBounds[f][y - 1].left +
                  this.__charBounds[f][y - 1].width -
                  P;
              }
            (S = b),
              (this.lineHeight < 1 || (_ === f && this.lineHeight > 1)) &&
                (b /= this.lineHeight);
            var F = s.left + x + T,
              V = w - T,
              J = b,
              z = 0;
            this.inCompositionMode
              ? ((u.fillStyle = this.compositionColor || "black"),
                (J = 1),
                (z = b))
              : (u.fillStyle = this.selectionColor),
              this.direction === "rtl" && (F = this.width - F - V),
              u.fillRect(F, s.top + s.topOffset + z, V, J),
              (s.topOffset += S);
          }
        },
        getCurrentCharFontSize: function () {
          var s = this._getCurrentCharIndex();
          return this.getValueOfPropertyAt(s.l, s.c, "fontSize");
        },
        getCurrentCharColor: function () {
          var s = this._getCurrentCharIndex();
          return this.getValueOfPropertyAt(s.l, s.c, "fill");
        },
        _getCurrentCharIndex: function () {
          var s = this.get2DCursorLocation(this.selectionStart, !0),
            u = s.charIndex > 0 ? s.charIndex - 1 : 0;
          return { l: s.lineIndex, c: u };
        },
      })),
        (e.IText.fromObject = function (s, u) {
          var d = e.util.stylesFromArray(s.styles, s.text),
            l = Object.assign({}, s, { styles: d });
          if ((a(l), l.styles))
            for (var c in l.styles)
              for (var h in l.styles[c]) a(l.styles[c][h]);
          e.Object._fromObject("IText", l, u, "text");
        });
    })(),
    (function () {
      var a = e.util.object.clone;
      e.util.object.extend(e.IText.prototype, {
        initBehavior: function () {
          this.initAddedHandler(),
            this.initRemovedHandler(),
            this.initCursorSelectionHandlers(),
            this.initDoubleClickSimulation(),
            (this.mouseMoveHandler = this.mouseMoveHandler.bind(this));
        },
        onDeselect: function () {
          this.isEditing && this.exitEditing(), (this.selected = !1);
        },
        initAddedHandler: function () {
          var s = this;
          this.on("added", function () {
            var u = s.canvas;
            u &&
              (u._hasITextHandlers ||
                ((u._hasITextHandlers = !0), s._initCanvasHandlers(u)),
              (u._iTextInstances = u._iTextInstances || []),
              u._iTextInstances.push(s));
          });
        },
        initRemovedHandler: function () {
          var s = this;
          this.on("removed", function () {
            var u = s.canvas;
            u &&
              ((u._iTextInstances = u._iTextInstances || []),
              e.util.removeFromArray(u._iTextInstances, s),
              u._iTextInstances.length === 0 &&
                ((u._hasITextHandlers = !1), s._removeCanvasHandlers(u)));
          });
        },
        _initCanvasHandlers: function (s) {
          (s._mouseUpITextHandler = function () {
            s._iTextInstances &&
              s._iTextInstances.forEach(function (u) {
                u.__isMousedown = !1;
              });
          }),
            s.on("mouse:up", s._mouseUpITextHandler);
        },
        _removeCanvasHandlers: function (s) {
          s.off("mouse:up", s._mouseUpITextHandler);
        },
        _tick: function () {
          this._currentTickState = this._animateCursor(
            this,
            1,
            this.cursorDuration,
            "_onTickComplete"
          );
        },
        _animateCursor: function (s, u, d, l) {
          var c;
          return (
            (c = {
              isAborted: !1,
              abort: function () {
                this.isAborted = !0;
              },
            }),
            s.animate("_currentCursorOpacity", u, {
              duration: d,
              onComplete: function () {
                c.isAborted || s[l]();
              },
              onChange: function () {
                s.canvas &&
                  s.selectionStart === s.selectionEnd &&
                  s.renderCursorOrSelection();
              },
              abort: function () {
                return c.isAborted;
              },
            }),
            c
          );
        },
        _onTickComplete: function () {
          var s = this;
          this._cursorTimeout1 && clearTimeout(this._cursorTimeout1),
            (this._cursorTimeout1 = setTimeout(function () {
              s._currentTickCompleteState = s._animateCursor(
                s,
                0,
                this.cursorDuration / 2,
                "_tick"
              );
            }, 100));
        },
        initDelayedCursor: function (s) {
          var u = this,
            d = s ? 0 : this.cursorDelay;
          this.abortCursorAnimation(),
            (this._currentCursorOpacity = 1),
            (this._cursorTimeout2 = setTimeout(function () {
              u._tick();
            }, d));
        },
        abortCursorAnimation: function () {
          var s = this._currentTickState || this._currentTickCompleteState,
            u = this.canvas;
          this._currentTickState && this._currentTickState.abort(),
            this._currentTickCompleteState &&
              this._currentTickCompleteState.abort(),
            clearTimeout(this._cursorTimeout1),
            clearTimeout(this._cursorTimeout2),
            (this._currentCursorOpacity = 0),
            s && u && u.clearContext(u.contextTop || u.contextContainer);
        },
        selectAll: function () {
          return (
            (this.selectionStart = 0),
            (this.selectionEnd = this._text.length),
            this._fireSelectionChanged(),
            this._updateTextarea(),
            this
          );
        },
        getSelectedText: function () {
          return this._text
            .slice(this.selectionStart, this.selectionEnd)
            .join("");
        },
        findWordBoundaryLeft: function (s) {
          var u = 0,
            d = s - 1;
          if (this._reSpace.test(this._text[d]))
            for (; this._reSpace.test(this._text[d]); ) u++, d--;
          for (; /\S/.test(this._text[d]) && d > -1; ) u++, d--;
          return s - u;
        },
        findWordBoundaryRight: function (s) {
          var u = 0,
            d = s;
          if (this._reSpace.test(this._text[d]))
            for (; this._reSpace.test(this._text[d]); ) u++, d++;
          for (; /\S/.test(this._text[d]) && d < this._text.length; ) u++, d++;
          return s + u;
        },
        findLineBoundaryLeft: function (s) {
          for (var u = 0, d = s - 1; !/\n/.test(this._text[d]) && d > -1; )
            u++, d--;
          return s - u;
        },
        findLineBoundaryRight: function (s) {
          for (
            var u = 0, d = s;
            !/\n/.test(this._text[d]) && d < this._text.length;

          )
            u++, d++;
          return s + u;
        },
        searchWordBoundary: function (s, u) {
          for (
            var d = this._text,
              l = this._reSpace.test(d[s]) ? s - 1 : s,
              c = d[l],
              h = e.reNonWord;
            !h.test(c) && l > 0 && l < d.length;

          )
            (l += u), (c = d[l]);
          return h.test(c) && (l += u === 1 ? 0 : 1), l;
        },
        selectWord: function (s) {
          s = s || this.selectionStart;
          var u = this.searchWordBoundary(s, -1),
            d = this.searchWordBoundary(s, 1);
          (this.selectionStart = u),
            (this.selectionEnd = d),
            this._fireSelectionChanged(),
            this._updateTextarea(),
            this.renderCursorOrSelection();
        },
        selectLine: function (s) {
          s = s || this.selectionStart;
          var u = this.findLineBoundaryLeft(s),
            d = this.findLineBoundaryRight(s);
          return (
            (this.selectionStart = u),
            (this.selectionEnd = d),
            this._fireSelectionChanged(),
            this._updateTextarea(),
            this
          );
        },
        enterEditing: function (s) {
          if (!(this.isEditing || !this.editable))
            return (
              this.canvas &&
                (this.canvas.calcOffset(),
                this.exitEditingOnOthers(this.canvas)),
              (this.isEditing = !0),
              this.initHiddenTextarea(s),
              this.hiddenTextarea.focus(),
              (this.hiddenTextarea.value = this.text),
              this._updateTextarea(),
              this._saveEditingProps(),
              this._setEditingProps(),
              (this._textBeforeEdit = this.text),
              this._tick(),
              this.fire("editing:entered"),
              this._fireSelectionChanged(),
              this.canvas
                ? (this.canvas.fire("text:editing:entered", { target: this }),
                  this.initMouseMoveHandler(),
                  this.canvas.requestRenderAll(),
                  this)
                : this
            );
        },
        exitEditingOnOthers: function (s) {
          s._iTextInstances &&
            s._iTextInstances.forEach(function (u) {
              (u.selected = !1), u.isEditing && u.exitEditing();
            });
        },
        initMouseMoveHandler: function () {
          this.canvas.on("mouse:move", this.mouseMoveHandler);
        },
        mouseMoveHandler: function (s) {
          if (!(!this.__isMousedown || !this.isEditing)) {
            document.activeElement !== this.hiddenTextarea &&
              this.hiddenTextarea.focus();
            var u = this.getSelectionStartFromPointer(s.e),
              d = this.selectionStart,
              l = this.selectionEnd;
            ((u !== this.__selectionStartOnMouseDown || d === l) &&
              (d === u || l === u)) ||
              (u > this.__selectionStartOnMouseDown
                ? ((this.selectionStart = this.__selectionStartOnMouseDown),
                  (this.selectionEnd = u))
                : ((this.selectionStart = u),
                  (this.selectionEnd = this.__selectionStartOnMouseDown)),
              (this.selectionStart !== d || this.selectionEnd !== l) &&
                (this.restartCursorIfNeeded(),
                this._fireSelectionChanged(),
                this._updateTextarea(),
                this.renderCursorOrSelection()));
          }
        },
        _setEditingProps: function () {
          (this.hoverCursor = "text"),
            this.canvas &&
              (this.canvas.defaultCursor = this.canvas.moveCursor = "text"),
            (this.borderColor = this.editingBorderColor),
            (this.hasControls = this.selectable = !1),
            (this.lockMovementX = this.lockMovementY = !0);
        },
        fromStringToGraphemeSelection: function (s, u, d) {
          var l = d.slice(0, s),
            c = e.util.string.graphemeSplit(l).length;
          if (s === u) return { selectionStart: c, selectionEnd: c };
          var h = d.slice(s, u),
            m = e.util.string.graphemeSplit(h).length;
          return { selectionStart: c, selectionEnd: c + m };
        },
        fromGraphemeToStringSelection: function (s, u, d) {
          var l = d.slice(0, s),
            c = l.join("").length;
          if (s === u) return { selectionStart: c, selectionEnd: c };
          var h = d.slice(s, u),
            m = h.join("").length;
          return { selectionStart: c, selectionEnd: c + m };
        },
        _updateTextarea: function () {
          if (((this.cursorOffsetCache = {}), !!this.hiddenTextarea)) {
            if (!this.inCompositionMode) {
              var s = this.fromGraphemeToStringSelection(
                this.selectionStart,
                this.selectionEnd,
                this._text
              );
              (this.hiddenTextarea.selectionStart = s.selectionStart),
                (this.hiddenTextarea.selectionEnd = s.selectionEnd);
            }
            this.updateTextareaPosition();
          }
        },
        updateFromTextArea: function () {
          if (this.hiddenTextarea) {
            (this.cursorOffsetCache = {}),
              (this.text = this.hiddenTextarea.value),
              this._shouldClearDimensionCache() &&
                (this.initDimensions(), this.setCoords());
            var s = this.fromStringToGraphemeSelection(
              this.hiddenTextarea.selectionStart,
              this.hiddenTextarea.selectionEnd,
              this.hiddenTextarea.value
            );
            (this.selectionEnd = this.selectionStart = s.selectionEnd),
              this.inCompositionMode ||
                (this.selectionStart = s.selectionStart),
              this.updateTextareaPosition();
          }
        },
        updateTextareaPosition: function () {
          if (this.selectionStart === this.selectionEnd) {
            var s = this._calcTextareaPosition();
            (this.hiddenTextarea.style.left = s.left),
              (this.hiddenTextarea.style.top = s.top);
          }
        },
        _calcTextareaPosition: function () {
          if (!this.canvas) return { x: 1, y: 1 };
          var s = this.inCompositionMode
              ? this.compositionStart
              : this.selectionStart,
            u = this._getCursorBoundaries(s),
            d = this.get2DCursorLocation(s),
            l = d.lineIndex,
            c = d.charIndex,
            h = this.getValueOfPropertyAt(l, c, "fontSize") * this.lineHeight,
            m = u.leftOffset,
            g = this.calcTransformMatrix(),
            f = { x: u.left + m, y: u.top + u.topOffset + h },
            v = this.canvas.getRetinaScaling(),
            y = this.canvas.upperCanvasEl,
            _ = y.width / v,
            x = y.height / v,
            b = _ - h,
            S = x - h,
            T = y.clientWidth / _,
            w = y.clientHeight / x;
          return (
            (f = e.util.transformPoint(f, g)),
            (f = e.util.transformPoint(f, this.canvas.viewportTransform)),
            (f.x *= T),
            (f.y *= w),
            f.x < 0 && (f.x = 0),
            f.x > b && (f.x = b),
            f.y < 0 && (f.y = 0),
            f.y > S && (f.y = S),
            (f.x += this.canvas._offset.left),
            (f.y += this.canvas._offset.top),
            {
              left: f.x + "px",
              top: f.y + "px",
              fontSize: h + "px",
              charHeight: h,
            }
          );
        },
        _saveEditingProps: function () {
          this._savedProps = {
            hasControls: this.hasControls,
            borderColor: this.borderColor,
            lockMovementX: this.lockMovementX,
            lockMovementY: this.lockMovementY,
            hoverCursor: this.hoverCursor,
            selectable: this.selectable,
            defaultCursor: this.canvas && this.canvas.defaultCursor,
            moveCursor: this.canvas && this.canvas.moveCursor,
          };
        },
        _restoreEditingProps: function () {
          this._savedProps &&
            ((this.hoverCursor = this._savedProps.hoverCursor),
            (this.hasControls = this._savedProps.hasControls),
            (this.borderColor = this._savedProps.borderColor),
            (this.selectable = this._savedProps.selectable),
            (this.lockMovementX = this._savedProps.lockMovementX),
            (this.lockMovementY = this._savedProps.lockMovementY),
            this.canvas &&
              ((this.canvas.defaultCursor = this._savedProps.defaultCursor),
              (this.canvas.moveCursor = this._savedProps.moveCursor)));
        },
        exitEditing: function () {
          var s = this._textBeforeEdit !== this.text,
            u = this.hiddenTextarea;
          return (
            (this.selected = !1),
            (this.isEditing = !1),
            (this.selectionEnd = this.selectionStart),
            u &&
              (u.blur && u.blur(), u.parentNode && u.parentNode.removeChild(u)),
            (this.hiddenTextarea = null),
            this.abortCursorAnimation(),
            this._restoreEditingProps(),
            (this._currentCursorOpacity = 0),
            this._shouldClearDimensionCache() &&
              (this.initDimensions(), this.setCoords()),
            this.fire("editing:exited"),
            s && this.fire("modified"),
            this.canvas &&
              (this.canvas.off("mouse:move", this.mouseMoveHandler),
              this.canvas.fire("text:editing:exited", { target: this }),
              s && this.canvas.fire("object:modified", { target: this })),
            this
          );
        },
        _removeExtraneousStyles: function () {
          for (var s in this.styles)
            this._textLines[s] || delete this.styles[s];
        },
        removeStyleFromTo: function (s, u) {
          var d = this.get2DCursorLocation(s, !0),
            l = this.get2DCursorLocation(u, !0),
            c = d.lineIndex,
            h = d.charIndex,
            m = l.lineIndex,
            g = l.charIndex,
            f,
            v;
          if (c !== m) {
            if (this.styles[c])
              for (f = h; f < this._unwrappedTextLines[c].length; f++)
                delete this.styles[c][f];
            if (this.styles[m])
              for (f = g; f < this._unwrappedTextLines[m].length; f++)
                (v = this.styles[m][f]),
                  v &&
                    (this.styles[c] || (this.styles[c] = {}),
                    (this.styles[c][h + f - g] = v));
            for (f = c + 1; f <= m; f++) delete this.styles[f];
            this.shiftLineStyles(m, c - m);
          } else if (this.styles[c]) {
            v = this.styles[c];
            var y = g - h,
              _,
              x;
            for (f = h; f < g; f++) delete v[f];
            for (x in this.styles[c])
              (_ = parseInt(x, 10)), _ >= g && ((v[_ - y] = v[x]), delete v[x]);
          }
        },
        shiftLineStyles: function (s, u) {
          var d = a(this.styles);
          for (var l in this.styles) {
            var c = parseInt(l, 10);
            c > s &&
              ((this.styles[c + u] = d[c]), d[c - u] || delete this.styles[c]);
          }
        },
        restartCursorIfNeeded: function () {
          (!this._currentTickState ||
            this._currentTickState.isAborted ||
            !this._currentTickCompleteState ||
            this._currentTickCompleteState.isAborted) &&
            this.initDelayedCursor();
        },
        insertNewlineStyleObject: function (s, u, d, l) {
          var c,
            h = {},
            m = !1,
            g = this._unwrappedTextLines[s].length === u;
          d || (d = 1),
            this.shiftLineStyles(s, d),
            this.styles[s] && (c = this.styles[s][u === 0 ? u : u - 1]);
          for (var f in this.styles[s]) {
            var v = parseInt(f, 10);
            v >= u &&
              ((m = !0),
              (h[v - u] = this.styles[s][f]),
              (g && u === 0) || delete this.styles[s][f]);
          }
          var y = !1;
          for (
            m && !g && ((this.styles[s + d] = h), (y = !0)), y && d--;
            d > 0;

          )
            l && l[d - 1]
              ? (this.styles[s + d] = { 0: a(l[d - 1]) })
              : c
              ? (this.styles[s + d] = { 0: a(c) })
              : delete this.styles[s + d],
              d--;
          this._forceClearCache = !0;
        },
        insertCharStyleObject: function (s, u, d, l) {
          this.styles || (this.styles = {});
          var c = this.styles[s],
            h = c ? a(c) : {};
          d || (d = 1);
          for (var m in h) {
            var g = parseInt(m, 10);
            g >= u && ((c[g + d] = h[g]), h[g - d] || delete c[g]);
          }
          if (((this._forceClearCache = !0), l)) {
            for (; d--; )
              Object.keys(l[d]).length &&
                (this.styles[s] || (this.styles[s] = {}),
                (this.styles[s][u + d] = a(l[d])));
            return;
          }
          if (c)
            for (var f = c[u ? u - 1 : 1]; f && d--; )
              this.styles[s][u + d] = a(f);
        },
        insertNewStyleBlock: function (s, u, d) {
          for (
            var l = this.get2DCursorLocation(u, !0), c = [0], h = 0, m = 0;
            m < s.length;
            m++
          )
            s[m] ===
            `
`
              ? (h++, (c[h] = 0))
              : c[h]++;
          c[0] > 0 &&
            (this.insertCharStyleObject(l.lineIndex, l.charIndex, c[0], d),
            (d = d && d.slice(c[0] + 1))),
            h &&
              this.insertNewlineStyleObject(l.lineIndex, l.charIndex + c[0], h);
          for (var m = 1; m < h; m++)
            c[m] > 0
              ? this.insertCharStyleObject(l.lineIndex + m, 0, c[m], d)
              : d &&
                this.styles[l.lineIndex + m] &&
                d[0] &&
                (this.styles[l.lineIndex + m][0] = d[0]),
              (d = d && d.slice(c[m] + 1));
          c[m] > 0 && this.insertCharStyleObject(l.lineIndex + m, 0, c[m], d);
        },
        setSelectionStartEndWithShift: function (s, u, d) {
          d <= s
            ? (u === s
                ? (this._selectionDirection = "left")
                : this._selectionDirection === "right" &&
                  ((this._selectionDirection = "left"),
                  (this.selectionEnd = s)),
              (this.selectionStart = d))
            : d > s && d < u
            ? this._selectionDirection === "right"
              ? (this.selectionEnd = d)
              : (this.selectionStart = d)
            : (u === s
                ? (this._selectionDirection = "right")
                : this._selectionDirection === "left" &&
                  ((this._selectionDirection = "right"),
                  (this.selectionStart = u)),
              (this.selectionEnd = d));
        },
        setSelectionInBoundaries: function () {
          var s = this.text.length;
          this.selectionStart > s
            ? (this.selectionStart = s)
            : this.selectionStart < 0 && (this.selectionStart = 0),
            this.selectionEnd > s
              ? (this.selectionEnd = s)
              : this.selectionEnd < 0 && (this.selectionEnd = 0);
        },
      });
    })(),
    e.util.object.extend(e.IText.prototype, {
      initDoubleClickSimulation: function () {
        (this.__lastClickTime = +new Date()),
          (this.__lastLastClickTime = +new Date()),
          (this.__lastPointer = {}),
          this.on("mousedown", this.onMouseDown);
      },
      onMouseDown: function (a) {
        if (this.canvas) {
          this.__newClickTime = +new Date();
          var s = a.pointer;
          this.isTripleClick(s) &&
            (this.fire("tripleclick", a), this._stopEvent(a.e)),
            (this.__lastLastClickTime = this.__lastClickTime),
            (this.__lastClickTime = this.__newClickTime),
            (this.__lastPointer = s),
            (this.__lastIsEditing = this.isEditing),
            (this.__lastSelected = this.selected);
        }
      },
      isTripleClick: function (a) {
        return (
          this.__newClickTime - this.__lastClickTime < 500 &&
          this.__lastClickTime - this.__lastLastClickTime < 500 &&
          this.__lastPointer.x === a.x &&
          this.__lastPointer.y === a.y
        );
      },
      _stopEvent: function (a) {
        a.preventDefault && a.preventDefault(),
          a.stopPropagation && a.stopPropagation();
      },
      initCursorSelectionHandlers: function () {
        this.initMousedownHandler(),
          this.initMouseupHandler(),
          this.initClicks();
      },
      doubleClickHandler: function (a) {
        this.isEditing &&
          this.selectWord(this.getSelectionStartFromPointer(a.e));
      },
      tripleClickHandler: function (a) {
        this.isEditing &&
          this.selectLine(this.getSelectionStartFromPointer(a.e));
      },
      initClicks: function () {
        this.on("mousedblclick", this.doubleClickHandler),
          this.on("tripleclick", this.tripleClickHandler);
      },
      _mouseDownHandler: function (a) {
        !this.canvas ||
          !this.editable ||
          (a.e.button && a.e.button !== 1) ||
          ((this.__isMousedown = !0),
          this.selected &&
            ((this.inCompositionMode = !1), this.setCursorByClick(a.e)),
          this.isEditing &&
            ((this.__selectionStartOnMouseDown = this.selectionStart),
            this.selectionStart === this.selectionEnd &&
              this.abortCursorAnimation(),
            this.renderCursorOrSelection()));
      },
      _mouseDownHandlerBefore: function (a) {
        !this.canvas ||
          !this.editable ||
          (a.e.button && a.e.button !== 1) ||
          (this.selected = this === this.canvas._activeObject);
      },
      initMousedownHandler: function () {
        this.on("mousedown", this._mouseDownHandler),
          this.on("mousedown:before", this._mouseDownHandlerBefore);
      },
      initMouseupHandler: function () {
        this.on("mouseup", this.mouseUpHandler);
      },
      mouseUpHandler: function (a) {
        if (
          ((this.__isMousedown = !1),
          !(
            !this.editable ||
            this.group ||
            (a.transform && a.transform.actionPerformed) ||
            (a.e.button && a.e.button !== 1)
          ))
        ) {
          if (this.canvas) {
            var s = this.canvas._activeObject;
            if (s && s !== this) return;
          }
          this.__lastSelected && !this.__corner
            ? ((this.selected = !1),
              (this.__lastSelected = !1),
              this.enterEditing(a.e),
              this.selectionStart === this.selectionEnd
                ? this.initDelayedCursor(!0)
                : this.renderCursorOrSelection())
            : (this.selected = !0);
        }
      },
      setCursorByClick: function (a) {
        var s = this.getSelectionStartFromPointer(a),
          u = this.selectionStart,
          d = this.selectionEnd;
        a.shiftKey
          ? this.setSelectionStartEndWithShift(u, d, s)
          : ((this.selectionStart = s), (this.selectionEnd = s)),
          this.isEditing &&
            (this._fireSelectionChanged(), this._updateTextarea());
      },
      getSelectionStartFromPointer: function (a) {
        for (
          var s = this.getLocalPointer(a),
            u = 0,
            d = 0,
            l = 0,
            c = 0,
            h = 0,
            m,
            g,
            f = 0,
            v = this._textLines.length;
          f < v && l <= s.y;
          f++
        )
          (l += this.getHeightOfLine(f) * this.scaleY),
            (h = f),
            f > 0 &&
              (c +=
                this._textLines[f - 1].length +
                this.missingNewlineOffset(f - 1));
        (m = this._getLineLeftOffset(h)),
          (d = m * this.scaleX),
          (g = this._textLines[h]),
          this.direction === "rtl" &&
            (s.x = this.width * this.scaleX - s.x + d);
        for (
          var y = 0, _ = g.length;
          y < _ &&
          ((u = d),
          (d += this.__charBounds[h][y].kernedWidth * this.scaleX),
          d <= s.x);
          y++
        )
          c++;
        return this._getNewSelectionStartFromOffset(s, u, d, c, _);
      },
      _getNewSelectionStartFromOffset: function (a, s, u, d, l) {
        var c = a.x - s,
          h = u - a.x,
          m = h > c || h < 0 ? 0 : 1,
          g = d + m;
        return (
          this.flipX && (g = l - g),
          g > this._text.length && (g = this._text.length),
          g
        );
      },
    }),
    e.util.object.extend(e.IText.prototype, {
      initHiddenTextarea: function () {
        (this.hiddenTextarea = e.document.createElement("textarea")),
          this.hiddenTextarea.setAttribute("autocapitalize", "off"),
          this.hiddenTextarea.setAttribute("autocorrect", "off"),
          this.hiddenTextarea.setAttribute("autocomplete", "off"),
          this.hiddenTextarea.setAttribute("spellcheck", "false"),
          this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""),
          this.hiddenTextarea.setAttribute("wrap", "off");
        var a = this._calcTextareaPosition();
        (this.hiddenTextarea.style.cssText =
          "position: absolute; top: " +
          a.top +
          "; left: " +
          a.left +
          "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: " +
          a.fontSize +
          ";"),
          this.hiddenTextareaContainer
            ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea)
            : e.document.body.appendChild(this.hiddenTextarea),
          e.util.addListener(
            this.hiddenTextarea,
            "keydown",
            this.onKeyDown.bind(this)
          ),
          e.util.addListener(
            this.hiddenTextarea,
            "keyup",
            this.onKeyUp.bind(this)
          ),
          e.util.addListener(
            this.hiddenTextarea,
            "input",
            this.onInput.bind(this)
          ),
          e.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)),
          e.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)),
          e.util.addListener(
            this.hiddenTextarea,
            "paste",
            this.paste.bind(this)
          ),
          e.util.addListener(
            this.hiddenTextarea,
            "compositionstart",
            this.onCompositionStart.bind(this)
          ),
          e.util.addListener(
            this.hiddenTextarea,
            "compositionupdate",
            this.onCompositionUpdate.bind(this)
          ),
          e.util.addListener(
            this.hiddenTextarea,
            "compositionend",
            this.onCompositionEnd.bind(this)
          ),
          !this._clickHandlerInitialized &&
            this.canvas &&
            (e.util.addListener(
              this.canvas.upperCanvasEl,
              "click",
              this.onClick.bind(this)
            ),
            (this._clickHandlerInitialized = !0));
      },
      keysMap: {
        9: "exitEditing",
        27: "exitEditing",
        33: "moveCursorUp",
        34: "moveCursorDown",
        35: "moveCursorRight",
        36: "moveCursorLeft",
        37: "moveCursorLeft",
        38: "moveCursorUp",
        39: "moveCursorRight",
        40: "moveCursorDown",
      },
      keysMapRtl: {
        9: "exitEditing",
        27: "exitEditing",
        33: "moveCursorUp",
        34: "moveCursorDown",
        35: "moveCursorLeft",
        36: "moveCursorRight",
        37: "moveCursorRight",
        38: "moveCursorUp",
        39: "moveCursorLeft",
        40: "moveCursorDown",
      },
      ctrlKeysMapUp: { 67: "copy", 88: "cut" },
      ctrlKeysMapDown: { 65: "selectAll" },
      onClick: function () {
        this.hiddenTextarea && this.hiddenTextarea.focus();
      },
      onKeyDown: function (a) {
        if (this.isEditing) {
          var s = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
          if (a.keyCode in s) this[s[a.keyCode]](a);
          else if (
            a.keyCode in this.ctrlKeysMapDown &&
            (a.ctrlKey || a.metaKey)
          )
            this[this.ctrlKeysMapDown[a.keyCode]](a);
          else return;
          a.stopImmediatePropagation(),
            a.preventDefault(),
            a.keyCode >= 33 && a.keyCode <= 40
              ? ((this.inCompositionMode = !1),
                this.clearContextTop(),
                this.renderCursorOrSelection())
              : this.canvas && this.canvas.requestRenderAll();
        }
      },
      onKeyUp: function (a) {
        if (!this.isEditing || this._copyDone || this.inCompositionMode) {
          this._copyDone = !1;
          return;
        }
        if (a.keyCode in this.ctrlKeysMapUp && (a.ctrlKey || a.metaKey))
          this[this.ctrlKeysMapUp[a.keyCode]](a);
        else return;
        a.stopImmediatePropagation(),
          a.preventDefault(),
          this.canvas && this.canvas.requestRenderAll();
      },
      onInput: function (a) {
        var s = this.fromPaste;
        if (
          ((this.fromPaste = !1), a && a.stopPropagation(), !!this.isEditing)
        ) {
          var u = this._splitTextIntoLines(
              this.hiddenTextarea.value
            ).graphemeText,
            d = this._text.length,
            l = u.length,
            c,
            h,
            m = l - d,
            g = this.selectionStart,
            f = this.selectionEnd,
            v = g !== f,
            y,
            _,
            x;
          if (this.hiddenTextarea.value === "") {
            (this.styles = {}),
              this.updateFromTextArea(),
              this.fire("changed"),
              this.canvas &&
                (this.canvas.fire("text:changed", { target: this }),
                this.canvas.requestRenderAll());
            return;
          }
          var b = this.fromStringToGraphemeSelection(
              this.hiddenTextarea.selectionStart,
              this.hiddenTextarea.selectionEnd,
              this.hiddenTextarea.value
            ),
            S = g > b.selectionStart;
          v
            ? ((c = this._text.slice(g, f)), (m += f - g))
            : l < d &&
              (S
                ? (c = this._text.slice(f + m, f))
                : (c = this._text.slice(g, g - m))),
            (h = u.slice(b.selectionEnd - m, b.selectionEnd)),
            c &&
              c.length &&
              (h.length &&
                ((y = this.getSelectionStyles(g, g + 1, !1)),
                (y = h.map(function () {
                  return y[0];
                }))),
              v
                ? ((_ = g), (x = f))
                : S
                ? ((_ = f - c.length), (x = f))
                : ((_ = f), (x = f + c.length)),
              this.removeStyleFromTo(_, x)),
            h.length &&
              (s &&
                h.join("") === e.copiedText &&
                !e.disableStyleCopyPaste &&
                (y = e.copiedTextStyle),
              this.insertNewStyleBlock(h, g, y)),
            this.updateFromTextArea(),
            this.fire("changed"),
            this.canvas &&
              (this.canvas.fire("text:changed", { target: this }),
              this.canvas.requestRenderAll());
        }
      },
      onCompositionStart: function () {
        this.inCompositionMode = !0;
      },
      onCompositionEnd: function () {
        this.inCompositionMode = !1;
      },
      onCompositionUpdate: function (a) {
        (this.compositionStart = a.target.selectionStart),
          (this.compositionEnd = a.target.selectionEnd),
          this.updateTextareaPosition();
      },
      copy: function () {
        this.selectionStart !== this.selectionEnd &&
          ((e.copiedText = this.getSelectedText()),
          e.disableStyleCopyPaste
            ? (e.copiedTextStyle = null)
            : (e.copiedTextStyle = this.getSelectionStyles(
                this.selectionStart,
                this.selectionEnd,
                !0
              )),
          (this._copyDone = !0));
      },
      paste: function () {
        this.fromPaste = !0;
      },
      _getClipboardData: function (a) {
        return (a && a.clipboardData) || e.window.clipboardData;
      },
      _getWidthBeforeCursor: function (a, s) {
        var u = this._getLineLeftOffset(a),
          d;
        return (
          s > 0 && ((d = this.__charBounds[a][s - 1]), (u += d.left + d.width)),
          u
        );
      },
      getDownCursorOffset: function (a, s) {
        var u = this._getSelectionForOffset(a, s),
          d = this.get2DCursorLocation(u),
          l = d.lineIndex;
        if (l === this._textLines.length - 1 || a.metaKey || a.keyCode === 34)
          return this._text.length - u;
        var c = d.charIndex,
          h = this._getWidthBeforeCursor(l, c),
          m = this._getIndexOnLine(l + 1, h),
          g = this._textLines[l].slice(c);
        return g.length + m + 1 + this.missingNewlineOffset(l);
      },
      _getSelectionForOffset: function (a, s) {
        return a.shiftKey && this.selectionStart !== this.selectionEnd && s
          ? this.selectionEnd
          : this.selectionStart;
      },
      getUpCursorOffset: function (a, s) {
        var u = this._getSelectionForOffset(a, s),
          d = this.get2DCursorLocation(u),
          l = d.lineIndex;
        if (l === 0 || a.metaKey || a.keyCode === 33) return -u;
        var c = d.charIndex,
          h = this._getWidthBeforeCursor(l, c),
          m = this._getIndexOnLine(l - 1, h),
          g = this._textLines[l].slice(0, c),
          f = this.missingNewlineOffset(l - 1);
        return -this._textLines[l - 1].length + m - g.length + (1 - f);
      },
      _getIndexOnLine: function (a, s) {
        for (
          var u = this._textLines[a],
            d = this._getLineLeftOffset(a),
            l = d,
            c = 0,
            h,
            m,
            g = 0,
            f = u.length;
          g < f;
          g++
        )
          if (((h = this.__charBounds[a][g].width), (l += h), l > s)) {
            m = !0;
            var v = l - h,
              y = l,
              _ = Math.abs(v - s),
              x = Math.abs(y - s);
            c = x < _ ? g : g - 1;
            break;
          }
        return m || (c = u.length - 1), c;
      },
      moveCursorDown: function (a) {
        (this.selectionStart >= this._text.length &&
          this.selectionEnd >= this._text.length) ||
          this._moveCursorUpOrDown("Down", a);
      },
      moveCursorUp: function (a) {
        (this.selectionStart === 0 && this.selectionEnd === 0) ||
          this._moveCursorUpOrDown("Up", a);
      },
      _moveCursorUpOrDown: function (a, s) {
        var u = "get" + a + "CursorOffset",
          d = this[u](s, this._selectionDirection === "right");
        s.shiftKey
          ? this.moveCursorWithShift(d)
          : this.moveCursorWithoutShift(d),
          d !== 0 &&
            (this.setSelectionInBoundaries(),
            this.abortCursorAnimation(),
            (this._currentCursorOpacity = 1),
            this.initDelayedCursor(),
            this._fireSelectionChanged(),
            this._updateTextarea());
      },
      moveCursorWithShift: function (a) {
        var s =
          this._selectionDirection === "left"
            ? this.selectionStart + a
            : this.selectionEnd + a;
        return (
          this.setSelectionStartEndWithShift(
            this.selectionStart,
            this.selectionEnd,
            s
          ),
          a !== 0
        );
      },
      moveCursorWithoutShift: function (a) {
        return (
          a < 0
            ? ((this.selectionStart += a),
              (this.selectionEnd = this.selectionStart))
            : ((this.selectionEnd += a),
              (this.selectionStart = this.selectionEnd)),
          a !== 0
        );
      },
      moveCursorLeft: function (a) {
        (this.selectionStart === 0 && this.selectionEnd === 0) ||
          this._moveCursorLeftOrRight("Left", a);
      },
      _move: function (a, s, u) {
        var d;
        if (a.altKey) d = this["findWordBoundary" + u](this[s]);
        else if (a.metaKey || a.keyCode === 35 || a.keyCode === 36)
          d = this["findLineBoundary" + u](this[s]);
        else return (this[s] += u === "Left" ? -1 : 1), !0;
        if (typeof d < "u" && this[s] !== d) return (this[s] = d), !0;
      },
      _moveLeft: function (a, s) {
        return this._move(a, s, "Left");
      },
      _moveRight: function (a, s) {
        return this._move(a, s, "Right");
      },
      moveCursorLeftWithoutShift: function (a) {
        var s = !0;
        return (
          (this._selectionDirection = "left"),
          this.selectionEnd === this.selectionStart &&
            this.selectionStart !== 0 &&
            (s = this._moveLeft(a, "selectionStart")),
          (this.selectionEnd = this.selectionStart),
          s
        );
      },
      moveCursorLeftWithShift: function (a) {
        if (
          this._selectionDirection === "right" &&
          this.selectionStart !== this.selectionEnd
        )
          return this._moveLeft(a, "selectionEnd");
        if (this.selectionStart !== 0)
          return (
            (this._selectionDirection = "left"),
            this._moveLeft(a, "selectionStart")
          );
      },
      moveCursorRight: function (a) {
        (this.selectionStart >= this._text.length &&
          this.selectionEnd >= this._text.length) ||
          this._moveCursorLeftOrRight("Right", a);
      },
      _moveCursorLeftOrRight: function (a, s) {
        var u = "moveCursor" + a + "With";
        (this._currentCursorOpacity = 1),
          s.shiftKey ? (u += "Shift") : (u += "outShift"),
          this[u](s) &&
            (this.abortCursorAnimation(),
            this.initDelayedCursor(),
            this._fireSelectionChanged(),
            this._updateTextarea());
      },
      moveCursorRightWithShift: function (a) {
        if (
          this._selectionDirection === "left" &&
          this.selectionStart !== this.selectionEnd
        )
          return this._moveRight(a, "selectionStart");
        if (this.selectionEnd !== this._text.length)
          return (
            (this._selectionDirection = "right"),
            this._moveRight(a, "selectionEnd")
          );
      },
      moveCursorRightWithoutShift: function (a) {
        var s = !0;
        return (
          (this._selectionDirection = "right"),
          this.selectionStart === this.selectionEnd
            ? ((s = this._moveRight(a, "selectionStart")),
              (this.selectionEnd = this.selectionStart))
            : (this.selectionStart = this.selectionEnd),
          s
        );
      },
      removeChars: function (a, s) {
        typeof s > "u" && (s = a + 1),
          this.removeStyleFromTo(a, s),
          this._text.splice(a, s - a),
          (this.text = this._text.join("")),
          this.set("dirty", !0),
          this._shouldClearDimensionCache() &&
            (this.initDimensions(), this.setCoords()),
          this._removeExtraneousStyles();
      },
      insertChars: function (a, s, u, d) {
        typeof d > "u" && (d = u), d > u && this.removeStyleFromTo(u, d);
        var l = e.util.string.graphemeSplit(a);
        this.insertNewStyleBlock(l, u, s),
          (this._text = [].concat(
            this._text.slice(0, u),
            l,
            this._text.slice(d)
          )),
          (this.text = this._text.join("")),
          this.set("dirty", !0),
          this._shouldClearDimensionCache() &&
            (this.initDimensions(), this.setCoords()),
          this._removeExtraneousStyles();
      },
    }),
    (function () {
      var a = e.util.toFixed,
        s = /  +/g;
      e.util.object.extend(e.Text.prototype, {
        _toSVG: function () {
          var u = this._getSVGLeftTopOffsets(),
            d = this._getSVGTextAndBg(u.textTop, u.textLeft);
          return this._wrapSVGTextAndBg(d);
        },
        toSVG: function (u) {
          return this._createBaseSVGMarkup(this._toSVG(), {
            reviver: u,
            noStyle: !0,
            withShadow: !0,
          });
        },
        _getSVGLeftTopOffsets: function () {
          return {
            textLeft: -this.width / 2,
            textTop: -this.height / 2,
            lineTop: this.getHeightOfLine(0),
          };
        },
        _wrapSVGTextAndBg: function (u) {
          var d = !0,
            l = this.getSvgTextDecoration(this);
          return [
            u.textBgRects.join(""),
            '		<text xml:space="preserve" ',
            this.fontFamily
              ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" '
              : "",
            this.fontSize ? 'font-size="' + this.fontSize + '" ' : "",
            this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "",
            this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "",
            l ? 'text-decoration="' + l + '" ' : "",
            'style="',
            this.getSvgStyles(d),
            '"',
            this.addPaintOrder(),
            " >",
            u.textSpans.join(""),
            `</text>
`,
          ];
        },
        _getSVGTextAndBg: function (u, d) {
          var l = [],
            c = [],
            h = u,
            m;
          this._setSVGBg(c);
          for (var g = 0, f = this._textLines.length; g < f; g++)
            (m = this._getLineLeftOffset(g)),
              (this.textBackgroundColor ||
                this.styleHas("textBackgroundColor", g)) &&
                this._setSVGTextLineBg(c, g, d + m, h),
              this._setSVGTextLineText(l, g, d + m, h),
              (h += this.getHeightOfLine(g));
          return { textSpans: l, textBgRects: c };
        },
        _createTextCharSpan: function (u, d, l, c) {
          var h = u !== u.trim() || u.match(s),
            m = this.getSvgSpanStyles(d, h),
            g = m ? 'style="' + m + '"' : "",
            f = d.deltaY,
            v = "",
            y = e.Object.NUM_FRACTION_DIGITS;
          return (
            f && (v = ' dy="' + a(f, y) + '" '),
            [
              '<tspan x="',
              a(l, y),
              '" y="',
              a(c, y),
              '" ',
              v,
              g,
              ">",
              e.util.string.escapeXml(u),
              "</tspan>",
            ].join("")
          );
        },
        _setSVGTextLineText: function (u, d, l, c) {
          var h = this.getHeightOfLine(d),
            m = this.textAlign.indexOf("justify") !== -1,
            g,
            f,
            v = "",
            y,
            _,
            x = 0,
            b = this._textLines[d],
            S;
          c += (h * (1 - this._fontSizeFraction)) / this.lineHeight;
          for (var T = 0, w = b.length - 1; T <= w; T++)
            (S = T === w || this.charSpacing),
              (v += b[T]),
              (y = this.__charBounds[d][T]),
              x === 0
                ? ((l += y.kernedWidth - y.width), (x += y.width))
                : (x += y.kernedWidth),
              m && !S && this._reSpaceAndTab.test(b[T]) && (S = !0),
              S ||
                ((g = g || this.getCompleteStyleDeclaration(d, T)),
                (f = this.getCompleteStyleDeclaration(d, T + 1)),
                (S = e.util.hasStyleChanged(g, f, !0))),
              S &&
                ((_ = this._getStyleDeclaration(d, T) || {}),
                u.push(this._createTextCharSpan(v, _, l, c)),
                (v = ""),
                (g = f),
                (l += x),
                (x = 0));
        },
        _pushTextBgRect: function (u, d, l, c, h, m) {
          var g = e.Object.NUM_FRACTION_DIGITS;
          u.push(
            "		<rect ",
            this._getFillAttributes(d),
            ' x="',
            a(l, g),
            '" y="',
            a(c, g),
            '" width="',
            a(h, g),
            '" height="',
            a(m, g),
            `"></rect>
`
          );
        },
        _setSVGTextLineBg: function (u, d, l, c) {
          for (
            var h = this._textLines[d],
              m = this.getHeightOfLine(d) / this.lineHeight,
              g = 0,
              f = 0,
              v,
              y,
              _ = this.getValueOfPropertyAt(d, 0, "textBackgroundColor"),
              x = 0,
              b = h.length;
            x < b;
            x++
          )
            (v = this.__charBounds[d][x]),
              (y = this.getValueOfPropertyAt(d, x, "textBackgroundColor")),
              y !== _
                ? (_ && this._pushTextBgRect(u, _, l + f, c, g, m),
                  (f = v.left),
                  (g = v.width),
                  (_ = y))
                : (g += v.kernedWidth);
          y && this._pushTextBgRect(u, y, l + f, c, g, m);
        },
        _getFillAttributes: function (u) {
          var d = u && typeof u == "string" ? new e.Color(u) : "";
          return !d || !d.getSource() || d.getAlpha() === 1
            ? 'fill="' + u + '"'
            : 'opacity="' +
                d.getAlpha() +
                '" fill="' +
                d.setAlpha(1).toRgb() +
                '"';
        },
        _getSVGLineTopOffset: function (u) {
          for (var d = 0, l = 0, c = 0; c < u; c++)
            d += this.getHeightOfLine(c);
          return (
            (l = this.getHeightOfLine(c)),
            {
              lineTop: d,
              offset:
                ((this._fontSizeMult - this._fontSizeFraction) * l) /
                (this.lineHeight * this._fontSizeMult),
            }
          );
        },
        getSvgStyles: function (u) {
          var d = e.Object.prototype.getSvgStyles.call(this, u);
          return d + " white-space: pre;";
        },
      });
    })(),
    (function (a) {
      var s = a.fabric || (a.fabric = {});
      (s.Textbox = s.util.createClass(s.IText, s.Observable, {
        type: "textbox",
        minWidth: 20,
        dynamicMinWidth: 2,
        __cachedLines: null,
        lockScalingFlip: !0,
        noScaleCache: !1,
        _dimensionAffectingProps:
          s.Text.prototype._dimensionAffectingProps.concat("width"),
        _wordJoiners: /[ \t\r]/,
        splitByGrapheme: !1,
        initDimensions: function () {
          this.__skipDimension ||
            (this.isEditing && this.initDelayedCursor(),
            this.clearContextTop(),
            this._clearCache(),
            (this.dynamicMinWidth = 0),
            (this._styleMap = this._generateStyleMap(this._splitText())),
            this.dynamicMinWidth > this.width &&
              this._set("width", this.dynamicMinWidth),
            this.textAlign.indexOf("justify") !== -1 && this.enlargeSpaces(),
            (this.height = this.calcTextHeight()),
            this.saveState({ propertySet: "_dimensionAffectingProps" }));
        },
        _generateStyleMap: function (u) {
          for (
            var d = 0, l = 0, c = 0, h = {}, m = 0;
            m < u.graphemeLines.length;
            m++
          )
            u.graphemeText[c] ===
              `
` && m > 0
              ? ((l = 0), c++, d++)
              : !this.splitByGrapheme &&
                this._reSpaceAndTab.test(u.graphemeText[c]) &&
                m > 0 &&
                (l++, c++),
              (h[m] = { line: d, offset: l }),
              (c += u.graphemeLines[m].length),
              (l += u.graphemeLines[m].length);
          return h;
        },
        styleHas: function (u, d) {
          if (this._styleMap && !this.isWrapping) {
            var l = this._styleMap[d];
            l && (d = l.line);
          }
          return s.Text.prototype.styleHas.call(this, u, d);
        },
        isEmptyStyles: function (u) {
          if (!this.styles) return !0;
          var d = 0,
            l = u + 1,
            c,
            h,
            m = !1,
            g = this._styleMap[u],
            f = this._styleMap[u + 1];
          g && ((u = g.line), (d = g.offset)),
            f && ((l = f.line), (m = l === u), (c = f.offset)),
            (h = typeof u > "u" ? this.styles : { line: this.styles[u] });
          for (var v in h)
            for (var y in h[v])
              if (y >= d && (!m || y < c)) for (var _ in h[v][y]) return !1;
          return !0;
        },
        _getStyleDeclaration: function (u, d) {
          if (this._styleMap && !this.isWrapping) {
            var l = this._styleMap[u];
            if (!l) return null;
            (u = l.line), (d = l.offset + d);
          }
          return this.callSuper("_getStyleDeclaration", u, d);
        },
        _setStyleDeclaration: function (u, d, l) {
          var c = this._styleMap[u];
          (u = c.line), (d = c.offset + d), (this.styles[u][d] = l);
        },
        _deleteStyleDeclaration: function (u, d) {
          var l = this._styleMap[u];
          (u = l.line), (d = l.offset + d), delete this.styles[u][d];
        },
        _getLineStyle: function (u) {
          var d = this._styleMap[u];
          return !!this.styles[d.line];
        },
        _setLineStyle: function (u) {
          var d = this._styleMap[u];
          this.styles[d.line] = {};
        },
        _wrapText: function (u, d) {
          var l = [],
            c;
          for (this.isWrapping = !0, c = 0; c < u.length; c++)
            l = l.concat(this._wrapLine(u[c], c, d));
          return (this.isWrapping = !1), l;
        },
        _measureWord: function (u, d, l) {
          var c = 0,
            h,
            m = !0;
          l = l || 0;
          for (var g = 0, f = u.length; g < f; g++) {
            var v = this._getGraphemeBox(u[g], d, g + l, h, m);
            (c += v.kernedWidth), (h = u[g]);
          }
          return c;
        },
        _wrapLine: function (u, d, l, F) {
          var h = 0,
            m = this.splitByGrapheme,
            g = [],
            f = [],
            v = m ? s.util.string.graphemeSplit(u) : u.split(this._wordJoiners),
            y = "",
            _ = 0,
            x = m ? "" : " ",
            b = 0,
            S = 0,
            T = 0,
            w = !0,
            P = this._getWidthOfCharSpacing(),
            F = F || 0;
          v.length === 0 && v.push([]), (l -= F);
          for (var V = 0; V < v.length; V++)
            (y = m ? v[V] : s.util.string.graphemeSplit(v[V])),
              (b = this._measureWord(y, d, _)),
              (_ += y.length),
              (h += S + b - P),
              h > l && !w ? (g.push(f), (f = []), (h = b), (w = !0)) : (h += P),
              !w && !m && f.push(x),
              (f = f.concat(y)),
              (S = m ? 0 : this._measureWord([x], d, _)),
              _++,
              (w = !1),
              b > T && (T = b);
          return (
            V && g.push(f),
            T + F > this.dynamicMinWidth && (this.dynamicMinWidth = T - P + F),
            g
          );
        },
        isEndOfWrapping: function (u) {
          return (
            !this._styleMap[u + 1] ||
            this._styleMap[u + 1].line !== this._styleMap[u].line
          );
        },
        missingNewlineOffset: function (u) {
          return this.splitByGrapheme ? (this.isEndOfWrapping(u) ? 1 : 0) : 1;
        },
        _splitTextIntoLines: function (u) {
          for (
            var d = s.Text.prototype._splitTextIntoLines.call(this, u),
              l = this._wrapText(d.lines, this.width),
              c = new Array(l.length),
              h = 0;
            h < l.length;
            h++
          )
            c[h] = l[h].join("");
          return (d.lines = c), (d.graphemeLines = l), d;
        },
        getMinWidth: function () {
          return Math.max(this.minWidth, this.dynamicMinWidth);
        },
        _removeExtraneousStyles: function () {
          var u = {};
          for (var d in this._styleMap)
            this._textLines[d] && (u[this._styleMap[d].line] = 1);
          for (var d in this.styles) u[d] || delete this.styles[d];
        },
        toObject: function (u) {
          return this.callSuper(
            "toObject",
            ["minWidth", "splitByGrapheme"].concat(u)
          );
        },
      })),
        (s.Textbox.fromObject = function (u, d) {
          var l = s.util.stylesFromArray(u.styles, u.text),
            c = Object.assign({}, u, { styles: l });
          return s.Object._fromObject("Textbox", c, d, "text");
        });
    })(n),
    (function () {
      var a = e.controlsUtils,
        s = a.scaleSkewCursorStyleHandler,
        u = a.scaleCursorStyleHandler,
        d = a.scalingEqually,
        l = a.scalingYOrSkewingX,
        c = a.scalingXOrSkewingY,
        h = a.scaleOrSkewActionName,
        m = e.Object.prototype.controls;
      if (
        ((m.ml = new e.Control({
          x: -0.5,
          y: 0,
          cursorStyleHandler: s,
          actionHandler: c,
          getActionName: h,
        })),
        (m.mr = new e.Control({
          x: 0.5,
          y: 0,
          cursorStyleHandler: s,
          actionHandler: c,
          getActionName: h,
        })),
        (m.mb = new e.Control({
          x: 0,
          y: 0.5,
          cursorStyleHandler: s,
          actionHandler: l,
          getActionName: h,
        })),
        (m.mt = new e.Control({
          x: 0,
          y: -0.5,
          cursorStyleHandler: s,
          actionHandler: l,
          getActionName: h,
        })),
        (m.tl = new e.Control({
          x: -0.5,
          y: -0.5,
          cursorStyleHandler: u,
          actionHandler: d,
        })),
        (m.tr = new e.Control({
          x: 0.5,
          y: -0.5,
          cursorStyleHandler: u,
          actionHandler: d,
        })),
        (m.bl = new e.Control({
          x: -0.5,
          y: 0.5,
          cursorStyleHandler: u,
          actionHandler: d,
        })),
        (m.br = new e.Control({
          x: 0.5,
          y: 0.5,
          cursorStyleHandler: u,
          actionHandler: d,
        })),
        (m.mtr = new e.Control({
          x: 0,
          y: -0.5,
          actionHandler: a.rotationWithSnapping,
          cursorStyleHandler: a.rotationStyleHandler,
          offsetY: -40,
          withConnection: !0,
          actionName: "rotate",
        })),
        e.Textbox)
      ) {
        var g = (e.Textbox.prototype.controls = {});
        (g.mtr = m.mtr),
          (g.tr = m.tr),
          (g.br = m.br),
          (g.tl = m.tl),
          (g.bl = m.bl),
          (g.mt = m.mt),
          (g.mb = m.mb),
          (g.mr = new e.Control({
            x: 0.5,
            y: 0,
            actionHandler: a.changeWidth,
            cursorStyleHandler: s,
            actionName: "resizing",
          })),
          (g.ml = new e.Control({
            x: -0.5,
            y: 0,
            actionHandler: a.changeWidth,
            cursorStyleHandler: s,
            actionName: "resizing",
          }));
      }
    })();
})(gm);
class BL {
  constructor({ el: e, images: t, updateCanvas: i }) {
    Fe(this, "id");
    Fe(this, "meshId");
    Fe(this, "textureId");
    Fe(this, "canvasDom", document.createElement("canvas"));
    Fe(this, "fabricCanvas");
    Fe(this, "images");
    Fe(this, "widgets", []);
    Fe(this, "updateCanvas");
    (typeof e == "string" ? document.getElementById(e) : e).append(
      this.canvasDom
    ),
      (this.fabricCanvas = new gm.fabric.Canvas(this.canvasDom)),
      this.fabricCanvas.on("mouse:up", (r) => {
        console.log("mouse:up", r), i();
      }),
      (this.images = t),
      (this.updateCanvas = i);
  }
  async initCanvasImages() {
    const {
      overlayImageSrc: e,
      backgroundColor: t,
      backgroundImageSrc: i,
    } = this.images;
    if (e) {
      const r = await Cc(e);
      this.fabricCanvas.setWidth(r.width, { backstoreOnly: !0 }),
        this.fabricCanvas.setHeight(r.height, { backstoreOnly: !0 }),
        this.fabricCanvas.setOverlayImage(
          r,
          this.fabricCanvas.renderAll.bind(this.fabricCanvas)
        );
    }
    if (i) {
      const r = await Cc(i);
      this.fabricCanvas.setBackgroundImage(
        r,
        this.fabricCanvas.renderAll.bind(this.fabricCanvas)
      );
    }
    t &&
      this.fabricCanvas.setBackgroundColor(
        t,
        this.fabricCanvas.renderAll.bind(this.fabricCanvas)
      );
  }
  async addImage(e) {
    const t = await Cc(e);
    t.on("moving", (i) => {
      console.log("image moving", i), this.updateCanvas();
    }),
      this.fabricCanvas.add(t),
      this.updateCanvas();
  }
  async setBackgroundImage(e) {
    const t = await Cc(e);
    this.fabricCanvas.setBackgroundImage(
      t,
      this.fabricCanvas.renderAll.bind(this.fabricCanvas)
    );
  }
  setBackgroundColor(e) {
    this.fabricCanvas.setBackgroundColor(
      e,
      this.fabricCanvas.renderAll.bind(this.fabricCanvas)
    );
  }
}
async function Cc(n) {
  return new Promise((e, t) => {
    gm.fabric.Image.fromURL(n, (i) => {
      try {
        i.set({ originX: "left", originY: "top" }), e(i);
      } catch (r) {
        t(r);
      }
    });
  });
}
class zL {
  constructor({ textureImages: e, emit: t, canvasEl: i }) {
    Fe(this, "id");
    Fe(this, "meshId");
    Fe(this, "materialIndexs", []);
    Fe(this, "canvasEl");
    Fe(this, "textureImages");
    Fe(this, "texture");
    Fe(this, "canvasInit", !1);
    Fe(this, "emit");
    Fe(this, "canvasOperator");
    Fe(this, "update", () => {
      (this.texture.needsUpdate = !0),
        console.log("", this.texture),
        setTimeout(() => {
          this.emit(Xu.RENDER);
        }, 0);
    });
    (this.textureImages = e), (this.emit = t), (this.canvasEl = i);
  }
  async initCanvas() {
    return new Promise((e, t) => {
      this.canvasOperator
        .initCanvasImages()
        .then(() => {
          (this.canvasInit = !0), e(!0);
        })
        .catch((i) => {
          t(i);
        });
    });
  }
  async getTexture() {
    return (
      this.texture ||
        ((this.canvasOperator = new BL({
          el: this.canvasEl,
          images: this.textureImages,
          updateCanvas: this.update,
        })),
        (this.texture = new gO(this.canvasOperator.fabricCanvas.getElement())),
        await this.initCanvas()),
      this.texture
    );
  }
  getFabricCanvas() {
    return this.canvasOperator.fabricCanvas;
  }
  getCanvasOperator() {
    return this.canvasOperator;
  }
  bindMesh(e) {
    this.meshId = e;
  }
  bindMaterial(e) {
    this.materialIndexs.push(e);
  }
}
class UL {
  constructor(e, t) {
    Fe(this, "state");
    Fe(this, "emit");
    Fe(this, "format");
    Fe(this, "loader");
    Fe(this, "loadHandle");
    (this.state = e), (this.emit = t);
  }
  init() {
    switch (this.format) {
      case "obj":
        this.loader = new IL();
        break;
      case "gltf":
        this.loader = new JO();
        const e = new qO();
        e.setDecoderPath("node_modules/three/examples/jsm/libs/draco/"),
          e.preload(),
          this.loader.setDRACOLoader(e);
        break;
    }
    return this;
  }
  async load(e, t, i) {
    const {
        fileSrc: r,
        textureImageArrays: o,
        scale: p,
        rotation: a,
        position: s,
      } = e,
      u = await this.loader.loadAsync(r);
    let d;
    switch (this.format) {
      case "gltf":
        d = u.scene;
        break;
      case "obj":
        d = u;
        break;
    }
    const { meshes: l, meshTextures: c } = this.groupHandle({
      group: d,
      textureImageArrays: o,
      canvasElArrays: i,
    });
    return (
      l.forEach(async (h) => {
        await h.setMeshTextures(),
          console.log(h.mesh),
          p && h.mesh.scale.set(...p),
          s && h.mesh.position.set(...s),
          a && h.mesh.rotation.set(...a),
          t.add(h.mesh),
          this.emit(Xu.RENDER);
      }),
      this.loadHandle(u),
      { meshes: l, meshTextures: c }
    );
  }
  groupHandle({ group: e, textureImageArrays: t, canvasElArrays: i }) {
    const r = [],
      o = [];
    return (
      e.children.forEach((p, a) => {
        const s = t[a],
          u = i[a],
          d = s.map(
            (l, c) =>
              new zL({ textureImages: l, emit: this.emit, canvasEl: u[c] })
          );
        o.push(...d), r.push(new kL({ mesh: p, textures: d, emit: this.emit }));
      }),
      { meshes: r, meshTextures: o }
    );
  }
}
class jL extends UL {
  constructor() {
    super(...arguments);
    Fe(this, "format", "obj");
    Fe(this, "loadHandle", (t) => {
      console.log(t, this.state);
    });
  }
}
class HL extends YO {
  constructor() {
    super(...arguments);
    Fe(this, "numberOfMesh", 0);
    Fe(this, "currentMesh");
  }
}
const r1 = {
    sceneConfig: {},
    lightConfig: {},
    cameraConfig: {},
    numberOfMesh: 0,
    currentMesh: void 0,
  },
  Pf = new KO(r1).addLoaders([jL]);
function VL(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var qn = VL,
  WL = typeof Fl == "object" && Fl && Fl.Object === Object && Fl,
  s1 = WL,
  GL = s1,
  $L = typeof self == "object" && self && self.Object === Object && self,
  XL = GL || $L || Function("return this")(),
  li = XL,
  YL = li,
  KL = function () {
    return YL.Date.now();
  },
  qL = KL,
  ZL = /\s/;
function JL(n) {
  for (var e = n.length; e-- && ZL.test(n.charAt(e)); );
  return e;
}
var QL = JL,
  eD = QL,
  tD = /^\s+/;
function nD(n) {
  return n && n.slice(0, eD(n) + 1).replace(tD, "");
}
var iD = nD,
  rD = li,
  sD = rD.Symbol,
  No = sD,
  Q0 = No,
  o1 = Object.prototype,
  oD = o1.hasOwnProperty,
  aD = o1.toString,
  ma = Q0 ? Q0.toStringTag : void 0;
function lD(n) {
  var e = oD.call(n, ma),
    t = n[ma];
  try {
    n[ma] = void 0;
    var i = !0;
  } catch {}
  var r = aD.call(n);
  return i && (e ? (n[ma] = t) : delete n[ma]), r;
}
var cD = lD,
  uD = Object.prototype,
  hD = uD.toString;
function fD(n) {
  return hD.call(n);
}
var dD = fD,
  ey = No,
  pD = cD,
  mD = dD,
  gD = "[object Null]",
  vD = "[object Undefined]",
  ty = ey ? ey.toStringTag : void 0;
function yD(n) {
  return n == null
    ? n === void 0
      ? vD
      : gD
    : ty && ty in Object(n)
    ? pD(n)
    : mD(n);
}
var Tr = yD;
function _D(n) {
  return n != null && typeof n == "object";
}
var ci = _D,
  xD = Tr,
  bD = ci,
  SD = "[object Symbol]";
function wD(n) {
  return typeof n == "symbol" || (bD(n) && xD(n) == SD);
}
var Yu = wD,
  TD = iD,
  ny = qn,
  CD = Yu,
  iy = 0 / 0,
  MD = /^[-+]0x[0-9a-f]+$/i,
  ED = /^0b[01]+$/i,
  AD = /^0o[0-7]+$/i,
  PD = parseInt;
function OD(n) {
  if (typeof n == "number") return n;
  if (CD(n)) return iy;
  if (ny(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = ny(e) ? e + "" : e;
  }
  if (typeof n != "string") return n === 0 ? n : +n;
  n = TD(n);
  var t = ED.test(n);
  return t || AD.test(n) ? PD(n.slice(2), t ? 2 : 8) : MD.test(n) ? iy : +n;
}
var LD = OD,
  DD = qn,
  Of = qL,
  ry = LD,
  RD = "Expected a function",
  ID = Math.max,
  kD = Math.min;
function FD(n, e, t) {
  var i,
    r,
    o,
    p,
    a,
    s,
    u = 0,
    d = !1,
    l = !1,
    c = !0;
  if (typeof n != "function") throw new TypeError(RD);
  (e = ry(e) || 0),
    DD(t) &&
      ((d = !!t.leading),
      (l = "maxWait" in t),
      (o = l ? ID(ry(t.maxWait) || 0, e) : o),
      (c = "trailing" in t ? !!t.trailing : c));
  function h(S) {
    var T = i,
      w = r;
    return (i = r = void 0), (u = S), (p = n.apply(w, T)), p;
  }
  function m(S) {
    return (u = S), (a = setTimeout(v, e)), d ? h(S) : p;
  }
  function g(S) {
    var T = S - s,
      w = S - u,
      P = e - T;
    return l ? kD(P, o - w) : P;
  }
  function f(S) {
    var T = S - s,
      w = S - u;
    return s === void 0 || T >= e || T < 0 || (l && w >= o);
  }
  function v() {
    var S = Of();
    if (f(S)) return y(S);
    a = setTimeout(v, g(S));
  }
  function y(S) {
    return (a = void 0), c && i ? h(S) : ((i = r = void 0), p);
  }
  function _() {
    a !== void 0 && clearTimeout(a), (u = 0), (i = s = r = a = void 0);
  }
  function x() {
    return a === void 0 ? p : y(Of());
  }
  function b() {
    var S = Of(),
      T = f(S);
    if (((i = arguments), (r = this), (s = S), T)) {
      if (a === void 0) return m(s);
      if (l) return clearTimeout(a), (a = setTimeout(v, e)), h(s);
    }
    return a === void 0 && (a = setTimeout(v, e)), p;
  }
  return (b.cancel = _), (b.flush = x), b;
}
var ND = FD,
  BD = ND,
  zD = qn,
  UD = "Expected a function";
function jD(n, e, t) {
  var i = !0,
    r = !0;
  if (typeof n != "function") throw new TypeError(UD);
  return (
    zD(t) &&
      ((i = "leading" in t ? !!t.leading : i),
      (r = "trailing" in t ? !!t.trailing : r)),
    BD(n, e, { leading: i, maxWait: e, trailing: r })
  );
}
var HD = jD;
const sy = HD;
function VD() {}
var ut = VD,
  Be = {},
  WD = {
    get exports() {
      return Be;
    },
    set exports(n) {
      Be = n;
    },
  };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (n) {
  (function () {
    var e = {}.hasOwnProperty;
    function t() {
      for (var i = [], r = 0; r < arguments.length; r++) {
        var o = arguments[r];
        if (o) {
          var p = typeof o;
          if (p === "string" || p === "number") i.push(o);
          else if (Array.isArray(o)) {
            if (o.length) {
              var a = t.apply(null, o);
              a && i.push(a);
            }
          } else if (p === "object") {
            if (
              o.toString !== Object.prototype.toString &&
              !o.toString.toString().includes("[native code]")
            ) {
              i.push(o.toString());
              continue;
            }
            for (var s in o) e.call(o, s) && o[s] && i.push(s);
          }
        }
      }
      return i.join(" ");
    }
    n.exports ? ((t.default = t), (n.exports = t)) : (window.classNames = t);
  })();
})(WD);
var M = {},
  GD = {
    get exports() {
      return M;
    },
    set exports(n) {
      M = n;
    },
  },
  $D = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  XD = $D,
  YD = XD;
function a1() {}
function l1() {}
l1.resetWarningCache = a1;
var KD = function () {
  function n(i, r, o, p, a, s) {
    if (s !== YD) {
      var u = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((u.name = "Invariant Violation"), u);
    }
  }
  n.isRequired = n;
  function e() {
    return n;
  }
  var t = {
    array: n,
    bigint: n,
    bool: n,
    func: n,
    number: n,
    object: n,
    string: n,
    symbol: n,
    any: n,
    arrayOf: e,
    element: n,
    elementType: n,
    instanceOf: e,
    node: n,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: l1,
    resetWarningCache: a1,
  };
  return (t.PropTypes = t), t;
};
GD.exports = KD();
const Ye = "semi";
var qD = Array.isArray,
  Fn = qD,
  ZD = Fn,
  JD = Yu,
  QD = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  e3 = /^\w*$/;
function t3(n, e) {
  if (ZD(n)) return !1;
  var t = typeof n;
  return t == "number" || t == "symbol" || t == "boolean" || n == null || JD(n)
    ? !0
    : e3.test(n) || !QD.test(n) || (e != null && n in Object(e));
}
var n3 = t3,
  i3 = Tr,
  r3 = qn,
  s3 = "[object AsyncFunction]",
  o3 = "[object Function]",
  a3 = "[object GeneratorFunction]",
  l3 = "[object Proxy]";
function c3(n) {
  if (!r3(n)) return !1;
  var e = i3(n);
  return e == o3 || e == a3 || e == s3 || e == l3;
}
var Bo = c3,
  u3 = li,
  h3 = u3["__core-js_shared__"],
  f3 = h3,
  Lf = f3,
  oy = (function () {
    var n = /[^.]+$/.exec((Lf && Lf.keys && Lf.keys.IE_PROTO) || "");
    return n ? "Symbol(src)_1." + n : "";
  })();
function d3(n) {
  return !!oy && oy in n;
}
var p3 = d3,
  m3 = Function.prototype,
  g3 = m3.toString;
function v3(n) {
  if (n != null) {
    try {
      return g3.call(n);
    } catch {}
    try {
      return n + "";
    } catch {}
  }
  return "";
}
var c1 = v3,
  y3 = Bo,
  _3 = p3,
  x3 = qn,
  b3 = c1,
  S3 = /[\\^$.*+?()[\]{}|]/g,
  w3 = /^\[object .+?Constructor\]$/,
  T3 = Function.prototype,
  C3 = Object.prototype,
  M3 = T3.toString,
  E3 = C3.hasOwnProperty,
  A3 = RegExp(
    "^" +
      M3.call(E3)
        .replace(S3, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  );
function P3(n) {
  if (!x3(n) || _3(n)) return !1;
  var e = y3(n) ? A3 : w3;
  return e.test(b3(n));
}
var O3 = P3;
function L3(n, e) {
  return n == null ? void 0 : n[e];
}
var D3 = L3,
  R3 = O3,
  I3 = D3;
function k3(n, e) {
  var t = I3(n, e);
  return R3(t) ? t : void 0;
}
var ms = k3,
  F3 = ms,
  N3 = F3(Object, "create"),
  Ku = N3,
  ay = Ku;
function B3() {
  (this.__data__ = ay ? ay(null) : {}), (this.size = 0);
}
var z3 = B3;
function U3(n) {
  var e = this.has(n) && delete this.__data__[n];
  return (this.size -= e ? 1 : 0), e;
}
var j3 = U3,
  H3 = Ku,
  V3 = "__lodash_hash_undefined__",
  W3 = Object.prototype,
  G3 = W3.hasOwnProperty;
function $3(n) {
  var e = this.__data__;
  if (H3) {
    var t = e[n];
    return t === V3 ? void 0 : t;
  }
  return G3.call(e, n) ? e[n] : void 0;
}
var X3 = $3,
  Y3 = Ku,
  K3 = Object.prototype,
  q3 = K3.hasOwnProperty;
function Z3(n) {
  var e = this.__data__;
  return Y3 ? e[n] !== void 0 : q3.call(e, n);
}
var J3 = Z3,
  Q3 = Ku,
  eR = "__lodash_hash_undefined__";
function tR(n, e) {
  var t = this.__data__;
  return (
    (this.size += this.has(n) ? 0 : 1),
    (t[n] = Q3 && e === void 0 ? eR : e),
    this
  );
}
var nR = tR,
  iR = z3,
  rR = j3,
  sR = X3,
  oR = J3,
  aR = nR;
function zo(n) {
  var e = -1,
    t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var i = n[e];
    this.set(i[0], i[1]);
  }
}
zo.prototype.clear = iR;
zo.prototype.delete = rR;
zo.prototype.get = sR;
zo.prototype.has = oR;
zo.prototype.set = aR;
var lR = zo;
function cR() {
  (this.__data__ = []), (this.size = 0);
}
var uR = cR;
function hR(n, e) {
  return n === e || (n !== n && e !== e);
}
var Tl = hR,
  fR = Tl;
function dR(n, e) {
  for (var t = n.length; t--; ) if (fR(n[t][0], e)) return t;
  return -1;
}
var qu = dR,
  pR = qu,
  mR = Array.prototype,
  gR = mR.splice;
function vR(n) {
  var e = this.__data__,
    t = pR(e, n);
  if (t < 0) return !1;
  var i = e.length - 1;
  return t == i ? e.pop() : gR.call(e, t, 1), --this.size, !0;
}
var yR = vR,
  _R = qu;
function xR(n) {
  var e = this.__data__,
    t = _R(e, n);
  return t < 0 ? void 0 : e[t][1];
}
var bR = xR,
  SR = qu;
function wR(n) {
  return SR(this.__data__, n) > -1;
}
var TR = wR,
  CR = qu;
function MR(n, e) {
  var t = this.__data__,
    i = CR(t, n);
  return i < 0 ? (++this.size, t.push([n, e])) : (t[i][1] = e), this;
}
var ER = MR,
  AR = uR,
  PR = yR,
  OR = bR,
  LR = TR,
  DR = ER;
function Uo(n) {
  var e = -1,
    t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var i = n[e];
    this.set(i[0], i[1]);
  }
}
Uo.prototype.clear = AR;
Uo.prototype.delete = PR;
Uo.prototype.get = OR;
Uo.prototype.has = LR;
Uo.prototype.set = DR;
var Zu = Uo,
  RR = ms,
  IR = li,
  kR = RR(IR, "Map"),
  vm = kR,
  ly = lR,
  FR = Zu,
  NR = vm;
function BR() {
  (this.size = 0),
    (this.__data__ = {
      hash: new ly(),
      map: new (NR || FR)(),
      string: new ly(),
    });
}
var zR = BR;
function UR(n) {
  var e = typeof n;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean"
    ? n !== "__proto__"
    : n === null;
}
var jR = UR,
  HR = jR;
function VR(n, e) {
  var t = n.__data__;
  return HR(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
var Ju = VR,
  WR = Ju;
function GR(n) {
  var e = WR(this, n).delete(n);
  return (this.size -= e ? 1 : 0), e;
}
var $R = GR,
  XR = Ju;
function YR(n) {
  return XR(this, n).get(n);
}
var KR = YR,
  qR = Ju;
function ZR(n) {
  return qR(this, n).has(n);
}
var JR = ZR,
  QR = Ju;
function eI(n, e) {
  var t = QR(this, n),
    i = t.size;
  return t.set(n, e), (this.size += t.size == i ? 0 : 1), this;
}
var tI = eI,
  nI = zR,
  iI = $R,
  rI = KR,
  sI = JR,
  oI = tI;
function jo(n) {
  var e = -1,
    t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var i = n[e];
    this.set(i[0], i[1]);
  }
}
jo.prototype.clear = nI;
jo.prototype.delete = iI;
jo.prototype.get = rI;
jo.prototype.has = sI;
jo.prototype.set = oI;
var ym = jo,
  u1 = ym,
  aI = "Expected a function";
function _m(n, e) {
  if (typeof n != "function" || (e != null && typeof e != "function"))
    throw new TypeError(aI);
  var t = function () {
    var i = arguments,
      r = e ? e.apply(this, i) : i[0],
      o = t.cache;
    if (o.has(r)) return o.get(r);
    var p = n.apply(this, i);
    return (t.cache = o.set(r, p) || o), p;
  };
  return (t.cache = new (_m.Cache || u1)()), t;
}
_m.Cache = u1;
var lI = _m,
  cI = lI,
  uI = 500;
function hI(n) {
  var e = cI(n, function (i) {
      return t.size === uI && t.clear(), i;
    }),
    t = e.cache;
  return e;
}
var fI = hI,
  dI = fI,
  pI =
    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
  mI = /\\(\\)?/g,
  gI = dI(function (n) {
    var e = [];
    return (
      n.charCodeAt(0) === 46 && e.push(""),
      n.replace(pI, function (t, i, r, o) {
        e.push(r ? o.replace(mI, "$1") : i || t);
      }),
      e
    );
  }),
  vI = gI;
function yI(n, e) {
  for (var t = -1, i = n == null ? 0 : n.length, r = Array(i); ++t < i; )
    r[t] = e(n[t], t, n);
  return r;
}
var h1 = yI,
  cy = No,
  _I = h1,
  xI = Fn,
  bI = Yu,
  SI = 1 / 0,
  uy = cy ? cy.prototype : void 0,
  hy = uy ? uy.toString : void 0;
function f1(n) {
  if (typeof n == "string") return n;
  if (xI(n)) return _I(n, f1) + "";
  if (bI(n)) return hy ? hy.call(n) : "";
  var e = n + "";
  return e == "0" && 1 / n == -SI ? "-0" : e;
}
var wI = f1,
  TI = wI;
function CI(n) {
  return n == null ? "" : TI(n);
}
var MI = CI,
  EI = Fn,
  AI = n3,
  PI = vI,
  OI = MI;
function LI(n, e) {
  return EI(n) ? n : AI(n, e) ? [n] : PI(OI(n));
}
var Ho = LI,
  DI = Yu,
  RI = 1 / 0;
function II(n) {
  if (typeof n == "string" || DI(n)) return n;
  var e = n + "";
  return e == "0" && 1 / n == -RI ? "-0" : e;
}
var Qu = II,
  kI = Ho,
  FI = Qu;
function NI(n, e) {
  e = kI(e, n);
  for (var t = 0, i = e.length; n != null && t < i; ) n = n[FI(e[t++])];
  return t && t == i ? n : void 0;
}
var xm = NI,
  BI = xm;
function zI(n, e, t) {
  var i = n == null ? void 0 : BI(n, e);
  return i === void 0 ? t : i;
}
var st = zI;
const UI = function (n) {
    if (st(process, "env.NODE_ENV") === "development") {
      for (
        var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1;
        i < e;
        i++
      )
        t[i - 1] = arguments[i];
      console.log(n, ...t);
    }
  },
  d1 = UI;
class bm {
  constructor(e) {
    this._adapter = Object.assign(Object.assign({}, bm.defaultAdapter), e);
  }
  static get cssClasses() {
    return {};
  }
  static get strings() {
    return {};
  }
  static get numbers() {
    return {};
  }
  static get defaultAdapter() {
    return {
      getProp: ut,
      getProps: ut,
      getState: ut,
      getStates: ut,
      setState: ut,
      getContext: ut,
      getContexts: ut,
      getCache: ut,
      setCache: ut,
      getCaches: ut,
      stopPropagation: ut,
      persistEvent: ut,
    };
  }
  getProp(e) {
    return this._adapter.getProp(e);
  }
  getProps() {
    return this._adapter.getProps();
  }
  getState(e) {
    return this._adapter.getState(e);
  }
  getStates() {
    return this._adapter.getStates();
  }
  setState(e, t) {
    return this._adapter.setState(Object.assign({}, e), t);
  }
  getContext(e) {
    return this._adapter.getContext(e);
  }
  getContexts() {
    return this._adapter.getContexts();
  }
  getCaches() {
    return this._adapter.getCaches();
  }
  getCache(e) {
    return this._adapter.getCache(e);
  }
  setCache(e, t) {
    return e && this._adapter.setCache(e, t);
  }
  stopPropagation(e) {
    this._adapter.stopPropagation(e);
  }
  _isControlledComponent() {
    let e =
      arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "value";
    const t = this.getProps();
    return e in t;
  }
  _isInProps(e) {
    const t = this.getProps();
    return e in t;
  }
  init(e) {}
  destroy() {}
  log(e) {
    for (
      var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1;
      r < t;
      r++
    )
      i[r - 1] = arguments[r];
    d1(e, ...i);
  }
  _persistEvent(e) {
    this._adapter.persistEvent(e);
  }
}
const Wi = bm,
  { hasOwnProperty: jI } = Object.prototype;
class bn extends Ce.Component {
  constructor(e) {
    super(e),
      (this.isControlled = (t) =>
        Boolean(
          t &&
            this.props &&
            typeof this.props == "object" &&
            jI.call(this.props, t)
        )),
      (this.cache = {}),
      (this.foundation = null);
  }
  componentDidMount() {
    this.foundation &&
      typeof this.foundation.init == "function" &&
      this.foundation.init();
  }
  componentWillUnmount() {
    this.foundation &&
      typeof this.foundation.destroy == "function" &&
      this.foundation.destroy(),
      (this.cache = {});
  }
  get adapter() {
    return {
      getContext: (e) => {
        if (this.context && e) return this.context[e];
      },
      getContexts: () => this.context,
      getProp: (e) => this.props[e],
      getProps: () => this.props,
      getState: (e) => this.state[e],
      getStates: () => this.state,
      setState: (e, t) => this.setState(Object.assign({}, e), t),
      getCache: (e) => e && this.cache[e],
      getCaches: () => this.cache,
      setCache: (e, t) => e && (this.cache[e] = t),
      stopPropagation: (e) => {
        try {
          e.stopPropagation(),
            e.nativeEvent && e.nativeEvent.stopImmediatePropagation();
        } catch {}
      },
      persistEvent: (e) => {
        e && e.persist && typeof e.persist == "function" && e.persist();
      },
    };
  }
  log(e) {
    for (
      var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1;
      r < t;
      r++
    )
      i[r - 1] = arguments[r];
    return d1(e, ...i);
  }
}
bn.propTypes = {};
bn.defaultProps = {};
const eh = { PREFIX: `${Ye}-typography` },
  cn = {
    TYPE: [
      "primary",
      "secondary",
      "danger",
      "warning",
      "success",
      "tertiary",
      "quaternary",
    ],
    SIZE: ["normal", "small"],
    SPACING: ["normal", "extended"],
    HEADING: [1, 2, 3, 4, 5, 6],
    RULE: [
      "text",
      "numbers",
      "bytes-decimal",
      "bytes-binary",
      "percentages",
      "exponential",
    ],
    TRUNCATE: ["ceil", "floor", "round"],
  };
var HI =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const VI = eh.PREFIX;
let Sm = class extends Ce.PureComponent {
  render() {
    const e = this.props,
      { component: t, className: i, children: r, forwardRef: o } = e,
      p = HI(e, ["component", "className", "children", "forwardRef"]),
      a = t,
      s = Be(VI, i);
    return W.createElement(a, Object.assign({ className: s, ref: o }, p), r);
  }
};
Sm.defaultProps = { component: "article", style: {}, className: "" };
Sm.propTypes = { component: M.string, style: M.object, className: M.string };
const p1 = Sm;
var WI = Tr,
  GI = Fn,
  $I = ci,
  XI = "[object String]";
function YI(n) {
  return typeof n == "string" || (!GI(n) && $I(n) && WI(n) == XI);
}
var KI = YI;
const qI = KI;
var ZI = Zu;
function JI() {
  (this.__data__ = new ZI()), (this.size = 0);
}
var QI = JI;
function ek(n) {
  var e = this.__data__,
    t = e.delete(n);
  return (this.size = e.size), t;
}
var tk = ek;
function nk(n) {
  return this.__data__.get(n);
}
var ik = nk;
function rk(n) {
  return this.__data__.has(n);
}
var sk = rk,
  ok = Zu,
  ak = vm,
  lk = ym,
  ck = 200;
function uk(n, e) {
  var t = this.__data__;
  if (t instanceof ok) {
    var i = t.__data__;
    if (!ak || i.length < ck - 1)
      return i.push([n, e]), (this.size = ++t.size), this;
    t = this.__data__ = new lk(i);
  }
  return t.set(n, e), (this.size = t.size), this;
}
var hk = uk,
  fk = Zu,
  dk = QI,
  pk = tk,
  mk = ik,
  gk = sk,
  vk = hk;
function Vo(n) {
  var e = (this.__data__ = new fk(n));
  this.size = e.size;
}
Vo.prototype.clear = dk;
Vo.prototype.delete = pk;
Vo.prototype.get = mk;
Vo.prototype.has = gk;
Vo.prototype.set = vk;
var wm = Vo,
  yk = ms,
  _k = (function () {
    try {
      var n = yk(Object, "defineProperty");
      return n({}, "", {}), n;
    } catch {}
  })(),
  m1 = _k,
  fy = m1;
function xk(n, e, t) {
  e == "__proto__" && fy
    ? fy(n, e, { configurable: !0, enumerable: !0, value: t, writable: !0 })
    : (n[e] = t);
}
var Tm = xk,
  bk = Tm,
  Sk = Tl;
function wk(n, e, t) {
  ((t !== void 0 && !Sk(n[e], t)) || (t === void 0 && !(e in n))) &&
    bk(n, e, t);
}
var g1 = wk;
function Tk(n) {
  return function (e, t, i) {
    for (var r = -1, o = Object(e), p = i(e), a = p.length; a--; ) {
      var s = p[n ? a : ++r];
      if (t(o[s], s, o) === !1) break;
    }
    return e;
  };
}
var Ck = Tk,
  Mk = Ck,
  Ek = Mk(),
  v1 = Ek,
  fl = {},
  Ak = {
    get exports() {
      return fl;
    },
    set exports(n) {
      fl = n;
    },
  };
(function (n, e) {
  var t = li,
    i = e && !e.nodeType && e,
    r = i && !0 && n && !n.nodeType && n,
    o = r && r.exports === i,
    p = o ? t.Buffer : void 0,
    a = p ? p.allocUnsafe : void 0;
  function s(u, d) {
    if (d) return u.slice();
    var l = u.length,
      c = a ? a(l) : new u.constructor(l);
    return u.copy(c), c;
  }
  n.exports = s;
})(Ak, fl);
var Pk = li,
  Ok = Pk.Uint8Array,
  y1 = Ok,
  dy = y1;
function Lk(n) {
  var e = new n.constructor(n.byteLength);
  return new dy(e).set(new dy(n)), e;
}
var Cm = Lk,
  Dk = Cm;
function Rk(n, e) {
  var t = e ? Dk(n.buffer) : n.buffer;
  return new n.constructor(t, n.byteOffset, n.length);
}
var _1 = Rk;
function Ik(n, e) {
  var t = -1,
    i = n.length;
  for (e || (e = Array(i)); ++t < i; ) e[t] = n[t];
  return e;
}
var x1 = Ik,
  kk = qn,
  py = Object.create,
  Fk = (function () {
    function n() {}
    return function (e) {
      if (!kk(e)) return {};
      if (py) return py(e);
      n.prototype = e;
      var t = new n();
      return (n.prototype = void 0), t;
    };
  })(),
  Nk = Fk;
function Bk(n, e) {
  return function (t) {
    return n(e(t));
  };
}
var b1 = Bk,
  zk = b1,
  Uk = zk(Object.getPrototypeOf, Object),
  Mm = Uk,
  jk = Object.prototype;
function Hk(n) {
  var e = n && n.constructor,
    t = (typeof e == "function" && e.prototype) || jk;
  return n === t;
}
var th = Hk,
  Vk = Nk,
  Wk = Mm,
  Gk = th;
function $k(n) {
  return typeof n.constructor == "function" && !Gk(n) ? Vk(Wk(n)) : {};
}
var S1 = $k,
  Xk = Tr,
  Yk = ci,
  Kk = "[object Arguments]";
function qk(n) {
  return Yk(n) && Xk(n) == Kk;
}
var Zk = qk,
  my = Zk,
  Jk = ci,
  w1 = Object.prototype,
  Qk = w1.hasOwnProperty,
  eF = w1.propertyIsEnumerable,
  tF = my(
    (function () {
      return arguments;
    })()
  )
    ? my
    : function (n) {
        return Jk(n) && Qk.call(n, "callee") && !eF.call(n, "callee");
      },
  Cl = tF,
  nF = 9007199254740991;
function iF(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= nF;
}
var Em = iF,
  rF = Bo,
  sF = Em;
function oF(n) {
  return n != null && sF(n.length) && !rF(n);
}
var Wo = oF,
  aF = Wo,
  lF = ci;
function cF(n) {
  return lF(n) && aF(n);
}
var uF = cF,
  xr = {},
  hF = {
    get exports() {
      return xr;
    },
    set exports(n) {
      xr = n;
    },
  };
function fF() {
  return !1;
}
var dF = fF;
(function (n, e) {
  var t = li,
    i = dF,
    r = e && !e.nodeType && e,
    o = r && !0 && n && !n.nodeType && n,
    p = o && o.exports === r,
    a = p ? t.Buffer : void 0,
    s = a ? a.isBuffer : void 0,
    u = s || i;
  n.exports = u;
})(hF, xr);
var pF = Tr,
  mF = Mm,
  gF = ci,
  vF = "[object Object]",
  yF = Function.prototype,
  _F = Object.prototype,
  T1 = yF.toString,
  xF = _F.hasOwnProperty,
  bF = T1.call(Object);
function SF(n) {
  if (!gF(n) || pF(n) != vF) return !1;
  var e = mF(n);
  if (e === null) return !0;
  var t = xF.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && T1.call(t) == bF;
}
var C1 = SF,
  wF = Tr,
  TF = Em,
  CF = ci,
  MF = "[object Arguments]",
  EF = "[object Array]",
  AF = "[object Boolean]",
  PF = "[object Date]",
  OF = "[object Error]",
  LF = "[object Function]",
  DF = "[object Map]",
  RF = "[object Number]",
  IF = "[object Object]",
  kF = "[object RegExp]",
  FF = "[object Set]",
  NF = "[object String]",
  BF = "[object WeakMap]",
  zF = "[object ArrayBuffer]",
  UF = "[object DataView]",
  jF = "[object Float32Array]",
  HF = "[object Float64Array]",
  VF = "[object Int8Array]",
  WF = "[object Int16Array]",
  GF = "[object Int32Array]",
  $F = "[object Uint8Array]",
  XF = "[object Uint8ClampedArray]",
  YF = "[object Uint16Array]",
  KF = "[object Uint32Array]",
  gt = {};
gt[jF] =
  gt[HF] =
  gt[VF] =
  gt[WF] =
  gt[GF] =
  gt[$F] =
  gt[XF] =
  gt[YF] =
  gt[KF] =
    !0;
gt[MF] =
  gt[EF] =
  gt[zF] =
  gt[AF] =
  gt[UF] =
  gt[PF] =
  gt[OF] =
  gt[LF] =
  gt[DF] =
  gt[RF] =
  gt[IF] =
  gt[kF] =
  gt[FF] =
  gt[NF] =
  gt[BF] =
    !1;
function qF(n) {
  return CF(n) && TF(n.length) && !!gt[wF(n)];
}
var ZF = qF;
function JF(n) {
  return function (e) {
    return n(e);
  };
}
var Am = JF,
  Co = {},
  QF = {
    get exports() {
      return Co;
    },
    set exports(n) {
      Co = n;
    },
  };
(function (n, e) {
  var t = s1,
    i = e && !e.nodeType && e,
    r = i && !0 && n && !n.nodeType && n,
    o = r && r.exports === i,
    p = o && t.process,
    a = (function () {
      try {
        var s = r && r.require && r.require("util").types;
        return s || (p && p.binding && p.binding("util"));
      } catch {}
    })();
  n.exports = a;
})(QF, Co);
var eN = ZF,
  tN = Am,
  gy = Co,
  vy = gy && gy.isTypedArray,
  nN = vy ? tN(vy) : eN,
  nh = nN;
function iN(n, e) {
  if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
    return n[e];
}
var M1 = iN,
  rN = Tm,
  sN = Tl,
  oN = Object.prototype,
  aN = oN.hasOwnProperty;
function lN(n, e, t) {
  var i = n[e];
  (!(aN.call(n, e) && sN(i, t)) || (t === void 0 && !(e in n))) && rN(n, e, t);
}
var Pm = lN,
  cN = Pm,
  uN = Tm;
function hN(n, e, t, i) {
  var r = !t;
  t || (t = {});
  for (var o = -1, p = e.length; ++o < p; ) {
    var a = e[o],
      s = i ? i(t[a], n[a], a, t, n) : void 0;
    s === void 0 && (s = n[a]), r ? uN(t, a, s) : cN(t, a, s);
  }
  return t;
}
var Go = hN;
function fN(n, e) {
  for (var t = -1, i = Array(n); ++t < n; ) i[t] = e(t);
  return i;
}
var dN = fN,
  pN = 9007199254740991,
  mN = /^(?:0|[1-9]\d*)$/;
function gN(n, e) {
  var t = typeof n;
  return (
    (e = e ?? pN),
    !!e &&
      (t == "number" || (t != "symbol" && mN.test(n))) &&
      n > -1 &&
      n % 1 == 0 &&
      n < e
  );
}
var ih = gN,
  vN = dN,
  yN = Cl,
  _N = Fn,
  xN = xr,
  bN = ih,
  SN = nh,
  wN = Object.prototype,
  TN = wN.hasOwnProperty;
function CN(n, e) {
  var t = _N(n),
    i = !t && yN(n),
    r = !t && !i && xN(n),
    o = !t && !i && !r && SN(n),
    p = t || i || r || o,
    a = p ? vN(n.length, String) : [],
    s = a.length;
  for (var u in n)
    (e || TN.call(n, u)) &&
      !(
        p &&
        (u == "length" ||
          (r && (u == "offset" || u == "parent")) ||
          (o && (u == "buffer" || u == "byteLength" || u == "byteOffset")) ||
          bN(u, s))
      ) &&
      a.push(u);
  return a;
}
var E1 = CN;
function MN(n) {
  var e = [];
  if (n != null) for (var t in Object(n)) e.push(t);
  return e;
}
var EN = MN,
  AN = qn,
  PN = th,
  ON = EN,
  LN = Object.prototype,
  DN = LN.hasOwnProperty;
function RN(n) {
  if (!AN(n)) return ON(n);
  var e = PN(n),
    t = [];
  for (var i in n) (i == "constructor" && (e || !DN.call(n, i))) || t.push(i);
  return t;
}
var IN = RN,
  kN = E1,
  FN = IN,
  NN = Wo;
function BN(n) {
  return NN(n) ? kN(n, !0) : FN(n);
}
var Ml = BN,
  zN = Go,
  UN = Ml;
function jN(n) {
  return zN(n, UN(n));
}
var HN = jN,
  yy = g1,
  VN = fl,
  WN = _1,
  GN = x1,
  $N = S1,
  _y = Cl,
  xy = Fn,
  XN = uF,
  YN = xr,
  KN = Bo,
  qN = qn,
  ZN = C1,
  JN = nh,
  by = M1,
  QN = HN;
function eB(n, e, t, i, r, o, p) {
  var a = by(n, t),
    s = by(e, t),
    u = p.get(s);
  if (u) {
    yy(n, t, u);
    return;
  }
  var d = o ? o(a, s, t + "", n, e, p) : void 0,
    l = d === void 0;
  if (l) {
    var c = xy(s),
      h = !c && YN(s),
      m = !c && !h && JN(s);
    (d = s),
      c || h || m
        ? xy(a)
          ? (d = a)
          : XN(a)
          ? (d = GN(a))
          : h
          ? ((l = !1), (d = VN(s, !0)))
          : m
          ? ((l = !1), (d = WN(s, !0)))
          : (d = [])
        : ZN(s) || _y(s)
        ? ((d = a), _y(a) ? (d = QN(a)) : (!qN(a) || KN(a)) && (d = $N(s)))
        : (l = !1);
  }
  l && (p.set(s, d), r(d, s, i, o, p), p.delete(s)), yy(n, t, d);
}
var tB = eB,
  nB = wm,
  iB = g1,
  rB = v1,
  sB = tB,
  oB = qn,
  aB = Ml,
  lB = M1;
function A1(n, e, t, i, r) {
  n !== e &&
    rB(
      e,
      function (o, p) {
        if ((r || (r = new nB()), oB(o))) sB(n, e, p, t, A1, i, r);
        else {
          var a = i ? i(lB(n, p), o, p + "", n, e, r) : void 0;
          a === void 0 && (a = o), iB(n, p, a);
        }
      },
      aB
    );
}
var cB = A1;
function uB(n) {
  return n;
}
var Om = uB;
function hB(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e);
    case 1:
      return n.call(e, t[0]);
    case 2:
      return n.call(e, t[0], t[1]);
    case 3:
      return n.call(e, t[0], t[1], t[2]);
  }
  return n.apply(e, t);
}
var fB = hB,
  dB = fB,
  Sy = Math.max;
function pB(n, e, t) {
  return (
    (e = Sy(e === void 0 ? n.length - 1 : e, 0)),
    function () {
      for (
        var i = arguments, r = -1, o = Sy(i.length - e, 0), p = Array(o);
        ++r < o;

      )
        p[r] = i[e + r];
      r = -1;
      for (var a = Array(e + 1); ++r < e; ) a[r] = i[r];
      return (a[e] = t(p)), dB(n, this, a);
    }
  );
}
var P1 = pB;
function mB(n) {
  return function () {
    return n;
  };
}
var gB = mB,
  vB = gB,
  wy = m1,
  yB = Om,
  _B = wy
    ? function (n, e) {
        return wy(n, "toString", {
          configurable: !0,
          enumerable: !1,
          value: vB(e),
          writable: !0,
        });
      }
    : yB,
  xB = _B,
  bB = 800,
  SB = 16,
  wB = Date.now;
function TB(n) {
  var e = 0,
    t = 0;
  return function () {
    var i = wB(),
      r = SB - (i - t);
    if (((t = i), r > 0)) {
      if (++e >= bB) return arguments[0];
    } else e = 0;
    return n.apply(void 0, arguments);
  };
}
var CB = TB,
  MB = xB,
  EB = CB,
  AB = EB(MB),
  O1 = AB,
  PB = Om,
  OB = P1,
  LB = O1;
function DB(n, e) {
  return LB(OB(n, e, PB), n + "");
}
var RB = DB,
  IB = Tl,
  kB = Wo,
  FB = ih,
  NB = qn;
function BB(n, e, t) {
  if (!NB(t)) return !1;
  var i = typeof e;
  return (i == "number" ? kB(t) && FB(e, t.length) : i == "string" && e in t)
    ? IB(t[e], n)
    : !1;
}
var zB = BB,
  UB = RB,
  jB = zB;
function HB(n) {
  return UB(function (e, t) {
    var i = -1,
      r = t.length,
      o = r > 1 ? t[r - 1] : void 0,
      p = r > 2 ? t[2] : void 0;
    for (
      o = n.length > 3 && typeof o == "function" ? (r--, o) : void 0,
        p && jB(t[0], t[1], p) && ((o = r < 3 ? void 0 : o), (r = 1)),
        e = Object(e);
      ++i < r;

    ) {
      var a = t[i];
      a && n(e, a, i, o);
    }
    return e;
  });
}
var VB = HB,
  WB = cB,
  GB = VB,
  $B = GB(function (n, e, t) {
    WB(n, e, t);
  }),
  XB = $B;
const YB = XB;
function KB(n, e) {
  for (
    var t = -1, i = n == null ? 0 : n.length;
    ++t < i && e(n[t], t, n) !== !1;

  );
  return n;
}
var L1 = KB,
  qB = b1,
  ZB = qB(Object.keys, Object),
  JB = ZB,
  QB = th,
  e4 = JB,
  t4 = Object.prototype,
  n4 = t4.hasOwnProperty;
function i4(n) {
  if (!QB(n)) return e4(n);
  var e = [];
  for (var t in Object(n)) n4.call(n, t) && t != "constructor" && e.push(t);
  return e;
}
var D1 = i4,
  r4 = E1,
  s4 = D1,
  o4 = Wo;
function a4(n) {
  return o4(n) ? r4(n) : s4(n);
}
var rh = a4,
  l4 = Go,
  c4 = rh;
function u4(n, e) {
  return n && l4(e, c4(e), n);
}
var h4 = u4,
  f4 = Go,
  d4 = Ml;
function p4(n, e) {
  return n && f4(e, d4(e), n);
}
var m4 = p4;
function g4(n, e) {
  for (var t = -1, i = n == null ? 0 : n.length, r = 0, o = []; ++t < i; ) {
    var p = n[t];
    e(p, t, n) && (o[r++] = p);
  }
  return o;
}
var v4 = g4;
function y4() {
  return [];
}
var R1 = y4,
  _4 = v4,
  x4 = R1,
  b4 = Object.prototype,
  S4 = b4.propertyIsEnumerable,
  Ty = Object.getOwnPropertySymbols,
  w4 = Ty
    ? function (n) {
        return n == null
          ? []
          : ((n = Object(n)),
            _4(Ty(n), function (e) {
              return S4.call(n, e);
            }));
      }
    : x4,
  Lm = w4,
  T4 = Go,
  C4 = Lm;
function M4(n, e) {
  return T4(n, C4(n), e);
}
var E4 = M4;
function A4(n, e) {
  for (var t = -1, i = e.length, r = n.length; ++t < i; ) n[r + t] = e[t];
  return n;
}
var Dm = A4,
  P4 = Dm,
  O4 = Mm,
  L4 = Lm,
  D4 = R1,
  R4 = Object.getOwnPropertySymbols,
  I4 = R4
    ? function (n) {
        for (var e = []; n; ) P4(e, L4(n)), (n = O4(n));
        return e;
      }
    : D4,
  I1 = I4,
  k4 = Go,
  F4 = I1;
function N4(n, e) {
  return k4(n, F4(n), e);
}
var B4 = N4,
  z4 = Dm,
  U4 = Fn;
function j4(n, e, t) {
  var i = e(n);
  return U4(n) ? i : z4(i, t(n));
}
var k1 = j4,
  H4 = k1,
  V4 = Lm,
  W4 = rh;
function G4(n) {
  return H4(n, W4, V4);
}
var F1 = G4,
  $4 = k1,
  X4 = I1,
  Y4 = Ml;
function K4(n) {
  return $4(n, Y4, X4);
}
var N1 = K4,
  q4 = ms,
  Z4 = li,
  J4 = q4(Z4, "DataView"),
  Q4 = J4,
  e5 = ms,
  t5 = li,
  n5 = e5(t5, "Promise"),
  i5 = n5,
  r5 = ms,
  s5 = li,
  o5 = r5(s5, "Set"),
  a5 = o5,
  l5 = ms,
  c5 = li,
  u5 = l5(c5, "WeakMap"),
  h5 = u5,
  Kd = Q4,
  qd = vm,
  Zd = i5,
  Jd = a5,
  Qd = h5,
  B1 = Tr,
  $o = c1,
  Cy = "[object Map]",
  f5 = "[object Object]",
  My = "[object Promise]",
  Ey = "[object Set]",
  Ay = "[object WeakMap]",
  Py = "[object DataView]",
  d5 = $o(Kd),
  p5 = $o(qd),
  m5 = $o(Zd),
  g5 = $o(Jd),
  v5 = $o(Qd),
  zr = B1;
((Kd && zr(new Kd(new ArrayBuffer(1))) != Py) ||
  (qd && zr(new qd()) != Cy) ||
  (Zd && zr(Zd.resolve()) != My) ||
  (Jd && zr(new Jd()) != Ey) ||
  (Qd && zr(new Qd()) != Ay)) &&
  (zr = function (n) {
    var e = B1(n),
      t = e == f5 ? n.constructor : void 0,
      i = t ? $o(t) : "";
    if (i)
      switch (i) {
        case d5:
          return Py;
        case p5:
          return Cy;
        case m5:
          return My;
        case g5:
          return Ey;
        case v5:
          return Ay;
      }
    return e;
  });
var El = zr,
  y5 = Object.prototype,
  _5 = y5.hasOwnProperty;
function x5(n) {
  var e = n.length,
    t = new n.constructor(e);
  return (
    e &&
      typeof n[0] == "string" &&
      _5.call(n, "index") &&
      ((t.index = n.index), (t.input = n.input)),
    t
  );
}
var b5 = x5,
  S5 = Cm;
function w5(n, e) {
  var t = e ? S5(n.buffer) : n.buffer;
  return new n.constructor(t, n.byteOffset, n.byteLength);
}
var T5 = w5,
  C5 = /\w*$/;
function M5(n) {
  var e = new n.constructor(n.source, C5.exec(n));
  return (e.lastIndex = n.lastIndex), e;
}
var E5 = M5,
  Oy = No,
  Ly = Oy ? Oy.prototype : void 0,
  Dy = Ly ? Ly.valueOf : void 0;
function A5(n) {
  return Dy ? Object(Dy.call(n)) : {};
}
var P5 = A5,
  O5 = Cm,
  L5 = T5,
  D5 = E5,
  R5 = P5,
  I5 = _1,
  k5 = "[object Boolean]",
  F5 = "[object Date]",
  N5 = "[object Map]",
  B5 = "[object Number]",
  z5 = "[object RegExp]",
  U5 = "[object Set]",
  j5 = "[object String]",
  H5 = "[object Symbol]",
  V5 = "[object ArrayBuffer]",
  W5 = "[object DataView]",
  G5 = "[object Float32Array]",
  $5 = "[object Float64Array]",
  X5 = "[object Int8Array]",
  Y5 = "[object Int16Array]",
  K5 = "[object Int32Array]",
  q5 = "[object Uint8Array]",
  Z5 = "[object Uint8ClampedArray]",
  J5 = "[object Uint16Array]",
  Q5 = "[object Uint32Array]";
function ez(n, e, t) {
  var i = n.constructor;
  switch (e) {
    case V5:
      return O5(n);
    case k5:
    case F5:
      return new i(+n);
    case W5:
      return L5(n, t);
    case G5:
    case $5:
    case X5:
    case Y5:
    case K5:
    case q5:
    case Z5:
    case J5:
    case Q5:
      return I5(n, t);
    case N5:
      return new i();
    case B5:
    case j5:
      return new i(n);
    case z5:
      return D5(n);
    case U5:
      return new i();
    case H5:
      return R5(n);
  }
}
var tz = ez,
  nz = El,
  iz = ci,
  rz = "[object Map]";
function sz(n) {
  return iz(n) && nz(n) == rz;
}
var oz = sz,
  az = oz,
  lz = Am,
  Ry = Co,
  Iy = Ry && Ry.isMap,
  cz = Iy ? lz(Iy) : az,
  uz = cz,
  hz = El,
  fz = ci,
  dz = "[object Set]";
function pz(n) {
  return fz(n) && hz(n) == dz;
}
var mz = pz,
  gz = mz,
  vz = Am,
  ky = Co,
  Fy = ky && ky.isSet,
  yz = Fy ? vz(Fy) : gz,
  _z = yz,
  xz = wm,
  bz = L1,
  Sz = Pm,
  wz = h4,
  Tz = m4,
  Cz = fl,
  Mz = x1,
  Ez = E4,
  Az = B4,
  Pz = F1,
  Oz = N1,
  Lz = El,
  Dz = b5,
  Rz = tz,
  Iz = S1,
  kz = Fn,
  Fz = xr,
  Nz = uz,
  Bz = qn,
  zz = _z,
  Uz = rh,
  jz = Ml,
  Hz = 1,
  Vz = 2,
  Wz = 4,
  z1 = "[object Arguments]",
  Gz = "[object Array]",
  $z = "[object Boolean]",
  Xz = "[object Date]",
  Yz = "[object Error]",
  U1 = "[object Function]",
  Kz = "[object GeneratorFunction]",
  qz = "[object Map]",
  Zz = "[object Number]",
  j1 = "[object Object]",
  Jz = "[object RegExp]",
  Qz = "[object Set]",
  eU = "[object String]",
  tU = "[object Symbol]",
  nU = "[object WeakMap]",
  iU = "[object ArrayBuffer]",
  rU = "[object DataView]",
  sU = "[object Float32Array]",
  oU = "[object Float64Array]",
  aU = "[object Int8Array]",
  lU = "[object Int16Array]",
  cU = "[object Int32Array]",
  uU = "[object Uint8Array]",
  hU = "[object Uint8ClampedArray]",
  fU = "[object Uint16Array]",
  dU = "[object Uint32Array]",
  dt = {};
dt[z1] =
  dt[Gz] =
  dt[iU] =
  dt[rU] =
  dt[$z] =
  dt[Xz] =
  dt[sU] =
  dt[oU] =
  dt[aU] =
  dt[lU] =
  dt[cU] =
  dt[qz] =
  dt[Zz] =
  dt[j1] =
  dt[Jz] =
  dt[Qz] =
  dt[eU] =
  dt[tU] =
  dt[uU] =
  dt[hU] =
  dt[fU] =
  dt[dU] =
    !0;
dt[Yz] = dt[U1] = dt[nU] = !1;
function Gc(n, e, t, i, r, o) {
  var p,
    a = e & Hz,
    s = e & Vz,
    u = e & Wz;
  if ((t && (p = r ? t(n, i, r, o) : t(n)), p !== void 0)) return p;
  if (!Bz(n)) return n;
  var d = kz(n);
  if (d) {
    if (((p = Dz(n)), !a)) return Mz(n, p);
  } else {
    var l = Lz(n),
      c = l == U1 || l == Kz;
    if (Fz(n)) return Cz(n, a);
    if (l == j1 || l == z1 || (c && !r)) {
      if (((p = s || c ? {} : Iz(n)), !a))
        return s ? Az(n, Tz(p, n)) : Ez(n, wz(p, n));
    } else {
      if (!dt[l]) return r ? n : {};
      p = Rz(n, l, a);
    }
  }
  o || (o = new xz());
  var h = o.get(n);
  if (h) return h;
  o.set(n, p),
    zz(n)
      ? n.forEach(function (f) {
          p.add(Gc(f, e, t, f, n, o));
        })
      : Nz(n) &&
        n.forEach(function (f, v) {
          p.set(v, Gc(f, e, t, v, n, o));
        });
  var m = u ? (s ? Oz : Pz) : s ? jz : Uz,
    g = d ? void 0 : m(n);
  return (
    bz(g || n, function (f, v) {
      g && ((v = f), (f = n[v])), Sz(p, v, Gc(f, e, t, v, n, o));
    }),
    p
  );
}
var Rm = Gc;
function pU(n) {
  var e = n == null ? 0 : n.length;
  return e ? n[e - 1] : void 0;
}
var mU = pU;
function gU(n, e, t) {
  var i = -1,
    r = n.length;
  e < 0 && (e = -e > r ? 0 : r + e),
    (t = t > r ? r : t),
    t < 0 && (t += r),
    (r = e > t ? 0 : (t - e) >>> 0),
    (e >>>= 0);
  for (var o = Array(r); ++i < r; ) o[i] = n[i + e];
  return o;
}
var vU = gU,
  yU = xm,
  _U = vU;
function xU(n, e) {
  return e.length < 2 ? n : yU(n, _U(e, 0, -1));
}
var bU = xU,
  SU = Ho,
  wU = mU,
  TU = bU,
  CU = Qu;
function MU(n, e) {
  return (e = SU(e, n)), (n = TU(n, e)), n == null || delete n[CU(wU(e))];
}
var EU = MU,
  AU = C1;
function PU(n) {
  return AU(n) ? void 0 : n;
}
var OU = PU,
  Ny = No,
  LU = Cl,
  DU = Fn,
  By = Ny ? Ny.isConcatSpreadable : void 0;
function RU(n) {
  return DU(n) || LU(n) || !!(By && n && n[By]);
}
var IU = RU,
  kU = Dm,
  FU = IU;
function H1(n, e, t, i, r) {
  var o = -1,
    p = n.length;
  for (t || (t = FU), r || (r = []); ++o < p; ) {
    var a = n[o];
    e > 0 && t(a)
      ? e > 1
        ? H1(a, e - 1, t, i, r)
        : kU(r, a)
      : i || (r[r.length] = a);
  }
  return r;
}
var NU = H1,
  BU = NU;
function zU(n) {
  var e = n == null ? 0 : n.length;
  return e ? BU(n, 1) : [];
}
var UU = zU,
  jU = UU,
  HU = P1,
  VU = O1;
function WU(n) {
  return VU(HU(n, void 0, jU), n + "");
}
var V1 = WU,
  GU = h1,
  $U = Rm,
  XU = EU,
  YU = Ho,
  KU = Go,
  qU = OU,
  ZU = V1,
  JU = N1,
  QU = 1,
  ej = 2,
  tj = 4,
  nj = ZU(function (n, e) {
    var t = {};
    if (n == null) return t;
    var i = !1;
    (e = GU(e, function (o) {
      return (o = YU(o, n)), i || (i = o.length > 1), o;
    })),
      KU(n, JU(n), t),
      i && (t = $U(t, QU | ej | tj, qU));
    for (var r = e.length; r--; ) XU(t, e[r]);
    return t;
  }),
  ij = nj;
const Im = ij;
function rj(n) {
  return n === void 0;
}
var sj = rj;
const Mc = sj;
var oj = "__lodash_hash_undefined__";
function aj(n) {
  return this.__data__.set(n, oj), this;
}
var lj = aj;
function cj(n) {
  return this.__data__.has(n);
}
var uj = cj,
  hj = ym,
  fj = lj,
  dj = uj;
function bu(n) {
  var e = -1,
    t = n == null ? 0 : n.length;
  for (this.__data__ = new hj(); ++e < t; ) this.add(n[e]);
}
bu.prototype.add = bu.prototype.push = fj;
bu.prototype.has = dj;
var pj = bu;
function mj(n, e) {
  for (var t = -1, i = n == null ? 0 : n.length; ++t < i; )
    if (e(n[t], t, n)) return !0;
  return !1;
}
var gj = mj;
function vj(n, e) {
  return n.has(e);
}
var yj = vj,
  _j = pj,
  xj = gj,
  bj = yj,
  Sj = 1,
  wj = 2;
function Tj(n, e, t, i, r, o) {
  var p = t & Sj,
    a = n.length,
    s = e.length;
  if (a != s && !(p && s > a)) return !1;
  var u = o.get(n),
    d = o.get(e);
  if (u && d) return u == e && d == n;
  var l = -1,
    c = !0,
    h = t & wj ? new _j() : void 0;
  for (o.set(n, e), o.set(e, n); ++l < a; ) {
    var m = n[l],
      g = e[l];
    if (i) var f = p ? i(g, m, l, e, n, o) : i(m, g, l, n, e, o);
    if (f !== void 0) {
      if (f) continue;
      c = !1;
      break;
    }
    if (h) {
      if (
        !xj(e, function (v, y) {
          if (!bj(h, y) && (m === v || r(m, v, t, i, o))) return h.push(y);
        })
      ) {
        c = !1;
        break;
      }
    } else if (!(m === g || r(m, g, t, i, o))) {
      c = !1;
      break;
    }
  }
  return o.delete(n), o.delete(e), c;
}
var W1 = Tj;
function Cj(n) {
  var e = -1,
    t = Array(n.size);
  return (
    n.forEach(function (i, r) {
      t[++e] = [r, i];
    }),
    t
  );
}
var Mj = Cj;
function Ej(n) {
  var e = -1,
    t = Array(n.size);
  return (
    n.forEach(function (i) {
      t[++e] = i;
    }),
    t
  );
}
var Aj = Ej,
  zy = No,
  Uy = y1,
  Pj = Tl,
  Oj = W1,
  Lj = Mj,
  Dj = Aj,
  Rj = 1,
  Ij = 2,
  kj = "[object Boolean]",
  Fj = "[object Date]",
  Nj = "[object Error]",
  Bj = "[object Map]",
  zj = "[object Number]",
  Uj = "[object RegExp]",
  jj = "[object Set]",
  Hj = "[object String]",
  Vj = "[object Symbol]",
  Wj = "[object ArrayBuffer]",
  Gj = "[object DataView]",
  jy = zy ? zy.prototype : void 0,
  Df = jy ? jy.valueOf : void 0;
function $j(n, e, t, i, r, o, p) {
  switch (t) {
    case Gj:
      if (n.byteLength != e.byteLength || n.byteOffset != e.byteOffset)
        return !1;
      (n = n.buffer), (e = e.buffer);
    case Wj:
      return !(n.byteLength != e.byteLength || !o(new Uy(n), new Uy(e)));
    case kj:
    case Fj:
    case zj:
      return Pj(+n, +e);
    case Nj:
      return n.name == e.name && n.message == e.message;
    case Uj:
    case Hj:
      return n == e + "";
    case Bj:
      var a = Lj;
    case jj:
      var s = i & Rj;
      if ((a || (a = Dj), n.size != e.size && !s)) return !1;
      var u = p.get(n);
      if (u) return u == e;
      (i |= Ij), p.set(n, e);
      var d = Oj(a(n), a(e), i, r, o, p);
      return p.delete(n), d;
    case Vj:
      if (Df) return Df.call(n) == Df.call(e);
  }
  return !1;
}
var Xj = $j,
  Hy = F1,
  Yj = 1,
  Kj = Object.prototype,
  qj = Kj.hasOwnProperty;
function Zj(n, e, t, i, r, o) {
  var p = t & Yj,
    a = Hy(n),
    s = a.length,
    u = Hy(e),
    d = u.length;
  if (s != d && !p) return !1;
  for (var l = s; l--; ) {
    var c = a[l];
    if (!(p ? c in e : qj.call(e, c))) return !1;
  }
  var h = o.get(n),
    m = o.get(e);
  if (h && m) return h == e && m == n;
  var g = !0;
  o.set(n, e), o.set(e, n);
  for (var f = p; ++l < s; ) {
    c = a[l];
    var v = n[c],
      y = e[c];
    if (i) var _ = p ? i(y, v, c, e, n, o) : i(v, y, c, n, e, o);
    if (!(_ === void 0 ? v === y || r(v, y, t, i, o) : _)) {
      g = !1;
      break;
    }
    f || (f = c == "constructor");
  }
  if (g && !f) {
    var x = n.constructor,
      b = e.constructor;
    x != b &&
      "constructor" in n &&
      "constructor" in e &&
      !(
        typeof x == "function" &&
        x instanceof x &&
        typeof b == "function" &&
        b instanceof b
      ) &&
      (g = !1);
  }
  return o.delete(n), o.delete(e), g;
}
var Jj = Zj,
  Rf = wm,
  Qj = W1,
  e6 = Xj,
  t6 = Jj,
  Vy = El,
  Wy = Fn,
  Gy = xr,
  n6 = nh,
  i6 = 1,
  $y = "[object Arguments]",
  Xy = "[object Array]",
  Ec = "[object Object]",
  r6 = Object.prototype,
  Yy = r6.hasOwnProperty;
function s6(n, e, t, i, r, o) {
  var p = Wy(n),
    a = Wy(e),
    s = p ? Xy : Vy(n),
    u = a ? Xy : Vy(e);
  (s = s == $y ? Ec : s), (u = u == $y ? Ec : u);
  var d = s == Ec,
    l = u == Ec,
    c = s == u;
  if (c && Gy(n)) {
    if (!Gy(e)) return !1;
    (p = !0), (d = !1);
  }
  if (c && !d)
    return (
      o || (o = new Rf()),
      p || n6(n) ? Qj(n, e, t, i, r, o) : e6(n, e, s, t, i, r, o)
    );
  if (!(t & i6)) {
    var h = d && Yy.call(n, "__wrapped__"),
      m = l && Yy.call(e, "__wrapped__");
    if (h || m) {
      var g = h ? n.value() : n,
        f = m ? e.value() : e;
      return o || (o = new Rf()), r(g, f, t, i, o);
    }
  }
  return c ? (o || (o = new Rf()), t6(n, e, t, i, r, o)) : !1;
}
var o6 = s6,
  a6 = o6,
  Ky = ci;
function G1(n, e, t, i, r) {
  return n === e
    ? !0
    : n == null || e == null || (!Ky(n) && !Ky(e))
    ? n !== n && e !== e
    : a6(n, e, t, i, G1, r);
}
var l6 = G1,
  c6 = l6;
function u6(n, e) {
  return c6(n, e);
}
var bi = u6,
  h6 = D1,
  f6 = El,
  d6 = Cl,
  p6 = Fn,
  m6 = Wo,
  g6 = xr,
  v6 = th,
  y6 = nh,
  _6 = "[object Map]",
  x6 = "[object Set]",
  b6 = Object.prototype,
  S6 = b6.hasOwnProperty;
function w6(n) {
  if (n == null) return !0;
  if (
    m6(n) &&
    (p6(n) ||
      typeof n == "string" ||
      typeof n.splice == "function" ||
      g6(n) ||
      y6(n) ||
      d6(n))
  )
    return !n.length;
  var e = f6(n);
  if (e == _6 || e == x6) return !n.size;
  if (v6(n)) return !h6(n).length;
  for (var t in n) if (S6.call(n, t)) return !1;
  return !0;
}
var T6 = w6;
const gi = T6;
var ep = {},
  C6 = {
    get exports() {
      return ep;
    },
    set exports(n) {
      ep = n;
    },
  },
  M6 = v1,
  E6 = rh;
function A6(n, e) {
  return n && M6(n, e, E6);
}
var P6 = A6,
  O6 = Wo;
function L6(n, e) {
  return function (t, i) {
    if (t == null) return t;
    if (!O6(t)) return n(t, i);
    for (
      var r = t.length, o = e ? r : -1, p = Object(t);
      (e ? o-- : ++o < r) && i(p[o], o, p) !== !1;

    );
    return t;
  };
}
var D6 = L6,
  R6 = P6,
  I6 = D6,
  k6 = I6(R6),
  F6 = k6,
  N6 = Om;
function B6(n) {
  return typeof n == "function" ? n : N6;
}
var z6 = B6,
  U6 = L1,
  j6 = F6,
  H6 = z6,
  V6 = Fn;
function W6(n, e) {
  var t = V6(n) ? U6 : j6;
  return t(n, H6(e));
}
var G6 = W6;
(function (n) {
  n.exports = G6;
})(C6);
const $6 = sp(ep);
function Su(n, e) {
  n && console.warn(`Warning: ${e}`);
}
function km(n) {
  return n == null;
}
class X6 {
  constructor() {
    this._eventMap = new Map();
  }
  on(e, t) {
    return (
      e &&
        typeof t == "function" &&
        (this._eventMap.has(e) || this._eventMap.set(e, []),
        this._eventMap.get(e).push(t)),
      this
    );
  }
  once(e, t) {
    var i = this;
    if (e && typeof t == "function") {
      const r = function () {
        t(...arguments), i.off(e, r);
      };
      this.on(e, r);
    }
  }
  off(e, t) {
    if (e)
      if (typeof t == "function") {
        const i = this._eventMap.get(e);
        if (Array.isArray(i) && i.length) {
          let r = -1;
          for (; (r = i.findIndex((o) => o === t)) > -1; ) i.splice(r, 1);
        }
      } else km(t) && this._eventMap.delete(e);
    return this;
  }
  emit(e) {
    for (
      var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1;
      r < t;
      r++
    )
      i[r - 1] = arguments[r];
    return this._eventMap.has(e)
      ? (this._eventMap.get(e).forEach((o) => o(...i)), !0)
      : !1;
  }
}
function qs(n) {
  try {
    return n instanceof HTMLElement;
  } catch {
    return (
      typeof n == "object" &&
      n.nodeType === 1 &&
      typeof n.style == "object" &&
      typeof n.ownerDocument == "object"
    );
  }
}
function Y6(n) {
  if (n && typeof n == "object")
    return typeof n.toJSON == "function"
      ? n.toJSON()
      : ["left", "top", "right", "bottom", "width", "height"].reduce(
          (t, i) => ((t[i] = n[i]), t),
          {}
        );
}
function dl(n) {
  n.stopPropagation(), n.preventDefault();
}
function K6(n) {
  return n.length === 1 && n.match(/\S/);
}
function Al(n, e) {
  for (let t = 0; t < n.length; t++)
    n[t] === e ? ((n[t].tabIndex = 0), n[t].focus()) : (n[t].tabIndex = -1);
}
function q6(n) {
  n.length > 0 && Al(n, n[0]);
}
function Z6(n) {
  n.length > 0 && Al(n, n[n.length - 1]);
}
function J6(n, e) {
  let t, i;
  n.length > 0 &&
    (e === n[0] ? (t = n[n.length - 1]) : ((i = n.indexOf(e)), (t = n[i - 1])),
    Al(n, t));
}
function Q6(n, e) {
  let t, i;
  n.length > 0 &&
    (e === n[n.length - 1] ? (t = n[0]) : ((i = n.indexOf(e)), (t = n[i + 1])),
    Al(n, t));
}
function eH(n, e, t, i) {
  let r, o;
  return !n || !t || !i || i.length > 1
    ? -1
    : ((i = i.toLowerCase()),
      (r = n.indexOf(e) + 1),
      r >= n.length && (r = 0),
      (o = t.indexOf(i, r)),
      o === -1 && (o = t.indexOf(i, 0)),
      o >= 0 ? o : -1);
}
function tH(n, e) {
  if (!n) return null;
  for (
    ;
    n.parentElement && st(n.parentElement, "attributes.role.value", "") !== e;

  )
    n = n.parentElement;
  return n.parentElement;
}
function nH(n, e) {
  for (let t = 0; t < n.length; t++) {
    const i = n[t].attributes["data-popupid"];
    if (i && i.value === e) return n[t];
  }
  return null;
}
const Ac = { TOP: /top/i, RIGHT: /right/i, BOTTOM: /bottom/i, LEFT: /left/i },
  Is = { left: 0, top: 0, height: 0, width: 0, scrollLeft: 0, scrollTop: 0 };
let iH = class extends Wi {
  constructor(e) {
    var t;
    super(Object.assign({}, e)),
      (t = this),
      (this.removePortal = () => {
        this._adapter.removePortal();
      }),
      (this.onResize = () => {
        this.calcPosition();
      }),
      (this.delayShow = () => {
        const i = this.getProp("mouseEnterDelay");
        this.clearDelayTimer(),
          i > 0
            ? (this._timer = setTimeout(() => {
                this.show(), this.clearDelayTimer();
              }, i))
            : this.show();
      }),
      (this.show = () => {
        const i = this.getProp("content"),
          r = this.getProp("trigger"),
          o = this.getProp("clickTriggerToHide"),
          { visible: p } = this.getStates();
        p ||
          (this.clearDelayTimer(),
          this._adapter.on("portalInserted", () => {
            this.calcPosition();
          }),
          this._adapter.on("positionUpdated", () => {
            this._togglePortalVisible(!0);
          }),
          this._adapter.insertPortal(i, { left: -9999, top: -9999 }),
          r === "custom" && this._adapter.registerClickOutsideHandler(() => {}),
          (r === "click" || o) &&
            this._adapter.registerClickOutsideHandler(this.hide),
          this._bindScrollEvent(),
          this._bindResizeEvent());
      }),
      (this.calcPosition = function (i, r, o) {
        let p =
          arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
        (i =
          (gi(i) ? t._adapter.getTriggerBounding() : i) ||
          Object.assign({}, Is)),
          (o =
            (gi(o) ? t._adapter.getPopupContainerRect() : o) ||
            Object.assign({}, Is)),
          (r =
            (gi(r) ? t._adapter.getWrapperBounding() : r) ||
            Object.assign({}, Is));
        let a = t.calcPosStyle({
            triggerRect: i,
            wrapperRect: r,
            containerRect: o,
          }),
          s = t.getProp("position");
        if (t.getProp("autoAdjustOverflow")) {
          const {
            position: u,
            isHeightOverFlow: d,
            isWidthOverFlow: l,
          } = t.adjustPosIfNeed(s, a, i, r, o);
          (s !== u || d || l) &&
            ((s = u),
            (a = t.calcPosStyle({
              triggerRect: i,
              wrapperRect: r,
              containerRect: o,
              position: s,
              spacing: null,
              isOverFlow: [d, l],
            })));
        }
        return (
          p &&
            t._mounted &&
            t._adapter.setPosition(
              Object.assign(Object.assign({}, a), { position: s })
            ),
          a
        );
      }),
      (this.delayHide = () => {
        const i = this.getProp("mouseLeaveDelay");
        this.clearDelayTimer(),
          i > 0
            ? (this._timer = setTimeout(() => {
                this.hide(), this.clearDelayTimer();
              }, i))
            : this.hide();
      }),
      (this.hide = () => {
        this.clearDelayTimer(),
          this._togglePortalVisible(!1),
          this._adapter.off("portalInserted"),
          this._adapter.off("positionUpdated");
      }),
      (this.handleContainerKeydown = (i) => {
        const { guardFocus: r, closeOnEsc: o } = this.getProps();
        switch (i && i.key) {
          case "Escape":
            o && this._handleEscKeyDown(i);
            break;
          case "Tab":
            if (r) {
              const p = this._adapter.getContainer(),
                a = this._adapter.getFocusableElements(p);
              a.length &&
                (i.shiftKey
                  ? this._handleContainerShiftTabKeyDown(a, i)
                  : this._handleContainerTabKeyDown(a, i));
            }
            break;
        }
      }),
      (this._timer = null);
  }
  init() {
    const { wrapperId: e } = this.getProps();
    (this._mounted = !0),
      this._bindEvent(),
      this._shouldShow(),
      this._initContainerPosition(),
      e || this._adapter.setId();
  }
  destroy() {
    (this._mounted = !1), this.unBindEvent();
  }
  _bindEvent() {
    const e = this.getProp("trigger"),
      { triggerEventSet: t, portalEventSet: i } = this._generateEvent(e);
    this._bindTriggerEvent(t),
      this._bindPortalEvent(i),
      this._bindResizeEvent();
  }
  unBindEvent() {
    this._adapter.unregisterClickOutsideHandler(),
      this.unBindResizeEvent(),
      this.unBindScrollEvent();
  }
  _bindTriggerEvent(e) {
    this._adapter.registerTriggerEvent(e);
  }
  _bindPortalEvent(e) {
    this._adapter.registerPortalEvent(e);
  }
  _bindResizeEvent() {
    this._adapter.registerResizeHandler(this.onResize);
  }
  unBindResizeEvent() {
    this._adapter.unregisterResizeHandler(this.onResize);
  }
  _adjustPos() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
      t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
      i =
        arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : "reverse",
      r = arguments.length > 3 ? arguments[3] : void 0;
    switch (i) {
      case "reverse":
        return this._reversePos(e, t);
      case "expand":
        return this._expandPos(e, r);
      case "reduce":
        return this._reducePos(e);
      default:
        return this._reversePos(e, t);
    }
  }
  _reversePos() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    if (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) {
      if (Ac.TOP.test(e))
        return e.replace("top", "bottom").replace("Top", "Bottom");
      if (Ac.BOTTOM.test(e))
        return e.replace("bottom", "top").replace("Bottom", "Top");
    } else {
      if (Ac.LEFT.test(e))
        return e.replace("left", "right").replace("Left", "Right");
      if (Ac.RIGHT.test(e))
        return e.replace("right", "left").replace("Right", "Left");
    }
    return e;
  }
  _expandPos() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "",
      t = arguments.length > 1 ? arguments[1] : void 0;
    return e.concat(t);
  }
  _reducePos() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    const t = ["Top", "Bottom", "Left", "Right"].find((i) => e.endsWith(i));
    return t ? e.replace(t, "") : e;
  }
  clearDelayTimer() {
    this._timer && (clearTimeout(this._timer), (this._timer = null));
  }
  _generateEvent(e) {
    const t = this._adapter.getEventName(),
      i = {
        [t.keydown]: (o) => {
          this._handleTriggerKeydown(o);
        },
      };
    let r = {};
    switch (e) {
      case "focus":
        (i[t.focus] = () => {
          this.delayShow();
        }),
          (i[t.blur] = () => {
            this.delayHide();
          }),
          (r = i);
        break;
      case "click":
        (i[t.click] = () => {
          this.show();
        }),
          (r = {});
        break;
      case "hover":
        (i[t.mouseEnter] = () => {
          this.setCache("isClickToHide", !1), this.delayShow();
        }),
          (i[t.mouseLeave] = () => {
            this.delayHide();
          }),
          (i[t.focus] = () => {
            const { disableFocusListener: o } = this.getProps();
            !o && this.delayShow();
          }),
          (i[t.blur] = () => {
            const { disableFocusListener: o } = this.getProps();
            !o && this.delayHide();
          }),
          (r = Object.assign({}, i)),
          this.getProp("clickToHide") &&
            ((r[t.click] = () => {
              this.setCache("isClickToHide", !0), this.hide();
            }),
            (r[t.mouseEnter] = () => {
              this.getCache("isClickToHide") || this.delayShow();
            }));
        break;
    }
    return { triggerEventSet: i, portalEventSet: r };
  }
  _shouldShow() {
    this.getProp("visible") && this.show();
  }
  _togglePortalVisible(e) {
    this.getState("visible") !== e &&
      this._adapter.togglePortalVisible(e, () => {
        e && this._adapter.setInitialFocus(),
          this._adapter.notifyVisibleChange(e);
      });
  }
  _roundPixel(e) {
    return typeof e == "number" ? Math.round(e) : e;
  }
  calcTransformOrigin(e, t, i, r) {
    if (e && t && i != null && r != null) {
      if (this.getProp("transformFromCenter")) {
        if (["topLeft", "bottomLeft"].includes(e))
          return `${this._roundPixel(t.width / 2)}px ${-r * 100}%`;
        if (["topRight", "bottomRight"].includes(e))
          return `calc(100% - ${this._roundPixel(t.width / 2)}px) ${-r * 100}%`;
        if (["leftTop", "rightTop"].includes(e))
          return `${-i * 100}% ${this._roundPixel(t.height / 2)}px`;
        if (["leftBottom", "rightBottom"].includes(e))
          return `${-i * 100}% calc(100% - ${this._roundPixel(
            t.height / 2
          )}px)`;
      }
      return `${-i * 100}% ${-r * 100}%`;
    }
    return null;
  }
  calcPosStyle(e) {
    const { spacing: t, isOverFlow: i } = e,
      r =
        (gi(e.triggerRect)
          ? e.triggerRect
          : this._adapter.getTriggerBounding()) || Object.assign({}, Is),
      o =
        (gi(e.containerRect)
          ? e.containerRect
          : this._adapter.getPopupContainerRect()) || Object.assign({}, Is),
      p =
        (gi(e.wrapperRect)
          ? e.wrapperRect
          : this._adapter.getWrapperBounding()) || Object.assign({}, Is),
      a = e.position != null ? e.position : this.getProp("position"),
      s = t ?? this.getProp("spacing"),
      {
        arrowPointAtCenter: u,
        showArrow: d,
        arrowBounding: l,
      } = this.getProps(),
      c = d && u,
      h = st(l, "width", 24),
      m = st(l, "width", 24),
      g = st(l, "offsetY", 0),
      f = 6,
      v = 6;
    let y,
      _,
      x = 0,
      b = 0;
    const S = r.left + r.width / 2,
      T = r.top + r.height / 2,
      w = f + h / 2,
      P = v + m / 2,
      F = p.height - o.height,
      V = p.width - o.width,
      J = F > 0 ? F : 0,
      z = V > 0 ? V : 0,
      B = i && i[0],
      G = i && i[1],
      ie = S - o.left < o.right - S,
      re = T - o.top < o.bottom - T;
    switch (a) {
      case "top":
        (y = G ? (ie ? o.left + p.width / 2 : o.right - p.width / 2 + z) : S),
          (_ = B ? o.bottom + J : r.top - s),
          (x = -0.5),
          (b = -1);
        break;
      case "topLeft":
        (y = G ? o.left : c ? S - w : r.left),
          (_ = B ? o.bottom + J : r.top - s),
          (b = -1);
        break;
      case "topRight":
        (y = G ? o.right + z : c ? S + w : r.right),
          (_ = B ? o.bottom + J : r.top - s),
          (b = -1),
          (x = -1);
        break;
      case "left":
        (y = G ? o.right + z - s + w : r.left - s),
          (_ = B
            ? re
              ? o.top + p.height / 2
              : o.bottom - p.height / 2 + J
            : T),
          (x = -1),
          (b = -0.5);
        break;
      case "leftTop":
        (y = G ? o.right + z - s + w : r.left - s),
          (_ = B ? o.top : c ? T - P : r.top),
          (x = -1);
        break;
      case "leftBottom":
        (y = G ? o.right + z - s + w : r.left - s),
          (_ = B ? o.bottom + J : c ? T + P : r.bottom),
          (x = -1),
          (b = -1);
        break;
      case "bottom":
        (y = G ? (ie ? o.left + p.width / 2 : o.right - p.width / 2 + z) : S),
          (_ = B ? o.top + P - s : r.top + r.height + s),
          (x = -0.5);
        break;
      case "bottomLeft":
        (y = G ? o.left : c ? S - w : r.left),
          (_ = B ? o.top + P - s : r.top + r.height + s);
        break;
      case "bottomRight":
        (y = G ? o.right + z : c ? S + w : r.right),
          (_ = B ? o.top + P - s : r.top + r.height + s),
          (x = -1);
        break;
      case "right":
        (y = G ? o.left - s + w : r.right + s),
          (_ = B
            ? re
              ? o.top + p.height / 2
              : o.bottom - p.height / 2 + J
            : T),
          (b = -0.5);
        break;
      case "rightTop":
        (y = G ? o.left - s + w : r.right + s),
          (_ = B ? o.top : c ? T - P : r.top);
        break;
      case "rightBottom":
        (y = G ? o.left - s + w : r.right + s),
          (_ = B ? o.bottom + J : c ? T + P : r.bottom),
          (b = -1);
        break;
      case "leftTopOver":
        (y = r.left - s), (_ = r.top - s);
        break;
      case "rightTopOver":
        (y = r.right + s), (_ = r.top - s), (x = -1);
        break;
      case "leftBottomOver":
        (y = r.left - s), (_ = r.bottom + s), (b = -1);
        break;
      case "rightBottomOver":
        (y = r.right + s), (_ = r.bottom + s), (x = -1), (b = -1);
        break;
    }
    const j = this.calcTransformOrigin(a, r, x, b),
      C = this._adapter.containerIsBody();
    if (
      ((y = y - o.left),
      (_ = _ - o.top),
      C && !this._adapter.containerIsRelativeOrAbsolute())
    ) {
      const H = this._adapter.getDocumentElementBounding();
      (y += o.left - H.left), (_ += o.top - H.top);
    }
    (y = C ? y : y + o.scrollLeft), (_ = C ? _ : _ + o.scrollTop);
    const R = r.height;
    if (this.getProp("showArrow") && !u && R <= (m / 2 + g) * 2) {
      const H = R / 2 - (g + m / 2);
      (a.includes("Top") || a.includes("Bottom")) &&
        !a.includes("Over") &&
        (_ = a.includes("Top") ? _ + H : _ - H);
    }
    const A = { left: this._roundPixel(y), top: this._roundPixel(_) };
    let O = "";
    return (
      x != null &&
        ((O += `translateX(${x * 100}%) `),
        Object.defineProperty(A, "translateX", { enumerable: !1, value: x })),
      b != null &&
        ((O += `translateY(${b * 100}%) `),
        Object.defineProperty(A, "translateY", { enumerable: !1, value: b })),
      j != null && (A.transformOrigin = j),
      O && (A.transform = O),
      A
    );
  }
  isLR() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return e.includes("left") || e.includes("right");
  }
  isTB() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return e.includes("top") || e.includes("bottom");
  }
  isReverse(e, t, i) {
    return e < i && t > i;
  }
  isOverFlow(e, t, i) {
    return e < i && t < i;
  }
  isHalfOverFlow(e, t, i) {
    return e < i || t < i;
  }
  isHalfAllEnough(e, t, i) {
    return e >= i || t >= i;
  }
  getReverse(e, t, i, r) {
    return (e && r) || (i && t) || (i && r);
  }
  adjustPosIfNeed(e, t, i, r, o) {
    const { innerWidth: p, innerHeight: a } = window,
      { spacing: s, margin: u } = this.getProps(),
      d = typeof u == "number" ? u : u.marginLeft,
      l = typeof u == "number" ? u : u.marginTop,
      c = typeof u == "number" ? u : u.marginRight,
      h = typeof u == "number" ? u : u.marginBottom;
    let m = !1,
      g = !1;
    if (r.width > 0 && r.height > 0) {
      const f = i.left,
        v = i.right,
        y = i.top,
        _ = i.bottom,
        x = p - f,
        b = a - y,
        S = p - v,
        T = a - _,
        w = r.width > i.width,
        P = r.height > i.height,
        F = y - l < r.height + s && T - h > r.height + s,
        V = f - d < r.width + s && S - c > r.width + s,
        J = T - h < r.height + s && y - l > r.height + s,
        z = S - c < r.width + s && f - d > r.width + s;
      b - h < r.height + s && _ - l > r.height + s,
        _ - l < r.height + s && b - h > r.height + s;
      const B = b < r.height && _ > r.height,
        G = _ < r.height && b > r.height,
        ie = x < r.width && v > r.width,
        re = v < r.width && x > r.width,
        j = b < r.height + s && _ > r.height + s,
        C = _ < r.height + s && b > r.height + s,
        R = x < r.width && v > r.width,
        A = v < r.width && x > r.width,
        O = y - o.top,
        H = f - o.left,
        I = O + i.height,
        E = H + i.width,
        k = o.bottom - _,
        $ = o.right - v,
        Y = k + i.height,
        X = $ + i.width,
        ee = this.isReverse(O - l, k - h, r.height + s),
        he = this.isReverse(H - d, $ - c, r.width + s),
        pe = this.isReverse(k - h, O - l, r.height + s),
        Z = this.isReverse($ - c, H - d, r.width + s);
      this.isReverse(Y - h, I - l, r.height + s),
        this.isReverse(I - l, Y - h, r.height + s);
      const K = this.isReverse(Y, I, r.height),
        ce = this.isReverse(I, Y, r.height),
        ue = this.isReverse(X, E, r.width),
        oe = this.isReverse(E, X, r.width),
        le = i.height / 2,
        ge = i.width / 2,
        Re = this.isOverFlow(y - l, T - h, r.height + s),
        Me = this.isOverFlow(f - d, S - c, r.width + s),
        L = this.isOverFlow(_ - l, b - h, r.height + s),
        D = this.isOverFlow(v - d, x - c, r.width + s),
        ne = this.isHalfOverFlow(_ - le, b - le, r.height / 2),
        de = this.isHalfOverFlow(v - ge, x - ge, r.width / 2),
        ye = this.isHalfAllEnough(_ - le, b - le, r.height / 2),
        _e = this.isHalfAllEnough(v - ge, x - ge, r.width / 2),
        Pe = this.isOverFlow(O - l, k - h, r.height + s),
        U = this.isOverFlow(H - d, $ - c, r.width + s),
        te = this.isOverFlow(I - l, Y - h, r.height + s),
        we = this.isOverFlow(E - d, X - c, r.width + s),
        Se = this.isHalfOverFlow(I - le, Y - le, r.height / 2),
        Ee = this.isHalfOverFlow(E - ge, X - ge, r.width / 2),
        Le = this.isHalfAllEnough(I - le, Y - le, r.height / 2),
        De = this.isHalfAllEnough(E - ge, X - ge, r.width / 2),
        He = this.getReverse(Re, Pe, F, ee),
        We = this.getReverse(Me, U, V, he),
        it = this.getReverse(Re, Pe, J, pe),
        q = this.getReverse(Me, U, z, Z),
        fe = this.getReverse(L, te, B, K),
        xe = this.getReverse(L, te, G, ce),
        Ae = this.getReverse(D, we, ie, ue),
        Ie = this.getReverse(D, we, re, oe),
        et = ne && Se,
        Ct = de && Ee;
      switch (e) {
        case "top":
          He && (e = this._adjustPos(e, !0)),
            Ct &&
              (Ae || Ie) &&
              (e = this._adjustPos(e, !0, "expand", Ae ? "Right" : "Left"));
          break;
        case "topLeft":
          He && (e = this._adjustPos(e, !0)),
            Ae && w && (e = this._adjustPos(e)),
            g && (_e || De) && (e = this._adjustPos(e, !0, "reduce"));
          break;
        case "topRight":
          He && (e = this._adjustPos(e, !0)),
            Ie && w && (e = this._adjustPos(e)),
            g && (_e || De) && (e = this._adjustPos(e, !0, "reduce"));
          break;
        case "left":
          We && (e = this._adjustPos(e)),
            et &&
              (fe || xe) &&
              (e = this._adjustPos(e, !1, "expand", fe ? "Bottom" : "Top"));
          break;
        case "leftTop":
          We && (e = this._adjustPos(e)),
            fe && P && (e = this._adjustPos(e, !0)),
            m && (ye || Le) && (e = this._adjustPos(e, !1, "reduce"));
          break;
        case "leftBottom":
          We && (e = this._adjustPos(e)),
            xe && P && (e = this._adjustPos(e, !0)),
            m && (ye || Le) && (e = this._adjustPos(e, !1, "reduce"));
          break;
        case "bottom":
          it && (e = this._adjustPos(e, !0)),
            Ct &&
              (Ae || Ie) &&
              (e = this._adjustPos(e, !0, "expand", Ae ? "Right" : "Left"));
          break;
        case "bottomLeft":
          it && (e = this._adjustPos(e, !0)),
            Ae && w && (e = this._adjustPos(e)),
            g && (_e || De) && (e = this._adjustPos(e, !0, "reduce"));
          break;
        case "bottomRight":
          it && (e = this._adjustPos(e, !0)),
            Ie && w && (e = this._adjustPos(e)),
            g && (_e || De) && (e = this._adjustPos(e, !0, "reduce"));
          break;
        case "right":
          q && (e = this._adjustPos(e)),
            et &&
              (fe || xe) &&
              (e = this._adjustPos(e, !1, "expand", fe ? "Bottom" : "Top"));
          break;
        case "rightTop":
          q && (e = this._adjustPos(e)),
            fe && P && (e = this._adjustPos(e, !0)),
            m && (ye || Le) && (e = this._adjustPos(e, !1, "reduce"));
          break;
        case "rightBottom":
          q && (e = this._adjustPos(e)),
            xe && P && (e = this._adjustPos(e, !0)),
            m && (ye || Le) && (e = this._adjustPos(e, !1, "reduce"));
          break;
        case "leftTopOver":
          j && (e = this._adjustPos(e, !0)), R && (e = this._adjustPos(e));
          break;
        case "leftBottomOver":
          C && (e = this._adjustPos(e, !0)), R && (e = this._adjustPos(e));
          break;
        case "rightTopOver":
          j && (e = this._adjustPos(e, !0)), A && (e = this._adjustPos(e));
          break;
        case "rightBottomOver":
          C && (e = this._adjustPos(e, !0)), A && (e = this._adjustPos(e));
          break;
      }
      this.isTB(e) &&
        ((m = Re && Pe),
        e === "top" || e === "bottom"
          ? (g = (de && Ee) || v < 0 || S < 0)
          : (g = (D && we) || v < 0 || S < 0)),
        this.isLR(e) &&
          ((g = Me && U),
          e === "left" || e === "right"
            ? (m = (ne && Se) || y < 0 || b < 0)
            : (m = (L && te) || y < 0 || b < 0));
    }
    return { position: e, isHeightOverFlow: m, isWidthOverFlow: g };
  }
  _bindScrollEvent() {
    this._adapter.registerScrollHandler(() => this.calcPosition());
  }
  unBindScrollEvent() {
    this._adapter.unregisterScrollHandler();
  }
  _initContainerPosition() {
    this._adapter.updateContainerPosition();
  }
  _handleTriggerKeydown(e) {
    const { closeOnEsc: t, disableArrowKeyDown: i } = this.getProps(),
      r = this._adapter.getContainer(),
      o = this._adapter.getFocusableElements(r),
      p = o.length;
    switch (e && e.key) {
      case "Escape":
        dl(e), t && this._handleEscKeyDown(e);
        break;
      case "ArrowUp":
        !i && p && this._handleTriggerArrowUpKeydown(o, e);
        break;
      case "ArrowDown":
        !i && p && this._handleTriggerArrowDownKeydown(o, e);
        break;
    }
  }
  _focusTrigger() {
    const {
      trigger: e,
      returnFocusOnClose: t,
      preventScroll: i,
    } = this.getProps();
    if (t && e !== "custom") {
      const r = this._adapter.getTriggerNode();
      r && "focus" in r && r.focus({ preventScroll: i });
    }
  }
  _handleEscKeyDown(e) {
    const { trigger: t } = this.getProps();
    t !== "custom" && (this._focusTrigger(), this.hide()),
      this._adapter.notifyEscKeydown(e);
  }
  _handleContainerTabKeyDown(e, t) {
    const { preventScroll: i } = this.getProps(),
      r = this._adapter.getActiveElement();
    e[e.length - 1] === r &&
      (e[0].focus({ preventScroll: i }), t.preventDefault());
  }
  _handleContainerShiftTabKeyDown(e, t) {
    const { preventScroll: i } = this.getProps(),
      r = this._adapter.getActiveElement();
    e[0] === r &&
      (e[e.length - 1].focus({ preventScroll: i }), t.preventDefault());
  }
  _handleTriggerArrowDownKeydown(e, t) {
    const { preventScroll: i } = this.getProps();
    e[0].focus({ preventScroll: i }), t.preventDefault();
  }
  _handleTriggerArrowUpKeydown(e, t) {
    const { preventScroll: i } = this.getProps();
    e[e.length - 1].focus({ preventScroll: i }), t.preventDefault();
  }
};
const rH = { PREFIX: `${Ye}-tooltip` },
  ao = {
    POSITION_SET: [
      "top",
      "topLeft",
      "topRight",
      "left",
      "leftTop",
      "leftBottom",
      "right",
      "rightTop",
      "rightBottom",
      "bottom",
      "bottomLeft",
      "bottomRight",
      "leftTopOver",
      "rightTopOver",
      "leftBottomOver",
      "rightBottomOver",
    ],
    TRIGGER_SET: ["hover", "focus", "click", "custom"],
    STATUS_DISABLED: "disabled",
    STATUS_LOADING: "loading",
  },
  tr = {
    ARROW_BOUNDING: { offsetX: 0, offsetY: 2, width: 24, height: 7 },
    DEFAULT_Z_INDEX: 1060,
    MOUSE_ENTER_DELAY: 50,
    MOUSE_LEAVE_DELAY: 50,
    SPACING: 8,
    MARGIN: 0,
  };
function wu(n) {
  return `${n}-${new Date().getTime()}-${Math.random()}`;
}
function sH() {
  var n, e;
  try {
    return (e =
      (n = crypto == null ? void 0 : crypto.randomUUID) === null || n === void 0
        ? void 0
        : n.call(crypto)) !== null && e !== void 0
      ? e
      : String(1e7 + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (t) =>
          (
            Number(t) ^
            (crypto.getRandomValues(new Uint8Array(1))[0] &
              (15 >> (Number(t) / 4)))
          ).toString(16)
        );
  } catch {
    return wu("semi");
  }
}
function $1() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const { prefix: e = "", length: t = 7 } = n,
    i = "0123456789abcdefghijklmnopqrstuvwxyz",
    r = i.length;
  let o = "";
  for (let p = 0; p < t; p++) {
    const a = Math.floor(Math.random() * r);
    o += i.charAt(a);
  }
  return e ? `${e}-${o}` : o;
}
var oH = Pm,
  aH = Ho,
  lH = ih,
  qy = qn,
  cH = Qu;
function uH(n, e, t, i) {
  if (!qy(n)) return n;
  e = aH(e, n);
  for (var r = -1, o = e.length, p = o - 1, a = n; a != null && ++r < o; ) {
    var s = cH(e[r]),
      u = t;
    if (s === "__proto__" || s === "constructor" || s === "prototype") return n;
    if (r != p) {
      var d = a[s];
      (u = i ? i(d, s, a) : void 0),
        u === void 0 && (u = qy(d) ? d : lH(e[r + 1]) ? [] : {});
    }
    oH(a, s, u), (a = a[s]);
  }
  return n;
}
var X1 = uH,
  hH = X1;
function fH(n, e, t) {
  return n == null ? n : hH(n, e, t);
}
var dH = fH,
  pH = Rm,
  mH = 1,
  gH = 4;
function vH(n, e) {
  return (e = typeof e == "function" ? e : void 0), pH(n, mH | gH, e);
}
var yH = vH;
function Zy(n, e) {
  n && typeof n.stopPropagation == "function" && n.stopPropagation(),
    !e &&
      n.nativeEvent &&
      typeof n.nativeEvent.stopImmediatePropagation == "function" &&
      n.nativeEvent.stopImmediatePropagation();
}
function Jy(n, e) {
  return yH(n, (t) => {
    if (typeof e == "function") return e(t);
    if (
      typeof t == "function" ||
      W.isValidElement(t) ||
      Object.prototype.toString.call(t) === "[object Error]"
    )
      return t;
    if (Array.isArray(t) && t.length === 0) {
      const i = Object.keys(t);
      if (i.length) {
        const r = [];
        i.forEach((o) => {
          dH(r, o, t[o]);
        });
        try {
          Su(
            st(process, "env.NODE_ENV") !== "production",
            `[Semi] You may use an out-of-bounds array. In some cases, your program may not behave as expected.
                    The maximum length of an array is 4294967295.
                    Please check whether the array subscript in your data exceeds the maximum value of the JS array subscript`
          );
        } catch {}
        return r;
      } else return;
    }
  });
}
const Y1 = (n) => W.isValidElement(n) && st(n.type, "elementType") === "Icon";
function _H() {
  return document ? document.activeElement : null;
}
function xH(n) {
  if (!qs(n)) return [];
  const t = [
    "input:not([disabled]):not([tabindex='-1'])",
    "textarea:not([disabled]):not([tabindex='-1'])",
    "button:not([disabled]):not([tabindex='-1'])",
    "a[href]:not([tabindex='-1'])",
    "select:not([disabled]):not([tabindex='-1'])",
    "area[href]:not([tabindex='-1'])",
    "iframe:not([tabindex='-1'])",
    "object:not([tabindex='-1'])",
    "*[tabindex]:not([tabindex='-1'])",
    "*[contenteditable]:not([tabindex='-1'])",
  ].join(",");
  return Array.from(n.querySelectorAll(t));
}
const bH = W.createContext({}),
  Pl = bH;
const SH = () => document.body;
class sh extends Ce.PureComponent {
  constructor(e) {
    var t;
    super(e),
      (t = this),
      (this.addStyle = function () {
        let i =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (t.el) for (const r of Object.keys(i)) t.el.style[r] = i[r];
      }),
      (this.addClass = function (i) {
        const { direction: r } = t.context;
        for (
          var o = arguments.length, p = new Array(o > 1 ? o - 1 : 0), a = 1;
          a < o;
          a++
        )
          p[a - 1] = arguments[a];
        const s = Be(i, ...p, { [`${i}-rtl`]: r === "rtl" });
        t.el && (t.el.className = s);
      });
    try {
      this.el = document.createElement("div");
    } catch {}
    this.state = { container: void 0 };
  }
  componentDidMount() {
    this.el || (this.el = document.createElement("div"));
    const { state: e, props: t, context: i } = this,
      o = (t.getPopupContainer || i.getPopupContainer || SH)();
    o !== e.container &&
      (o.appendChild(this.el),
      this.addStyle(t.style),
      this.addClass(t.prefixCls, t.className),
      this.setState({ container: o }));
  }
  componentDidUpdate(e) {
    const { didUpdate: t } = this.props;
    t && t(e);
  }
  componentWillUnmount() {
    const { container: e } = this.state;
    e && e.removeChild(this.el);
  }
  render() {
    const { state: e, props: t } = this;
    return e.container ? co.createPortal(t.children, this.el) : null;
  }
}
sh.contextType = Pl;
sh.defaultProps = { prefixCls: `${Ye}-portal` };
sh.propTypes = {
  children: M.node,
  prefixCls: M.string,
  getPopupContainer: M.func,
  className: M.string,
  didUpdate: M.func,
};
const wH = sh;
var TH =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const CH = (n) => {
    const { className: e, style: t } = n,
      i = TH(n, ["className", "style"]);
    return W.createElement(
      "svg",
      Object.assign({ "aria-hidden": !0, className: e, style: t }, i, {
        width: "24",
        height: "7",
        viewBox: "0 0 24 7",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg",
      }),
      W.createElement("path", {
        d: "M24 0V1C20 1 18.5 2 16.5 4C14.5 6 14 7 12 7C10 7 9.5 6 7.5 4C5.5 2 4 1 0 1V0H24Z",
      })
    );
  },
  MH = CH;
var EH =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const AH = (n) => {
    const { className: e, style: t } = n,
      i = EH(n, ["className", "style"]);
    return W.createElement(
      "svg",
      Object.assign({ "aria-hidden": !0, className: e, style: t }, i, {
        width: "7",
        height: "24",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor",
      }),
      W.createElement("path", {
        d: "M0 0L1 0C1 4, 2 5.5, 4 7.5S7,10 7,12S6 14.5, 4 16.5S1,20 1,24L0 24L0 0z",
      })
    );
  },
  PH = AH,
  OH = M.shape({
    offsetX: M.number,
    offsetY: M.number,
    width: M.number,
    height: M.number,
  });
class K1 extends W.Component {
  constructor(e) {
    super(e),
      (this.handleAnimationStart = () => {
        var t, i;
        (i = (t = this.props).onAnimationStart) === null ||
          i === void 0 ||
          i.call(t);
      }),
      (this.handleAnimationEnd = () => {
        this.setState(
          {
            currentClassName: this.props.endClassName,
            extraStyle: { animationFillMode: this.props.fillMode },
            isAnimating: !1,
          },
          () => {
            var t, i;
            (i = (t = this.props).onAnimationEnd) === null ||
              i === void 0 ||
              i.call(t, !1);
          }
        );
      }),
      (this.state = {
        currentClassName: this.props.startClassName,
        extraStyle: { animationFillMode: this.props.fillMode },
        isAnimating: !0,
      });
  }
  componentDidMount() {
    var e, t, i, r;
    (t = (e = this.props).onAnimationStart) === null ||
      t === void 0 ||
      t.call(e),
      this.props.motion ||
        ((r = (i = this.props).onAnimationEnd) === null ||
          r === void 0 ||
          r.call(i, !1),
        this.setState({ isAnimating: !1 }));
  }
  componentDidUpdate(e, t, i) {
    const r = Object.keys(this.props).filter((o) => !bi(this.props[o], e[o]));
    r.includes("animationState"),
      (r.includes("startClassName") ||
        r.includes("replayKey") ||
        r.includes("motion")) &&
        this.setState(
          {
            currentClassName: this.props.startClassName,
            extraStyle: { animationFillMode: this.props.fillMode },
            isAnimating: !0,
          },
          () => {
            var o, p, a, s;
            (p = (o = this.props).onAnimationStart) === null ||
              p === void 0 ||
              p.call(o),
              this.props.motion ||
                ((s = (a = this.props).onAnimationEnd) === null ||
                  s === void 0 ||
                  s.call(a, this.state.isAnimating),
                this.setState({ isAnimating: !1 }));
          }
        );
  }
  render() {
    var e;
    return this.props.motion
      ? this.props.children({
          animationClassName:
            (e = this.state.currentClassName) !== null && e !== void 0 ? e : "",
          animationStyle: this.state.extraStyle,
          animationEventsNeedBind: {
            onAnimationStart: this.handleAnimationStart,
            onAnimationEnd: this.handleAnimationEnd,
          },
          isAnimating: this.state.isAnimating,
        })
      : this.props.children({
          animationClassName: "",
          animationStyle: {},
          animationEventsNeedBind: {},
          isAnimating: this.state.isAnimating,
        });
  }
}
K1.defaultProps = { motion: !0, replayKey: "" };
const Fm = K1;
var Qy =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const tp = rH.PREFIX,
  LH = ao.POSITION_SET,
  DH = ao.TRIGGER_SET,
  RH = ["flex", "block", "table", "flow-root", "grid"],
  IH = () => document.body;
class gs extends bn {
  constructor(e) {
    super(e),
      (this.setContainerEl = (t) => (this.containerEl = { current: t })),
      (this.isSpecial = (t) => {
        if (qs(t)) return Boolean(t.disabled);
        if (Ce.isValidElement(t)) {
          if (st(t, "props.disabled")) return ao.STATUS_DISABLED;
          const r = st(t, "props.loading"),
            o =
              (!gi(t) && !gi(t.type) && t.type.name === "Button") ||
              t.type.name === "IconButton";
          if (r && o) return ao.STATUS_LOADING;
        }
        return !1;
      }),
      (this.didLeave = () => {
        this.foundation.removePortal(), this.foundation.unBindEvent();
      }),
      (this.renderIcon = () => {
        const { placement: t } = this.state,
          { showArrow: i, prefixCls: r, style: o } = this.props;
        let p = null;
        const a = Be([`${r}-icon-arrow`]),
          s = st(o, "backgroundColor"),
          u =
            t.includes("left") || t.includes("right")
              ? W.createElement(PH, null)
              : W.createElement(MH, null);
        return (
          i &&
            (Ce.isValidElement(i)
              ? (p = i)
              : (p = W.cloneElement(u, {
                  className: a,
                  style: { color: s, fill: "currentColor" },
                }))),
          p
        );
      }),
      (this.handlePortalInnerClick = (t) => {
        this.props.clickToHide && this.foundation.hide(),
          this.props.stopPropagation && Zy(t);
      }),
      (this.handlePortalMouseDown = (t) => {
        this.props.stopPropagation && Zy(t);
      }),
      (this.handlePortalInnerKeyDown = (t) => {
        this.foundation.handleContainerKeydown(t);
      }),
      (this.renderContentNode = (t) => {
        const i = { initialFocusRef: this.initialFocusRef };
        return Bo(t) ? t(i) : t;
      }),
      (this.renderPortal = () => {
        const {
            containerStyle: t = {},
            visible: i,
            portalEventSet: r,
            placement: o,
            transitionState: p,
            id: a,
            isPositionUpdated: s,
          } = this.state,
          {
            prefixCls: u,
            content: d,
            showArrow: l,
            style: c,
            motion: h,
            role: m,
            zIndex: g,
          } = this.props,
          f = this.renderContentNode(d),
          { className: v } = this.props,
          y = this.context.direction,
          _ = Be(v, {
            [`${u}-wrapper`]: !0,
            [`${u}-wrapper-show`]: i,
            [`${u}-with-arrow`]: Boolean(l),
            [`${u}-rtl`]: y === "rtl",
          }),
          x = this.renderIcon(),
          b = Im(t, h ? ["transformOrigin"] : void 0),
          S = st(t, "transformOrigin"),
          T = st(c, "opacity"),
          w = T || 1,
          P = W.createElement(
            Fm,
            {
              fillMode: "forwards",
              animationState: p,
              motion: h && s,
              startClassName:
                p === "enter" ? `${tp}-animation-show` : `${tp}-animation-hide`,
              onAnimationEnd: () => {
                var F, V;
                p === "leave" &&
                  (this.didLeave(),
                  (V = (F = this.props).afterClose) === null ||
                    V === void 0 ||
                    V.call(F));
              },
            },
            (F) => {
              let {
                animationStyle: V,
                animationClassName: J,
                animationEventsNeedBind: z,
              } = F;
              return W.createElement(
                "div",
                Object.assign(
                  {
                    className: Be(_, J),
                    style: Object.assign(
                      Object.assign(
                        Object.assign(Object.assign({}, V), {
                          transformOrigin: S,
                        }),
                        c
                      ),
                      { opacity: s ? w : "0" }
                    ),
                  },
                  r,
                  z,
                  { role: m, "x-placement": o, id: a }
                ),
                f,
                x
              );
            }
          );
        return W.createElement(
          wH,
          {
            getPopupContainer: this.props.getPopupContainer,
            style: { zIndex: g },
          },
          W.createElement(
            "div",
            {
              className: `${Ye}-portal-inner`,
              style: b,
              ref: this.setContainerEl,
              onClick: this.handlePortalInnerClick,
              onMouseDown: this.handlePortalMouseDown,
              onKeyDown: this.handlePortalInnerKeyDown,
            },
            P
          )
        );
      }),
      (this.wrapSpan = (t) => {
        const { wrapperClassName: i } = this.props,
          r = st(t, "props.style.display"),
          o = st(t, "props.block"),
          p = { display: "inline-block" };
        return (
          (o || RH.includes(r)) && (p.width = "100%"),
          W.createElement("span", { className: i, style: p }, t)
        );
      }),
      (this.mergeEvents = (t, i) => {
        const r = {};
        return (
          $6(i, (o, p) => {
            typeof o == "function" &&
              (r[p] = function () {
                o(...arguments),
                  t && typeof t[p] == "function" && t[p](...arguments);
              });
          }),
          r
        );
      }),
      (this.getPopupId = () => this.state.id),
      (this.state = {
        visible: !1,
        transitionState: "",
        triggerEventSet: {},
        portalEventSet: {},
        containerStyle: {},
        isInsert: !1,
        placement: e.position || "top",
        transitionStyle: {},
        isPositionUpdated: !1,
        id: e.wrapperId,
      }),
      (this.foundation = new iH(this.adapter)),
      (this.eventManager = new X6()),
      (this.triggerEl = W.createRef()),
      (this.containerEl = W.createRef()),
      (this.initialFocusRef = W.createRef()),
      (this.clickOutsideHandler = null),
      (this.resizeHandler = null),
      (this.isWrapped = !1),
      (this.containerPosition = void 0);
  }
  get adapter() {
    var e = this;
    return Object.assign(Object.assign({}, super.adapter), {
      on: function () {
        return e.eventManager.on(...arguments);
      },
      off: function () {
        return e.eventManager.off(...arguments);
      },
      insertPortal: (t, i) => {
        var r = Qy(i, ["position"]);
        this.setState(
          {
            isInsert: !0,
            transitionState: "enter",
            containerStyle: Object.assign(
              Object.assign({}, this.state.containerStyle),
              r
            ),
          },
          () => {
            setTimeout(() => {
              this.eventManager.emit("portalInserted");
            }, 0);
          }
        );
      },
      removePortal: () => {
        this.setState({ isInsert: !1, isPositionUpdated: !1 });
      },
      getEventName: () => ({
        mouseEnter: "onMouseEnter",
        mouseLeave: "onMouseLeave",
        mouseOut: "onMouseOut",
        mouseOver: "onMouseOver",
        click: "onClick",
        focus: "onFocus",
        blur: "onBlur",
        keydown: "onKeyDown",
      }),
      registerTriggerEvent: (t) => {
        this.setState({ triggerEventSet: t });
      },
      registerPortalEvent: (t) => {
        this.setState({ portalEventSet: t });
      },
      getTriggerBounding: () => {
        const t = this.adapter.getTriggerNode();
        return (this.triggerEl.current = t), t && t.getBoundingClientRect();
      },
      getPopupContainerRect: () => {
        const t = this.getPopupContainer();
        let i = null;
        if (t && qs(t)) {
          const r = Y6(t.getBoundingClientRect());
          i = Object.assign(Object.assign({}, r), {
            scrollLeft: t.scrollLeft,
            scrollTop: t.scrollTop,
          });
        }
        return i;
      },
      containerIsBody: () => this.getPopupContainer() === document.body,
      containerIsRelative: () => {
        const t = this.getPopupContainer();
        return (
          window.getComputedStyle(t).getPropertyValue("position") === "relative"
        );
      },
      containerIsRelativeOrAbsolute: () =>
        ["relative", "absolute"].includes(this.containerPosition),
      getWrapperBounding: () => {
        const t = this.containerEl && this.containerEl.current;
        return t && t.getBoundingClientRect();
      },
      getDocumentElementBounding: () =>
        document.documentElement.getBoundingClientRect(),
      setPosition: (t) => {
        var { position: i } = t,
          r = Qy(t, ["position"]);
        this.setState(
          {
            containerStyle: Object.assign(
              Object.assign({}, this.state.containerStyle),
              r
            ),
            placement: i,
            isPositionUpdated: !0,
          },
          () => {
            this.eventManager.emit("positionUpdated");
          }
        );
      },
      updatePlacementAttr: (t) => {
        this.setState({ placement: t });
      },
      togglePortalVisible: (t, i) => {
        const r = {};
        (r.transitionState = t ? "enter" : "leave"),
          (r.visible = t),
          this.mounted &&
            this.setState(r, () => {
              i();
            });
      },
      registerClickOutsideHandler: (t) => {
        this.clickOutsideHandler &&
          this.adapter.unregisterClickOutsideHandler(),
          (this.clickOutsideHandler = (i) => {
            if (!this.mounted) return !1;
            let r = this.triggerEl && this.triggerEl.current,
              o = this.containerEl && this.containerEl.current;
            (r = Yr.findDOMNode(r)),
              (o = Yr.findDOMNode(o)),
              ((r && !r.contains(i.target) && o && !o.contains(i.target)) ||
                (this.props.clickTriggerToHide && r && r.contains(i.target))) &&
                (this.props.onClickOutSide(i), t());
          }),
          window.addEventListener("mousedown", this.clickOutsideHandler);
      },
      unregisterClickOutsideHandler: () => {
        this.clickOutsideHandler &&
          (window.removeEventListener("mousedown", this.clickOutsideHandler),
          (this.clickOutsideHandler = null));
      },
      registerResizeHandler: (t) => {
        this.resizeHandler && this.adapter.unregisterResizeHandler(),
          (this.resizeHandler = sy((i) => {
            if (!this.mounted) return !1;
            t(i);
          }, 10)),
          window.addEventListener("resize", this.resizeHandler, !1);
      },
      unregisterResizeHandler: () => {
        this.resizeHandler &&
          (window.removeEventListener("resize", this.resizeHandler, !1),
          (this.resizeHandler = null));
      },
      notifyVisibleChange: (t) => {
        this.props.onVisibleChange(t);
      },
      registerScrollHandler: (t) => {
        this.scrollHandler && this.adapter.unregisterScrollHandler(),
          (this.scrollHandler = sy((i) => {
            if (!this.mounted) return !1;
            const r = this.adapter.getTriggerNode();
            if (i.target.contains(r)) {
              const p = { x: i.target.scrollLeft, y: i.target.scrollTop };
              t(p);
            }
          }, 10)),
          window.addEventListener("scroll", this.scrollHandler, !0);
      },
      unregisterScrollHandler: () => {
        this.scrollHandler &&
          (window.removeEventListener("scroll", this.scrollHandler, !0),
          (this.scrollHandler = null));
      },
      canMotion: () => Boolean(this.props.motion),
      updateContainerPosition: () => {
        const t = this.getPopupContainer();
        if (t && qs(t)) {
          const r = window.getComputedStyle(t).getPropertyValue("position");
          this.containerPosition = r;
        }
      },
      getContainerPosition: () => this.containerPosition,
      getContainer: () => this.containerEl && this.containerEl.current,
      getTriggerNode: () => {
        let t = this.triggerEl.current;
        return (
          qs(this.triggerEl.current) ||
            (t = Yr.findDOMNode(this.triggerEl.current)),
          t
        );
      },
      getFocusableElements: (t) => xH(t),
      getActiveElement: () => _H(),
      setInitialFocus: () => {
        const { preventScroll: t } = this.props,
          i = st(this, "initialFocusRef.current");
        i && "focus" in i && i.focus({ preventScroll: t });
      },
      notifyEscKeydown: (t) => {
        this.props.onEscKeyDown(t);
      },
      setId: () => {
        this.setState({ id: $1() });
      },
    });
  }
  componentDidMount() {
    (this.mounted = !0),
      (this.getPopupContainer =
        this.props.getPopupContainer || this.context.getPopupContainer || IH),
      this.foundation.init();
  }
  componentWillUnmount() {
    (this.mounted = !1), this.foundation.destroy();
  }
  rePosition() {
    return this.foundation.calcPosition();
  }
  componentDidUpdate(e, t) {
    Su(
      this.props.mouseLeaveDelay < this.props.mouseEnterDelay,
      "[Semi Tooltip] 'mouseLeaveDelay' cannot be less than 'mouseEnterDelay', which may cause the dropdown layer to not be hidden."
    ),
      e.visible !== this.props.visible &&
        (["hover", "focus"].includes(this.props.trigger)
          ? this.props.visible
            ? this.foundation.delayShow()
            : this.foundation.delayHide()
          : this.props.visible
          ? this.foundation.show()
          : this.foundation.hide()),
      bi(e.rePosKey, this.props.rePosKey) || this.rePosition();
  }
  render() {
    const { isInsert: e, triggerEventSet: t, visible: i, id: r } = this.state,
      { wrapWhenSpecial: o, role: p, trigger: a } = this.props;
    let { children: s } = this.props;
    const u = Object.assign({}, st(s, "props.style")),
      d = {};
    if (o) {
      const h = this.isSpecial(s);
      h
        ? ((u.pointerEvents = "none"),
          h === ao.STATUS_DISABLED && (d.cursor = "not-allowed"),
          (s = Ce.cloneElement(s, { style: u })),
          a !== "custom" && (s = this.wrapSpan(s)),
          (this.isWrapped = !0))
        : Ce.isValidElement(s) ||
          ((s = this.wrapSpan(s)), (this.isWrapped = !0));
    }
    let l = {};
    p === "dialog"
      ? ((l["aria-expanded"] = i ? "true" : "false"),
        (l["aria-haspopup"] = "dialog"),
        (l["aria-controls"] = r))
      : (l["aria-describedby"] = r);
    const c = W.cloneElement(
      s,
      Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, l), s.props),
          this.mergeEvents(s.props, t)
        ),
        {
          style: Object.assign(Object.assign({}, st(s, "props.style")), d),
          className: Be(st(s, "props.className")),
          ref: (h) => {
            this.triggerEl.current = h;
            const { ref: m } = s;
            typeof m == "function"
              ? m(h)
              : m && typeof m == "object" && (m.current = h);
          },
          tabIndex: s.props.tabIndex || 0,
          "data-popupid": r,
        }
      )
    );
    return W.createElement(W.Fragment, null, e ? this.renderPortal() : null, c);
  }
}
gs.contextType = Pl;
gs.propTypes = {
  children: M.node,
  motion: M.bool,
  autoAdjustOverflow: M.bool,
  position: M.oneOf(LH),
  getPopupContainer: M.func,
  mouseEnterDelay: M.number,
  mouseLeaveDelay: M.number,
  trigger: M.oneOf(DH).isRequired,
  className: M.string,
  wrapperClassName: M.string,
  clickToHide: M.bool,
  clickTriggerToHide: M.bool,
  visible: M.bool,
  style: M.object,
  content: M.oneOfType([M.node, M.func]),
  prefixCls: M.string,
  onVisibleChange: M.func,
  onClickOutSide: M.func,
  spacing: M.number,
  margin: M.oneOfType([M.number, M.object]),
  showArrow: M.oneOfType([M.bool, M.node]),
  zIndex: M.number,
  rePosKey: M.oneOfType([M.string, M.number]),
  arrowBounding: OH,
  transformFromCenter: M.bool,
  arrowPointAtCenter: M.bool,
  stopPropagation: M.bool,
  role: M.string,
  wrapWhenSpecial: M.bool,
  guardFocus: M.bool,
  returnFocusOnClose: M.bool,
  preventScroll: M.bool,
};
gs.defaultProps = {
  arrowBounding: tr.ARROW_BOUNDING,
  autoAdjustOverflow: !0,
  arrowPointAtCenter: !0,
  trigger: "hover",
  transformFromCenter: !0,
  position: "top",
  prefixCls: tp,
  role: "tooltip",
  mouseEnterDelay: tr.MOUSE_ENTER_DELAY,
  mouseLeaveDelay: tr.MOUSE_LEAVE_DELAY,
  motion: !0,
  onVisibleChange: ut,
  onClickOutSide: ut,
  spacing: tr.SPACING,
  margin: tr.MARGIN,
  showArrow: !0,
  wrapWhenSpecial: !0,
  zIndex: tr.DEFAULT_Z_INDEX,
  closeOnEsc: !1,
  guardFocus: !1,
  returnFocusOnClose: !1,
  onEscKeyDown: ut,
  disableFocusListener: !1,
  disableArrowKeyDown: !1,
};
var Tu = {},
  kH = {
    get exports() {
      return Tu;
    },
    set exports(n) {
      Tu = n;
    },
  };
const q1 = (n, { target: e = document.body } = {}) => {
  const t = document.createElement("textarea"),
    i = document.activeElement;
  (t.value = n),
    t.setAttribute("readonly", ""),
    (t.style.contain = "strict"),
    (t.style.position = "absolute"),
    (t.style.left = "-9999px"),
    (t.style.fontSize = "12pt");
  const r = document.getSelection();
  let o = !1;
  r.rangeCount > 0 && (o = r.getRangeAt(0)),
    e.append(t),
    t.select(),
    (t.selectionStart = 0),
    (t.selectionEnd = n.length);
  let p = !1;
  try {
    p = document.execCommand("copy");
  } catch {}
  return (
    t.remove(), o && (r.removeAllRanges(), r.addRange(o)), i && i.focus(), p
  );
};
kH.exports = q1;
Tu.default = q1;
function Zs() {}
const FH = W.createContext(null),
  NH = FH;
function If(n) {
  return function () {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      t = e.width ? String(e.width) : n.defaultWidth,
      i = n.formats[t] || n.formats[n.defaultWidth];
    return i;
  };
}
function ga(n) {
  return function (e, t) {
    var i = t != null && t.context ? String(t.context) : "standalone",
      r;
    if (i === "formatting" && n.formattingValues) {
      var o = n.defaultFormattingWidth || n.defaultWidth,
        p = t != null && t.width ? String(t.width) : o;
      r = n.formattingValues[p] || n.formattingValues[o];
    } else {
      var a = n.defaultWidth,
        s = t != null && t.width ? String(t.width) : n.defaultWidth;
      r = n.values[s] || n.values[a];
    }
    var u = n.argumentCallback ? n.argumentCallback(e) : e;
    return r[u];
  };
}
function va(n) {
  return function (e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      i = t.width,
      r = (i && n.matchPatterns[i]) || n.matchPatterns[n.defaultMatchWidth],
      o = e.match(r);
    if (!o) return null;
    var p = o[0],
      a = (i && n.parsePatterns[i]) || n.parsePatterns[n.defaultParseWidth],
      s = Array.isArray(a)
        ? zH(a, function (l) {
            return l.test(p);
          })
        : BH(a, function (l) {
            return l.test(p);
          }),
      u;
    (u = n.valueCallback ? n.valueCallback(s) : s),
      (u = t.valueCallback ? t.valueCallback(u) : u);
    var d = e.slice(p.length);
    return { value: u, rest: d };
  };
}
function BH(n, e) {
  for (var t in n) if (n.hasOwnProperty(t) && e(n[t])) return t;
}
function zH(n, e) {
  for (var t = 0; t < n.length; t++) if (e(n[t])) return t;
}
function UH(n) {
  return function (e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      i = e.match(n.matchPattern);
    if (!i) return null;
    var r = i[0],
      o = e.match(n.parsePattern);
    if (!o) return null;
    var p = n.valueCallback ? n.valueCallback(o[0]) : o[0];
    p = t.valueCallback ? t.valueCallback(p) : p;
    var a = e.slice(r.length);
    return { value: p, rest: a };
  };
}
function jH(n) {
  if (n === null || n === !0 || n === !1) return NaN;
  var e = Number(n);
  return isNaN(e) ? e : e < 0 ? Math.ceil(e) : Math.floor(e);
}
function Nm(n, e) {
  if (e.length < n)
    throw new TypeError(
      n +
        " argument" +
        (n > 1 ? "s" : "") +
        " required, but only " +
        e.length +
        " present"
    );
}
function $c(n) {
  return (
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? ($c = function (t) {
          return typeof t;
        })
      : ($c = function (t) {
          return t &&
            typeof Symbol == "function" &&
            t.constructor === Symbol &&
            t !== Symbol.prototype
            ? "symbol"
            : typeof t;
        }),
    $c(n)
  );
}
function HH(n) {
  Nm(1, arguments);
  var e = Object.prototype.toString.call(n);
  return n instanceof Date || ($c(n) === "object" && e === "[object Date]")
    ? new Date(n.getTime())
    : typeof n == "number" || e === "[object Number]"
    ? new Date(n)
    : ((typeof n == "string" || e === "[object String]") &&
        typeof console < "u" &&
        (console.warn(
          "Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"
        ),
        console.warn(new Error().stack)),
      new Date(NaN));
}
var VH = {};
function WH() {
  return VH;
}
function e_(n, e) {
  var t, i, r, o, p, a, s, u;
  Nm(1, arguments);
  var d = WH(),
    l = jH(
      (t =
        (i =
          (r =
            (o = e == null ? void 0 : e.weekStartsOn) !== null && o !== void 0
              ? o
              : e == null ||
                (p = e.locale) === null ||
                p === void 0 ||
                (a = p.options) === null ||
                a === void 0
              ? void 0
              : a.weekStartsOn) !== null && r !== void 0
            ? r
            : d.weekStartsOn) !== null && i !== void 0
          ? i
          : (s = d.locale) === null ||
            s === void 0 ||
            (u = s.options) === null ||
            u === void 0
          ? void 0
          : u.weekStartsOn) !== null && t !== void 0
        ? t
        : 0
    );
  if (!(l >= 0 && l <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var c = HH(n),
    h = c.getUTCDay(),
    m = (h < l ? 7 : 0) + h - l;
  return c.setUTCDate(c.getUTCDate() - m), c.setUTCHours(0, 0, 0, 0), c;
}
function GH(n, e, t) {
  Nm(2, arguments);
  var i = e_(n, t),
    r = e_(e, t);
  return i.getTime() === r.getTime();
}
var $H = {
    lessThanXSeconds: { one: " 1 ", other: " {{count}} " },
    xSeconds: { one: "1 ", other: "{{count}} " },
    halfAMinute: "",
    lessThanXMinutes: { one: " 1 ", other: " {{count}} " },
    xMinutes: { one: "1 ", other: "{{count}} " },
    xHours: { one: "1 ", other: "{{count}} " },
    aboutXHours: { one: " 1 ", other: " {{count}} " },
    xDays: { one: "1 ", other: "{{count}} " },
    aboutXWeeks: { one: " 1 ", other: " {{count}} " },
    xWeeks: { one: "1 ", other: "{{count}} " },
    aboutXMonths: { one: " 1 ", other: " {{count}} " },
    xMonths: { one: "1 ", other: "{{count}} " },
    aboutXYears: { one: " 1 ", other: " {{count}} " },
    xYears: { one: "1 ", other: "{{count}} " },
    overXYears: { one: " 1 ", other: " {{count}} " },
    almostXYears: { one: " 1 ", other: " {{count}} " },
  },
  XH = function (e, t, i) {
    var r,
      o = $H[e];
    return (
      typeof o == "string"
        ? (r = o)
        : t === 1
        ? (r = o.one)
        : (r = o.other.replace("{{count}}", String(t))),
      i != null && i.addSuffix
        ? i.comparison && i.comparison > 0
          ? r + ""
          : r + ""
        : r
    );
  };
const YH = XH;
var KH = {
    full: "y''M''d'' EEEE",
    long: "y''M''d''",
    medium: "yyyy-MM-dd",
    short: "yy-MM-dd",
  },
  qH = {
    full: "zzzz a h:mm:ss",
    long: "z a h:mm:ss",
    medium: "a h:mm:ss",
    short: "a h:mm",
  },
  ZH = {
    full: "{{date}} {{time}}",
    long: "{{date}} {{time}}",
    medium: "{{date}} {{time}}",
    short: "{{date}} {{time}}",
  },
  JH = {
    date: If({ formats: KH, defaultWidth: "full" }),
    time: If({ formats: qH, defaultWidth: "full" }),
    dateTime: If({ formats: ZH, defaultWidth: "full" }),
  };
const QH = JH;
function t_(n, e, t) {
  var i = "eeee p";
  return GH(n, e, t)
    ? i
    : n.getTime() > e.getTime()
    ? "''" + i
    : "''" + i;
}
var eV = {
    lastWeek: t_,
    yesterday: "'' p",
    today: "'' p",
    tomorrow: "'' p",
    nextWeek: t_,
    other: "PP p",
  },
  tV = function (e, t, i, r) {
    var o = eV[e];
    return typeof o == "function" ? o(t, i, r) : o;
  };
const nV = tV;
var iV = {
    narrow: ["", ""],
    abbreviated: ["", ""],
    wide: ["", ""],
  },
  rV = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["", "", "", ""],
    wide: ["", "", "", ""],
  },
  sV = {
    narrow: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
    ],
    abbreviated: [
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11",
      "12",
    ],
    wide: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
    ],
  },
  oV = {
    narrow: ["", "", "", "", "", "", ""],
    short: ["", "", "", "", "", "", ""],
    abbreviated: ["", "", "", "", "", "", ""],
    wide: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
    ],
  },
  aV = {
    narrow: {
      am: "",
      pm: "",
      midnight: "",
      noon: "",
      morning: "",
      afternoon: "",
      evening: "",
      night: "",
    },
    abbreviated: {
      am: "",
      pm: "",
      midnight: "",
      noon: "",
      morning: "",
      afternoon: "",
      evening: "",
      night: "",
    },
    wide: {
      am: "",
      pm: "",
      midnight: "",
      noon: "",
      morning: "",
      afternoon: "",
      evening: "",
      night: "",
    },
  },
  lV = {
    narrow: {
      am: "",
      pm: "",
      midnight: "",
      noon: "",
      morning: "",
      afternoon: "",
      evening: "",
      night: "",
    },
    abbreviated: {
      am: "",
      pm: "",
      midnight: "",
      noon: "",
      morning: "",
      afternoon: "",
      evening: "",
      night: "",
    },
    wide: {
      am: "",
      pm: "",
      midnight: "",
      noon: "",
      morning: "",
      afternoon: "",
      evening: "",
      night: "",
    },
  },
  cV = function (e, t) {
    var i = Number(e);
    switch (t == null ? void 0 : t.unit) {
      case "date":
        return i.toString() + "";
      case "hour":
        return i.toString() + "";
      case "minute":
        return i.toString() + "";
      case "second":
        return i.toString() + "";
      default:
        return " " + i.toString();
    }
  },
  uV = {
    ordinalNumber: cV,
    era: ga({ values: iV, defaultWidth: "wide" }),
    quarter: ga({
      values: rV,
      defaultWidth: "wide",
      argumentCallback: function (e) {
        return e - 1;
      },
    }),
    month: ga({ values: sV, defaultWidth: "wide" }),
    day: ga({ values: oV, defaultWidth: "wide" }),
    dayPeriod: ga({
      values: aV,
      defaultWidth: "wide",
      formattingValues: lV,
      defaultFormattingWidth: "wide",
    }),
  };
const hV = uV;
var fV = /^(\s*)?\d+(|||)?/i,
  dV = /\d+/i,
  pV = { narrow: /^()/i, abbreviated: /^()/i, wide: /^(|)/i },
  mV = { any: [/^()/i, /^()/i] },
  gV = {
    narrow: /^[1234]/i,
    abbreviated: /^[]/i,
    wide: /^[]/i,
  },
  vV = { any: [/(1|)/i, /(2|)/i, /(3|)/i, /(4|)/i] },
  yV = {
    narrow: /^(|||||||||[])/i,
    abbreviated: /^(|||||||||[]|\d|1[12])/i,
    wide: /^(|||||||||[])/i,
  },
  _V = {
    narrow: [
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^(?!(|))/i,
      /^/i,
      /^/i,
    ],
    any: [
      /^|1/i,
      /^|2/i,
      /^|3/i,
      /^|4/i,
      /^|5/i,
      /^|6/i,
      /^|7/i,
      /^|8/i,
      /^|9/i,
      /^(?!(|))|10/i,
      /^|11/i,
      /^|12/i,
    ],
  },
  xV = {
    narrow: /^[]/i,
    short: /^[]/i,
    abbreviated: /^[]/i,
    wide: /^[]/i,
  },
  bV = { any: [//i, //i, //i, //i, //i, //i, //i] },
  SV = { any: /^(?|?||[]|?||?||)/i },
  wV = {
    any: {
      am: /^?/i,
      pm: /^?/i,
      midnight: /^/i,
      noon: /^[]/i,
      morning: /^/i,
      afternoon: /^/i,
      evening: /^?/i,
      night: /^/i,
    },
  },
  TV = {
    ordinalNumber: UH({
      matchPattern: fV,
      parsePattern: dV,
      valueCallback: function (e) {
        return parseInt(e, 10);
      },
    }),
    era: va({
      matchPatterns: pV,
      defaultMatchWidth: "wide",
      parsePatterns: mV,
      defaultParseWidth: "any",
    }),
    quarter: va({
      matchPatterns: gV,
      defaultMatchWidth: "wide",
      parsePatterns: vV,
      defaultParseWidth: "any",
      valueCallback: function (e) {
        return e + 1;
      },
    }),
    month: va({
      matchPatterns: yV,
      defaultMatchWidth: "wide",
      parsePatterns: _V,
      defaultParseWidth: "any",
    }),
    day: va({
      matchPatterns: xV,
      defaultMatchWidth: "wide",
      parsePatterns: bV,
      defaultParseWidth: "any",
    }),
    dayPeriod: va({
      matchPatterns: SV,
      defaultMatchWidth: "any",
      parsePatterns: wV,
      defaultParseWidth: "any",
    }),
  };
const CV = TV;
var MV = {
  code: "zh-CN",
  formatDistance: YH,
  formatLong: QH,
  formatRelative: nV,
  localize: hV,
  match: CV,
  options: { weekStartsOn: 1, firstWeekContainsDate: 4 },
};
const EV = MV,
  AV = {
    code: "zh-CN",
    dateFnsLocale: EV,
    Pagination: {
      pageSize: "${pageSize} /",
      total: " ${total} ",
      jumpTo: "",
      page: "",
    },
    Modal: { confirm: "", cancel: "" },
    TimePicker: {
      placeholder: { time: "", timeRange: "" },
      begin: "",
      end: "",
      hour: "",
      minute: "",
      second: "",
      AM: "",
      PM: "",
    },
    DatePicker: {
      placeholder: {
        date: "",
        dateTime: "",
        dateRange: ["", ""],
        dateTimeRange: ["", ""],
      },
      footer: { confirm: "", cancel: "" },
      selectDate: "",
      selectTime: "",
      year: "",
      month: "",
      day: "",
      monthText: "${year} ${month}",
      months: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
      },
      fullMonths: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
      },
      weeks: {
        Mon: "",
        Tue: "",
        Wed: "",
        Thu: "",
        Fri: "",
        Sat: "",
        Sun: "",
      },
      localeFormatToken: { FORMAT_SWITCH_DATE: "yyyy-MM-dd" },
    },
    Navigation: { collapseText: "", expandText: "" },
    Popconfirm: { confirm: "", cancel: "" },
    Table: {
      emptyText: "",
      pageText: " ${currentStart} - ${currentEnd}  ${total} ",
    },
    Select: { emptyText: "", createText: "" },
    Cascader: { emptyText: "" },
    Tree: { emptyText: "", searchPlaceholder: "" },
    List: { emptyText: "" },
    Calendar: {
      allDay: "",
      AM: "${time}",
      PM: "${time}",
      datestring: "",
      remaining: "${remained}",
    },
    Upload: {
      mainText: "",
      illegalTips: "",
      legalTips: "",
      retry: "",
      replace: "",
      clear: "",
      selectedFiles: "",
      illegalSize: "",
      fail: "",
    },
    TreeSelect: { searchPlaceholder: "" },
    Typography: {
      copy: "",
      copied: "",
      expand: "",
      collapse: "",
    },
    Transfer: {
      emptyLeft: "",
      emptySearch: "",
      emptyRight: "",
      placeholder: "",
      clear: "",
      selectAll: "",
      clearSelectAll: "",
      total: " ${total} ",
      selected: " ${total} ",
    },
    Form: { optional: "" },
    Image: {
      preview: "",
      loading: "",
      loadError: "",
      prevTip: "",
      nextTip: "",
      zoomInTip: "",
      zoomOutTip: "",
      rotateTip: "",
      downloadTip: "",
      adaptiveTip: "",
      originTip: "",
    },
  },
  n_ = AV;
class pl extends Ce.Component {
  renderChildren(e, t) {
    const { componentName: i } = this.props;
    let r = e;
    (e != null && e.code) || (r = n_);
    const o = st(n_, "dateFnsLocale"),
      p = st(r, "dateFnsLocale", o);
    return t(r[i], r.code, p);
  }
  render() {
    const { children: e } = this.props;
    return W.createElement(Pl.Consumer, null, (t) => {
      let { locale: i } = t;
      return W.createElement(NH.Consumer, null, (r) =>
        this.renderChildren(i || r, e)
      );
    });
  }
}
pl.propTypes = { componentName: M.string.isRequired, children: M.any };
pl.defaultProps = { componentName: "" };
const PV = "semi";
var OV =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const Z1 = W.forwardRef((n, e) => {
  const {
      svg: t,
      spin: i = !1,
      rotate: r,
      style: o,
      className: p,
      prefixCls: a = PV,
      type: s,
      size: u = "default",
    } = n,
    d = OV(n, [
      "svg",
      "spin",
      "rotate",
      "style",
      "className",
      "prefixCls",
      "type",
      "size",
    ]),
    l = Be(
      `${a}-icon`,
      {
        [`${a}-icon-extra-small`]: u === "extra-small",
        [`${a}-icon-small`]: u === "small",
        [`${a}-icon-default`]: u === "default",
        [`${a}-icon-large`]: u === "large",
        [`${a}-icon-extra-large`]: u === "extra-large",
        [`${a}-icon-spinning`]: i === !0,
        [`${a}-icon-${s}`]: Boolean(s),
      },
      p
    ),
    c = {};
  return (
    Number.isSafeInteger(r) && (c.transform = `rotate(${r}deg)`),
    Object.assign(c, o),
    W.createElement(
      "span",
      Object.assign(
        { role: "img", ref: e, "aria-label": s, className: l, style: c },
        d
      ),
      t
    )
  );
});
Z1.elementType = "Icon";
const en = (n, e) => {
  const t = W.forwardRef((i, r) =>
    W.createElement(
      Z1,
      Object.assign({ svg: W.createElement(n), type: e, ref: r }, i)
    )
  );
  return (t.elementType = "Icon"), t;
};
function LV(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12ZM13.5 17.5C13.5 16.6716 12.8284 16 12 16C11.1716 16 10.5 16.6716 10.5 17.5C10.5 18.3284 11.1716 19 12 19C12.8284 19 13.5 18.3284 13.5 17.5ZM12 5C10.9138 5 10.0507 5.91244 10.1109 6.99692L10.4168 12.5023C10.4635 13.3426 11.1584 14 12 14C12.8416 14 13.5365 13.3426 13.5832 12.5023L13.8891 6.99692C13.9493 5.91244 13.0862 5 12 5Z",
      fill: "currentColor",
    })
  );
}
const DV = en(LV, "alert_circle"),
  RV = DV;
function IV(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M10.2268 2.3986L1.52616 19.0749C0.831449 20.4064 1.79747 22 3.29933 22H20.7007C22.2025 22 23.1686 20.4064 22.4739 19.0749L13.7732 2.3986C13.0254 0.965441 10.9746 0.965442 10.2268 2.3986ZM13.1415 14.0101C13.0603 14.5781 12.5739 15 12.0001 15C11.4263 15 10.9398 14.5781 10.8586 14.0101L10.2829 9.97992C10.1336 8.93495 10.9445 8.00002 12.0001 8.00002C13.0556 8.00002 13.8665 8.93495 13.7172 9.97992L13.1415 14.0101ZM13.5001 18.5C13.5001 19.3284 12.8285 20 12.0001 20C11.1716 20 10.5001 19.3284 10.5001 18.5C10.5001 17.6716 11.1716 17 12.0001 17C12.8285 17 13.5001 17.6716 13.5001 18.5Z",
      fill: "currentColor",
    })
  );
}
const kV = en(IV, "alert_triangle"),
  FV = kV;
function NV(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M4.08045 7.59809C4.66624 7.01231 5.61599 7.01231 6.20177 7.59809L11.8586 13.2549L17.5155 7.59809C18.1013 7.01231 19.051 7.01231 19.6368 7.59809C20.2226 8.18388 20.2226 9.13363 19.6368 9.71941L12.9193 16.4369C12.3335 17.0227 11.3838 17.0227 10.798 16.4369L4.08045 9.71941C3.49467 9.13363 3.49467 8.18388 4.08045 7.59809Z",
      fill: "currentColor",
    })
  );
}
const BV = en(NV, "chevron_down"),
  zV = BV;
function UV(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M16.2782 4.23933C16.864 4.82511 16.864 5.77486 16.2782 6.36065L10.6213 12.0175L16.2782 17.6744C16.864 18.2601 16.864 19.2099 16.2782 19.7957C15.6924 20.3815 14.7426 20.3815 14.1569 19.7957L7.43934 13.0782C6.85355 12.4924 6.85355 11.5426 7.43934 10.9568L14.1569 4.23933C14.7426 3.65354 15.6924 3.65354 16.2782 4.23933Z",
      fill: "currentColor",
    })
  );
}
const jV = en(UV, "chevron_left"),
  HV = jV;
function VV(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M7.43934 19.7957C6.85355 19.2099 6.85355 18.2601 7.43934 17.6744L13.0962 12.0175L7.43934 6.36065C6.85355 5.77486 6.85355 4.82511 7.43934 4.23933C8.02513 3.65354 8.97487 3.65354 9.56066 4.23933L16.2782 10.9568C16.864 11.5426 16.864 12.4924 16.2782 13.0782L9.56066 19.7957C8.97487 20.3815 8.02513 20.3815 7.43934 19.7957Z",
      fill: "currentColor",
    })
  );
}
const WV = en(VV, "chevron_right"),
  GV = WV;
function $V(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M19.637 16.4369C19.0513 17.0227 18.1015 17.0227 17.5157 16.4369L11.8589 10.7801L6.20202 16.4369C5.61623 17.0227 4.66648 17.0227 4.0807 16.4369C3.49491 15.8511 3.49491 14.9014 4.0807 14.3156L10.7982 7.59809C11.384 7.01231 12.3337 7.01231 12.9195 7.59809L19.637 14.3156C20.2228 14.9014 20.2228 15.8511 19.637 16.4369Z",
      fill: "currentColor",
    })
  );
}
const XV = en($V, "chevron_up"),
  YV = XV;
function KV(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      d: "M17.6568 19.7782C18.2426 20.3639 19.1924 20.3639 19.7782 19.7782C20.3639 19.1924 20.3639 18.2426 19.7782 17.6568L14.1213 12L19.7782 6.34313C20.3639 5.75734 20.3639 4.8076 19.7782 4.22181C19.1924 3.63602 18.2426 3.63602 17.6568 4.22181L12 9.87866L6.34313 4.22181C5.75734 3.63602 4.8076 3.63602 4.22181 4.22181C3.63602 4.8076 3.63602 5.75734 4.22181 6.34313L9.87866 12L4.22181 17.6568C3.63602 18.2426 3.63602 19.1924 4.22181 19.7782C4.8076 20.3639 5.75734 20.3639 6.34313 19.7782L12 14.1213L17.6568 19.7782Z",
      fill: "currentColor",
    })
  );
}
const qV = en(KV, "close"),
  J1 = qV;
function ZV(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M2 4C2 2.89543 2.89543 2 4 2H9C10.1046 2 11 2.89543 11 4V20C11 21.1046 10.1046 22 9 22H4C2.89543 22 2 21.1046 2 20V4ZM8 17.5C8 18.3284 7.32843 19 6.5 19C5.67157 19 5 18.3284 5 17.5C5 16.6716 5.67157 16 6.5 16C7.32843 16 8 16.6716 8 17.5ZM19.5858 8.58579L16.4142 5.41421C15.6332 4.63316 14.3668 4.63316 13.5858 5.41421L13 6V18L19.5858 11.4142C20.3668 10.6332 20.3668 9.36683 19.5858 8.58579ZM22 16C22 14.8954 21.1046 14 20 14L12 22H20C21.1046 22 22 21.1046 22 20V16Z",
      fill: "currentColor",
    })
  );
}
const JV = en(ZV, "color_palette"),
  QV = JV;
function eW(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 22 22",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      d: "M6 4L11 0L16 4L11 9.5L6 4Z",
      fill: "currentColor",
    }),
    Ce.createElement("path", {
      d: "M18 6L22 11L18 16L12.5 11L18 6Z",
      fill: "currentColor",
    }),
    Ce.createElement("path", {
      d: "M4 16L0 11L4 6L9.5 11L4 16Z",
      fill: "currentColor",
    }),
    Ce.createElement("path", {
      d: "M16 18L11 22L6 18L11 12.5L16 18Z",
      fill: "currentColor",
    })
  );
}
const tW = en(eW, "component"),
  nW = tW;
function iW(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      d: "M7 4C7 2.89543 7.89543 2 9 2H20C21.1046 2 22 2.89543 22 4V15C22 16.1046 21.1046 17 20 17H19V8C19 6 18 5 16 5H7V4Z",
      fill: "currentColor",
    }),
    Ce.createElement("path", {
      d: "M5 7C3.89543 7 3 7.89543 3 9V19C3 20.1046 3.89543 21 5 21H15C16.1046 21 17 20.1046 17 19V9C17 7.89543 16.1046 7 15 7H5Z",
      fill: "currentColor",
    })
  );
}
const rW = en(iW, "copy"),
  sW = rW;
function oW(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5 2C3.34315 2 2 3.34315 2 5V19C2 20.6569 3.34315 22 5 22H19C20.6569 22 22 20.6569 22 19V5C22 3.34315 20.6569 2 19 2H5ZM10 7.5C10 8.88071 8.88071 10 7.5 10C6.11929 10 5 8.88071 5 7.5C5 6.11929 6.11929 5 7.5 5C8.88071 5 10 6.11929 10 7.5ZM16.7071 11.7071C16.3166 11.3166 15.6834 11.3166 15.2929 11.7071L11 16L9.70711 14.7071C9.31658 14.3166 8.68342 14.3166 8.29289 14.7071L5 18V19H8H12H19V14L16.7071 11.7071Z",
      fill: "currentColor",
    })
  );
}
const aW = en(oW, "image"),
  lW = aW;
function cW(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM14 7C14 8.10457 13.1046 9 12 9C10.8954 9 10 8.10457 10 7C10 5.89543 10.8954 5 12 5C13.1046 5 14 5.89543 14 7ZM9 10.75C9 10.3358 9.33579 10 9.75 10H12.5C13.0523 10 13.5 10.4477 13.5 11V16.5H14.25C14.6642 16.5 15 16.8358 15 17.25C15 17.6642 14.6642 18 14.25 18H9.75C9.33579 18 9 17.6642 9 17.25C9 16.8358 9.33579 16.5 9.75 16.5H10.5V11.5H9.75C9.33579 11.5 9 11.1642 9 10.75Z",
      fill: "currentColor",
    })
  );
}
const uW = en(cW, "info_circle"),
  hW = uW;
function fW(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M5 2C3.34315 2 2 3.34315 2 5V19C2 20.6569 3.34315 22 5 22H19C20.6569 22 22 20.6569 22 19V5C22 3.34315 20.6569 2 19 2H5ZM7 6C7 5.44772 6.55228 5 6 5C5.44772 5 5 5.44772 5 6C5 9.86599 8.13401 13 12 13C15.866 13 19 9.86599 19 6C19 5.44772 18.5523 5 18 5C17.4477 5 17 5.44772 17 6C17 8.76142 14.7614 11 12 11C9.23858 11 7 8.76142 7 6Z",
      fill: "currentColor",
    })
  );
}
const dW = en(fW, "shopping_bag"),
  pW = dW;
function mW(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M3 4.5C3 3.67157 3.67157 3 4.5 3H19.5C20.3284 3 21 3.67157 21 4.5V7.5C21 8.32843 20.3284 9 19.5 9C18.6716 9 18 8.32843 18 7.5V6H13.5V19H15.5C16.3284 19 17 19.6716 17 20.5C17 21.3284 16.3284 22 15.5 22H8.5C7.67157 22 7 21.3284 7 20.5C7 19.6716 7.67157 19 8.5 19H10.5V6H6V7.5C6 8.32843 5.32843 9 4.5 9C3.67157 9 3 8.32843 3 7.5V4.5Z",
      fill: "currentColor",
    })
  );
}
const gW = en(mW, "text"),
  vW = gW;
function yW(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M21.3516 4.2652C22.0336 4.73552 22.2052 5.66964 21.7348 6.35162L11.7348 20.8516C11.4765 21.2262 11.0622 21.4632 10.6084 21.4961C10.1546 21.529 9.71041 21.3541 9.40082 21.0207L2.90082 14.0207C2.33711 13.4136 2.37226 12.4645 2.97933 11.9008C3.5864 11.3371 4.53549 11.3723 5.0992 11.9793L10.3268 17.6091L19.2652 4.64842C19.7355 3.96644 20.6696 3.79487 21.3516 4.2652Z",
      fill: "currentColor",
    })
  );
}
const _W = en(yW, "tick"),
  np = _W;
function xW(n) {
  return Ce.createElement(
    "svg",
    Object.assign(
      {
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        width: "1em",
        height: "1em",
        focusable: !1,
        "aria-hidden": !0,
      },
      n
    ),
    Ce.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM17.8831 9.82235L11.6854 17.4112C11.4029 17.7806 10.965 17.9981 10.5 18C10.035 18.0019 9.59533 17.788 9.30982 17.421L5.81604 13.4209C5.30744 12.767 5.42524 11.8246 6.07916 11.316C6.73308 10.8074 7.67549 10.9252 8.1841 11.5791L10.4838 14.0439L15.5 8C16.0032 7.34193 16.9446 7.21641 17.6027 7.71964C18.2608 8.22287 18.3863 9.16428 17.8831 9.82235Z",
      fill: "currentColor",
    })
  );
}
const bW = en(xW, "tick_circle"),
  SW = bW,
  wW = "Enter";
function Q1(n) {
  return st(n, "key") === wW;
}
const kf = eh.PREFIX;
class Bm extends W.PureComponent {
  constructor(e) {
    super(e),
      (this.copy = (t) => {
        const { content: i, duration: r, onCopy: o } = this.props,
          p = Tu(i);
        o && o(t, i, p), this.setCopied(i, r);
      }),
      (this.setCopied = (t, i) => {
        this.setState({ copied: !0, item: t }),
          (this._timeId = setTimeout(() => {
            this.resetCopied();
          }, i * 1e3));
      }),
      (this.resetCopied = () => {
        this._timeId &&
          (clearTimeout(this._timeId),
          (this._timeId = null),
          this.setState({ copied: !1, item: "" }));
      }),
      (this.renderSuccessTip = () => {
        const { successTip: t } = this.props;
        return typeof t < "u"
          ? t
          : W.createElement(pl, { componentName: "Typography" }, (i) =>
              W.createElement("span", null, W.createElement(np, null), i.copied)
            );
      }),
      (this.state = { copied: !1, item: "" });
  }
  componentWillUnmount() {
    this._timeId && (clearTimeout(this._timeId), (this._timeId = null));
  }
  render() {
    const { style: e, className: t, forwardRef: i, copyTip: r } = this.props,
      { copied: o } = this.state,
      p = Be(t, { [`${kf}-action-copy`]: !o, [`${kf}-action-copied`]: o });
    return W.createElement(pl, { componentName: "Typography" }, (a) =>
      W.createElement(
        "span",
        {
          style: Object.assign({ marginLeft: "4px" }, e),
          className: p,
          ref: i,
        },
        o
          ? this.renderSuccessTip()
          : W.createElement(
              gs,
              { content: typeof r < "u" ? r : a.copy },
              W.createElement(
                "a",
                { className: `${kf}-action-copy-icon` },
                W.createElement(sW, {
                  role: "button",
                  tabIndex: 0,
                  onClick: this.copy,
                  onKeyPress: (s) => Q1(s) && this.copy(s),
                })
              )
            )
      )
    );
  }
}
Bm.propTypes = {
  content: M.string,
  onCopy: M.func,
  successTip: M.node,
  copyTip: M.node,
  duration: M.number,
  style: M.object,
  className: M.string,
};
Bm.defaultProps = {
  content: "",
  onCopy: Zs,
  duration: 3,
  style: {},
  className: "",
};
const TW = Bm,
  eS = { PREFIX: `${Ye}-popover`, ARROW: `${Ye}-popover-icon-arrow` },
  za = {
    POSITION_SET: [
      "top",
      "topLeft",
      "topRight",
      "left",
      "leftTop",
      "leftBottom",
      "right",
      "rightTop",
      "rightBottom",
      "bottom",
      "bottomLeft",
      "bottomRight",
      "leftTopOver",
      "rightTopOver",
    ],
    TRIGGER_SET: ["hover", "focus", "click", "custom"],
    DEFAULT_ARROW_STYLE: {
      borderOpacity: "1",
      backgroundColor: "var(--semi-color-bg-3)",
      borderColor: "var(--semi-color-border)",
    },
  },
  Mo = {
    ARROW_BOUNDING: Object.assign(Object.assign({}, tr.ARROW_BOUNDING), {
      offsetY: 6,
      offsetX: 0,
      height: 8,
    }),
    SPACING: 4,
    SPACING_WITH_ARROW: 10,
    DEFAULT_Z_INDEX: 1030,
  };
var CW =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const tS = function () {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const { position: e = "", className: t, arrowStyle: i, popStyle: r } = n,
    o = CW(n, ["position", "className", "arrowStyle", "popStyle"]),
    p = e.indexOf("top") === 0 || e.indexOf("bottom") === 0,
    a = Be(t, eS.ARROW),
    s = st(i, "borderOpacity", za.DEFAULT_ARROW_STYLE.borderOpacity),
    u = st(
      i,
      "backgroundColor",
      st(r, "backgroundColor", za.DEFAULT_ARROW_STYLE.backgroundColor)
    ),
    d = st(
      i,
      "borderColor",
      st(r, "borderColor", za.DEFAULT_ARROW_STYLE.borderColor)
    ),
    l = Object.assign(Object.assign({}, o), {
      width: Mo.ARROW_BOUNDING.width,
      height: Mo.ARROW_BOUNDING.height,
      xmlns: "http://www.w3.org/2000/svg",
      className: a,
    });
  return p
    ? W.createElement(
        "svg",
        Object.assign({}, l),
        W.createElement("path", {
          d: "M0 0.5L0 1.5C4 1.5, 5.5 3, 7.5 5S10,8 12,8S14.5 7, 16.5 5S20,1.5 24,1.5L24 0.5L0 0.5z",
          fill: d,
          opacity: s,
        }),
        W.createElement("path", {
          d: "M0 0L0 1C4 1, 5.5 2, 7.5 4S10,7 12,7S14.5  6, 16.5 4S20,1 24,1L24 0L0 0z",
          fill: u,
        })
      )
    : W.createElement(
        "svg",
        Object.assign({}, l),
        W.createElement("path", {
          d: "M0.5 0L1.5 0C1.5 4, 3 5.5, 5 7.5S8,10 8,12S7 14.5, 5 16.5S1.5,20 1.5,24L0.5 24L0.5 0z",
          fill: d,
          opacity: s,
        }),
        W.createElement("path", {
          d: "M0 0L1 0C1 4, 2 5.5, 4 7.5S7,10 7,12S6 14.5, 4 16.5S1,20 1,24L0 24L0 0z",
          fill: u,
        })
      );
};
tS.propTypes = {
  position: M.string,
  className: M.string,
  arrowStyle: M.object,
  popStyle: M.object,
};
const MW = tS;
var EW =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const AW = za.POSITION_SET,
  PW = za.TRIGGER_SET;
class oh extends W.PureComponent {
  constructor() {
    super(...arguments),
      (this.renderPopCard = (e) => {
        let { initialFocusRef: t } = e;
        const { content: i, contentClassName: r, prefixCls: o } = this.props,
          { direction: p } = this.context,
          a = Be(o, r, { [`${o}-rtl`]: p === "rtl" }),
          s = this.renderContentNode({ initialFocusRef: t, content: i });
        return W.createElement(
          "div",
          { className: a },
          W.createElement("div", { className: `${o}-content` }, s)
        );
      }),
      (this.renderContentNode = (e) => {
        const { initialFocusRef: t, content: i } = e,
          r = { initialFocusRef: t };
        return Bo(i) ? i(r) : i;
      });
  }
  render() {
    const e = this.props,
      {
        children: t,
        prefixCls: i,
        showArrow: r,
        arrowStyle: o = {},
        arrowBounding: p,
        position: a,
        style: s,
        trigger: u,
      } = e,
      d = EW(e, [
        "children",
        "prefixCls",
        "showArrow",
        "arrowStyle",
        "arrowBounding",
        "position",
        "style",
        "trigger",
      ]);
    let { spacing: l } = this.props;
    const c = { position: a, className: "", popStyle: s, arrowStyle: o },
      h = r ? W.createElement(MW, Object.assign({}, c)) : !1;
    typeof l != "number" && (l = r ? Mo.SPACING_WITH_ARROW : Mo.SPACING);
    const m = u === "click" || u === "custom" ? "dialog" : "tooltip";
    return W.createElement(
      gs,
      Object.assign({ guardFocus: !0 }, d, {
        trigger: u,
        position: a,
        style: s,
        content: this.renderPopCard,
        prefixCls: i,
        spacing: l,
        showArrow: h,
        arrowBounding: p,
        role: m,
      }),
      t
    );
  }
}
oh.contextType = Pl;
oh.propTypes = {
  children: M.node,
  content: M.oneOfType([M.node, M.func]),
  visible: M.bool,
  autoAdjustOverflow: M.bool,
  motion: M.bool,
  position: M.oneOf(AW),
  margin: M.oneOfType([M.number, M.object]),
  mouseEnterDelay: M.number,
  mouseLeaveDelay: M.number,
  trigger: M.oneOf(PW).isRequired,
  contentClassName: M.oneOfType([M.string, M.array]),
  onVisibleChange: M.func,
  onClickOutSide: M.func,
  style: M.object,
  spacing: M.number,
  zIndex: M.number,
  showArrow: M.bool,
  arrowStyle: M.shape({
    borderColor: M.string,
    backgroundColor: M.string,
    borderOpacity: M.oneOfType([M.string, M.number]),
  }),
  arrowPointAtCenter: M.bool,
  arrowBounding: M.object,
  prefixCls: M.string,
  guardFocus: M.bool,
  disableArrowKeyDown: M.bool,
};
oh.defaultProps = {
  arrowBounding: Mo.ARROW_BOUNDING,
  showArrow: !1,
  autoAdjustOverflow: !0,
  zIndex: Mo.DEFAULT_Z_INDEX,
  motion: !0,
  trigger: "hover",
  cancelText: "No",
  okText: "Yes",
  position: "bottom",
  prefixCls: eS.PREFIX,
  onClickOutSide: ut,
  onEscKeyDown: ut,
  closeOnEsc: !0,
  returnFocusOnClose: !0,
  guardFocus: !0,
  disableFocusListener: !0,
};
const OW = oh;
let Ht;
function Ff(n) {
  if (!n) return 0;
  const e = n.match(/^\d*(\.\d*)?/);
  return e ? Number(e[0]) : 0;
}
function LW(n) {
  return Array.prototype.slice
    .apply(n)
    .map((t) => `${t}: ${n.getPropertyValue(t)};`)
    .join("");
}
const DW = function (n, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "",
      i = arguments.length > 3 ? arguments[3] : void 0,
      r = arguments.length > 4 ? arguments[4] : void 0,
      o = arguments.length > 5 ? arguments[5] : void 0,
      p = arguments.length > 6 ? arguments[6] : void 0;
    if (t.length === 0) return "";
    Ht ||
      ((Ht = document.createElement("div")),
      Ht.setAttribute("aria-hidden", "true"),
      document.body.appendChild(Ht));
    const a = window.getComputedStyle(n),
      s = LW(a),
      u = Ff(a.lineHeight),
      d = Math.round(u * (e + 1) + Ff(a.paddingTop) + Ff(a.paddingBottom));
    Ht.setAttribute("style", s),
      (Ht.style.position = "fixed"),
      (Ht.style.left = "0"),
      (Ht.style.height = "auto"),
      (Ht.style.top = "-999999px"),
      (Ht.style.zIndex = "-1000"),
      (Ht.style.textOverflow = "clip"),
      (Ht.style.webkitLineClamp = "none"),
      Yr.render(W.createElement(W.Fragment, null), Ht);
    function l() {
      return Ht.scrollHeight < d;
    }
    const c = document.createElement("span"),
      h = document.createTextNode(o);
    c.appendChild(h),
      Ht.appendChild(c),
      i.map((_) => _ && Ht.appendChild(_.cloneNode(!0)));
    function m(_) {
      c.insertBefore(_, h);
    }
    function g(_, x) {
      const b = _.length;
      return x
        ? p === "end" || x > b - x
          ? _.slice(0, x) + r
          : _.slice(0, x) + r + _.slice(b - x, b)
        : r;
    }
    function f(_, x) {
      let b =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
        S =
          arguments.length > 3 && arguments[3] !== void 0
            ? arguments[3]
            : x.length,
        T = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
      const w = Math.floor((b + S) / 2),
        P = g(x, w);
      if (((_.textContent = P), b >= S - 1 && S > 0))
        for (let F = S; F >= b; F -= 1) {
          const V = g(x, F);
          if (((_.textContent = V), l() || !V)) return F === x.length ? x : V;
        }
      else if (S === 0) return r;
      return l() ? f(_, x, w, S, w) : f(_, x, b, w, T);
    }
    const v = document.createTextNode(t);
    m(v);
    const y = f(v, t);
    return (Ht.innerHTML = ""), y;
  },
  RW = DW;
var IW =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const dn = eh.PREFIX,
  kW = "...",
  FW = (n, e) => {
    const {
      mark: t,
      code: i,
      underline: r,
      strong: o,
      link: p,
      disabled: a,
    } = n;
    let s = e;
    const u = (d, l) => {
      let c = {};
      d &&
        (typeof d == "object" && (c = Object.assign({}, d)),
        (s = W.createElement(l, c, s)));
    };
    return (
      u(t, "mark"),
      u(i, "code"),
      u(r && !p, "u"),
      u(o, "strong"),
      u(n.delete, "del"),
      u(p, a ? "span" : "a"),
      s
    );
  };
class Xo extends Ce.Component {
  constructor(e) {
    super(e),
      (this.onResize = () => {
        this.rafId && window.cancelAnimationFrame(this.rafId),
          (this.rafId = window.requestAnimationFrame(
            this.getEllipsisState.bind(this)
          ));
      }),
      (this.canUseCSSEllipsis = () => {
        const { copyable: t } = this.props,
          {
            expandable: i,
            expandText: r,
            pos: o,
            suffix: p,
          } = this.getEllipsisOpt();
        return !i && Mc(r) && !t && o === "end" && !p.length;
      }),
      (this.shouldTruncated = (t) =>
        !t || t < 1
          ? !1
          : t <= 1
          ? this.wrapperRef.current.scrollWidth >
            this.wrapperRef.current.clientWidth
          : this.wrapperRef.current.scrollHeight >
            this.wrapperRef.current.offsetHeight),
      (this.showTooltip = () => {
        const { isOverflowed: t, isTruncated: i, expanded: r } = this.state,
          {
            showTooltip: o,
            expandable: p,
            expandText: a,
          } = this.getEllipsisOpt(),
          s = !r && (t || i),
          d = !p && Mc(a) && s && o;
        if (!d) return d;
        const l = { type: "tooltip", opts: {} };
        return typeof o == "object"
          ? o.type && o.type.toLowerCase() === "popover"
            ? YB({ opts: { style: { width: "240px" }, showArrow: !0 } }, o)
            : Object.assign(Object.assign({}, l), o)
          : l;
      }),
      (this.toggleOverflow = (t) => {
        const {
            onExpand: i,
            expandable: r,
            collapsible: o,
          } = this.getEllipsisOpt(),
          { expanded: p } = this.state;
        i && i(!p, t),
          ((r && !p) || (o && p)) && this.setState({ expanded: !p, first: !1 });
      }),
      (this.getEllipsisOpt = () => {
        const { ellipsis: t } = this.props;
        return t
          ? Object.assign(
              {
                rows: 1,
                expandable: !1,
                pos: "end",
                suffix: "",
                showTooltip: !1,
                collapsible: !1,
                expandText: t.expandable ? this.expandStr : void 0,
                collapseText: t.collapsible ? this.collapseStr : void 0,
              },
              typeof t == "object" ? t : null
            )
          : {};
      }),
      (this.renderExpandable = () => {
        const {
            expandText: t,
            expandable: i,
            collapseText: r,
            collapsible: o,
          } = this.getEllipsisOpt(),
          { expanded: p, first: a } = this.state,
          s = !i && Mc(t),
          u = !o && Mc(r);
        let d;
        return (
          !p && !s ? (d = t) : p && !a && !u && (d = r),
          !s || !u
            ? W.createElement(
                "a",
                {
                  role: "button",
                  tabIndex: 0,
                  className: `${dn}-ellipsis-expand`,
                  key: "expand",
                  ref: this.expandRef,
                  "aria-label": d,
                  onClick: this.toggleOverflow,
                  onKeyPress: (l) => Q1(l) && this.toggleOverflow(l),
                },
                d
              )
            : null
        );
      }),
      (this.getEllipsisStyle = () => {
        const { ellipsis: t } = this.props;
        if ((this.getEllipsisOpt(), !t))
          return { ellipsisCls: "", ellipsisStyle: {} };
        const { rows: i } = this.getEllipsisOpt(),
          { isOverflowed: r, expanded: o, isTruncated: p } = this.state,
          a = !o && this.canUseCSSEllipsis(),
          s = Be({
            [`${dn}-ellipsis`]: !0,
            [`${dn}-ellipsis-single-line`]: i === 1,
            [`${dn}-ellipsis-multiple-line`]: i > 1,
            [`${dn}-ellipsis-overflow-ellipsis`]: i === 1 && a,
          }),
          u = a && i > 1 ? { WebkitLineClamp: i } : {};
        return { ellipsisCls: s, ellipsisStyle: r ? u : {} };
      }),
      (this.renderEllipsisText = (t) => {
        const { suffix: i } = t,
          { children: r } = this.props,
          {
            isTruncated: o,
            expanded: p,
            isOverflowed: a,
            ellipsisContent: s,
          } = this.state;
        return p || !o
          ? W.createElement(W.Fragment, null, r, i && i.length ? i : null)
          : W.createElement("span", null, s, i);
      }),
      (this.state = {
        editable: !1,
        copied: !1,
        isOverflowed: !0,
        ellipsisContent: null,
        expanded: !1,
        isTruncated: !1,
        first: !0,
        prevChildren: null,
      }),
      (this.wrapperRef = W.createRef()),
      (this.expandRef = W.createRef()),
      (this.copyRef = W.createRef());
  }
  componentDidMount() {
    this.props.ellipsis &&
      (this.getEllipsisState(),
      window.addEventListener("resize", this.onResize));
  }
  static getDerivedStateFromProps(e, t) {
    const { prevChildren: i } = t,
      r = {};
    return (
      (r.prevChildren = e.children),
      e.ellipsis &&
        i !== e.children &&
        ((r.isOverflowed = !0),
        (r.ellipsisContent = null),
        (r.expanded = !1),
        (r.isTruncated = !1),
        (r.first = !0)),
      r
    );
  }
  componentDidUpdate(e) {
    this.props.children !== e.children &&
      (this.forceUpdate(), this.props.ellipsis && this.getEllipsisState());
  }
  componentWillUnmount() {
    this.props.ellipsis && window.removeEventListener("resize", this.onResize),
      this.rafId && window.cancelAnimationFrame(this.rafId);
  }
  getEllipsisState() {
    const { rows: e, suffix: t, pos: i } = this.getEllipsisOpt(),
      { children: r } = this.props;
    if (!this.wrapperRef || !this.wrapperRef.current)
      return this.onResize(), !1;
    const {
        ellipsisContent: o,
        isOverflowed: p,
        isTruncated: a,
        expanded: s,
      } = this.state,
      u = this.shouldTruncated(e),
      d = this.canUseCSSEllipsis(),
      l = u !== p;
    if (!e || e < 0 || s) return;
    if (d) {
      l && this.setState({ expanded: !u });
      return;
    }
    const c = [this.expandRef.current, this.copyRef && this.copyRef.current];
    Su(
      "children" in this.props && typeof r != "string",
      "[Semi Typography] 'Only children with pure text could be used with ellipsis at this moment."
    );
    const h = RW(Yr.findDOMNode(this.wrapperRef.current), e, r, c, kW, t, i);
    r === h
      ? this.setState({ expanded: !0 })
      : (o !== h || p !== u) &&
        this.setState({
          ellipsisContent: h,
          isOverflowed: u,
          isTruncated: r !== h,
        });
  }
  renderOperations() {
    return W.createElement(
      W.Fragment,
      null,
      this.renderExpandable(),
      this.renderCopy()
    );
  }
  renderCopy() {
    const { copyable: e, children: t } = this.props;
    if (!e) return null;
    let i,
      r = !1;
    Array.isArray(t)
      ? ((i = ""),
        t.forEach((p) => {
          typeof p == "object" && (r = !0), (i += String(p));
        }))
      : (typeof t != "object" || (r = !0), (i = String(t))),
      Su(
        r,
        "Children in Typography is a object, it will case a [object Object] mistake when copy to clipboard."
      );
    const o = Object.assign(
      { content: i, duration: 3 },
      typeof e == "object" ? e : null
    );
    return W.createElement(
      TW,
      Object.assign({}, o, { forwardRef: this.copyRef })
    );
  }
  renderIcon() {
    const { icon: e, size: t } = this.props;
    if (!e) return null;
    const i = t === "small" ? "small" : "default";
    return W.createElement(
      "span",
      { className: `${dn}-icon`, "x-semi-prop": "icon" },
      Y1(e) ? W.cloneElement(e, { size: i }) : e
    );
  }
  renderContent() {
    const e = this.props,
      {
        component: t,
        children: i,
        className: r,
        type: o,
        spacing: p,
        disabled: a,
        style: s,
        ellipsis: u,
        icon: d,
        size: l,
        link: c,
        heading: h,
      } = e,
      m = IW(e, [
        "component",
        "children",
        "className",
        "type",
        "spacing",
        "disabled",
        "style",
        "ellipsis",
        "icon",
        "size",
        "link",
        "heading",
      ]),
      g = Im(m, [
        "strong",
        "editable",
        "mark",
        "copyable",
        "underline",
        "code",
        "delete",
      ]),
      f = this.renderIcon(),
      v = this.getEllipsisOpt(),
      { ellipsisCls: y, ellipsisStyle: _ } = this.getEllipsisStyle();
    let x = u ? this.renderEllipsisText(v) : i;
    const b = Be({
      [`${dn}-link-text`]: c,
      [`${dn}-link-underline`]: this.props.underline && c,
    });
    x = FW(
      this.props,
      W.createElement(
        W.Fragment,
        null,
        f,
        this.props.link ? W.createElement("span", { className: b }, x) : x
      )
    );
    const S = /^h[1-6]$/,
      T = Be(r, y, {
        [`${dn}-${o}`]: o && !c,
        [`${dn}-${l}`]: l,
        [`${dn}-link`]: c,
        [`${dn}-disabled`]: a,
        [`${dn}-${p}`]: p,
        [`${dn}-${h}`]: qI(h) && S.test(h),
      });
    return W.createElement(
      p1,
      Object.assign(
        {
          className: T,
          style: Object.assign(Object.assign({}, s), _),
          component: t,
          forwardRef: this.wrapperRef,
        },
        g
      ),
      x,
      this.renderOperations()
    );
  }
  renderTipWrapper() {
    const { children: e } = this.props,
      t = this.showTooltip(),
      i = this.renderContent();
    if (t) {
      const { type: r, opts: o } = t;
      return r.toLowerCase() === "popover"
        ? W.createElement(
            OW,
            Object.assign({ content: e, position: "top" }, o),
            i
          )
        : W.createElement(
            gs,
            Object.assign({ content: e, position: "top" }, o),
            i
          );
    } else return i;
  }
  render() {
    return W.createElement(
      pl,
      { componentName: "Typography" },
      (e) => (
        (this.expandStr = e.expand),
        (this.collapseStr = e.collapse),
        this.renderTipWrapper()
      )
    );
  }
}
Xo.propTypes = {
  children: M.node,
  copyable: M.oneOfType([
    M.shape({
      text: M.string,
      onCopy: M.func,
      successTip: M.node,
      copyTip: M.node,
    }),
    M.bool,
  ]),
  delete: M.bool,
  disabled: M.bool,
  ellipsis: M.oneOfType([
    M.shape({
      rows: M.number,
      expandable: M.bool,
      expandText: M.string,
      onExpand: M.func,
      suffix: M.string,
      showTooltip: M.oneOfType([
        M.shape({ type: M.string, opts: M.object }),
        M.bool,
      ]),
      collapsible: M.bool,
      collapseText: M.string,
      pos: M.oneOf(["end", "middle"]),
    }),
    M.bool,
  ]),
  mark: M.bool,
  underline: M.bool,
  link: M.oneOfType([M.object, M.bool]),
  spacing: M.oneOf(cn.SPACING),
  strong: M.bool,
  size: M.oneOf(cn.SIZE),
  type: M.oneOf(cn.TYPE),
  style: M.object,
  className: M.string,
  icon: M.oneOfType([M.node, M.string]),
  heading: M.string,
  component: M.string,
};
Xo.defaultProps = {
  children: null,
  copyable: !1,
  delete: !1,
  disabled: !1,
  ellipsis: !1,
  icon: "",
  mark: !1,
  underline: !1,
  strong: !1,
  link: !1,
  type: "primary",
  spacing: "normal",
  size: "normal",
  style: {},
  className: "",
};
class zm extends Ce.PureComponent {
  render() {
    return W.createElement(
      Xo,
      Object.assign({ component: "span" }, this.props)
    );
  }
}
zm.propTypes = {
  copyable: M.oneOfType([M.object, M.bool]),
  delete: M.bool,
  disabled: M.bool,
  icon: M.oneOfType([M.node, M.string]),
  ellipsis: M.oneOfType([M.object, M.bool]),
  mark: M.bool,
  underline: M.bool,
  link: M.oneOfType([M.object, M.bool]),
  strong: M.bool,
  type: M.oneOf(cn.TYPE),
  size: M.oneOf(cn.SIZE),
  style: M.object,
  className: M.string,
  code: M.bool,
  component: M.string,
};
zm.defaultProps = {
  copyable: !1,
  delete: !1,
  disabled: !1,
  icon: "",
  ellipsis: !1,
  mark: !1,
  underline: !1,
  strong: !1,
  link: !1,
  type: "primary",
  style: {},
  size: "normal",
  className: "",
};
var NW =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
class Um extends Ce.PureComponent {
  render() {
    const e = this.props,
      { heading: t } = e,
      i = NW(e, ["heading"]),
      r = cn.HEADING.indexOf(t) !== -1 ? `h${t}` : "h1";
    return W.createElement(Xo, Object.assign({ component: r, heading: r }, i));
  }
}
Um.propTypes = {
  copyable: M.oneOfType([M.object, M.bool]),
  delete: M.bool,
  disabled: M.bool,
  ellipsis: M.oneOfType([M.object, M.bool]),
  mark: M.bool,
  link: M.oneOfType([M.object, M.bool]),
  underline: M.bool,
  strong: M.bool,
  type: M.oneOf(cn.TYPE),
  heading: M.oneOf(cn.HEADING),
  style: M.object,
  className: M.string,
  component: M.string,
};
Um.defaultProps = {
  copyable: !1,
  delete: !1,
  disabled: !1,
  ellipsis: !1,
  mark: !1,
  underline: !1,
  strong: !1,
  link: !1,
  type: "primary",
  heading: 1,
  style: {},
  className: "",
};
const BW = eh.PREFIX;
class jm extends Ce.PureComponent {
  render() {
    const { className: e } = this.props,
      t = Be(e, `${BW}-paragraph`);
    return W.createElement(
      Xo,
      Object.assign({ component: "p" }, this.props, { className: t })
    );
  }
}
jm.propTypes = {
  copyable: M.oneOfType([M.object, M.bool]),
  delete: M.bool,
  disabled: M.bool,
  ellipsis: M.oneOfType([M.object, M.bool]),
  mark: M.bool,
  link: M.oneOfType([M.object, M.bool]),
  underline: M.bool,
  strong: M.bool,
  type: M.oneOf(cn.TYPE),
  size: M.oneOf(cn.SIZE),
  spacing: M.oneOf(cn.SPACING),
  style: M.object,
  className: M.string,
  component: M.string,
};
jm.defaultProps = {
  copyable: !1,
  delete: !1,
  disabled: !1,
  ellipsis: !1,
  mark: !1,
  underline: !1,
  strong: !1,
  link: !1,
  type: "primary",
  size: "normal",
  spacing: "normal",
  style: {},
  className: "",
};
class zW {
  constructor(e, t, i, r, o) {
    (this.ruleMethods = {
      "bytes-decimal": (p) => {
        const a = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
        let s = 0;
        for (; p >= 1e3; ) (p /= 1e3), s++;
        return `${this.truncatePrecision(p)} ${a[s]}`;
      },
      "bytes-binary": (p) => {
        const a = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
        let s = 0;
        for (; p >= 1024; ) (p /= 1024), s++;
        return `${this.truncatePrecision(p)} ${a[s]}`;
      },
      percentages: (p) => {
        const a = p.toString().split(".");
        return Number(a[0]) === 0
          ? `${this.truncatePrecision(p * 100)}%`
          : `${this.truncatePrecision(p)}%`;
      },
      exponential: (p) => {
        const s = p.toExponential(this.precision + 2).split("e");
        return `${this.truncatePrecision(Number(s[0]))}e${s[1]}`;
      },
    }),
      (this.truncateMethods = {
        ceil: Math.ceil,
        floor: Math.floor,
        round: Math.round,
      }),
      (this.isDiyParser = typeof o < "u"),
      (this.content = e),
      (this.rule = t),
      (this.precision = i),
      (this.truncate = r),
      (this.parser = o);
  }
  format() {
    return this.isDiyParser
      ? this.parser(this.content)
      : this.rule === "text"
      ? Nf(this.content)
          .map((e) => (Bf(e) ? this.truncatePrecision(e) : e))
          .join("")
      : this.rule === "numbers"
      ? Nf(this.content)
          .filter((e) => Bf(e))
          .map((e) => this.truncatePrecision(e))
          .join(",")
      : Nf(this.content)
          .map((e) => (Bf(e) ? this.ruleMethods[this.rule](Number(e)) : e))
          .join("");
  }
  truncatePrecision(e) {
    const t =
        this.truncateMethods[this.truncate](
          Number(e) * Math.pow(10, this.precision)
        ) / Math.pow(10, this.precision),
      i = t.toString().split(".");
    if (i.length === 1) return t.toFixed(this.precision);
    const r = i[1].length;
    return r < this.precision
      ? `${i[0]}.${i[1]}${"0".repeat(this.precision - r)}`
      : t.toString();
  }
}
function Nf(n) {
  const e = /(-?[0-9]*\.?[0-9]+([eE]-?[0-9]+)?)|([^-\d\.]+)/g;
  return n.match(e) || [];
}
function Bf(n) {
  return !(isNaN(Number(n)) || n.replace(/\s+/g, "") === "");
}
class Hm extends Ce.PureComponent {
  formatNodeDFS(e) {
    return (
      Array.isArray(e) || (e = [e]),
      (e = e.map((t) =>
        typeof t == "string" || typeof t == "number"
          ? new zW(
              String(t),
              this.props.rule,
              this.props.precision,
              this.props.truncate,
              this.props.parser
            ).format()
          : typeof t == "function"
          ? this.formatNodeDFS(t())
          : typeof t == "object" && "children" in t.props
          ? Object.assign(Object.assign({}, t), {
              props: Object.assign(Object.assign({}, t.props), {
                children: this.formatNodeDFS(t.props.children),
              }),
            })
          : t
      )),
      e.length === 1 ? e[0] : e
    );
  }
  render() {
    const e = Object.assign({}, this.props);
    return (
      delete e.rule,
      delete e.parser,
      (e.children = this.formatNodeDFS(this.props.children)),
      W.createElement(Xo, Object.assign({ component: "span" }, e))
    );
  }
}
Hm.propTypes = {
  rule: M.oneOf(cn.RULE),
  precision: M.number,
  truncate: M.oneOf(cn.TRUNCATE),
  parser: M.func,
  copyable: M.oneOfType([M.object, M.bool]),
  delete: M.bool,
  disabled: M.bool,
  icon: M.oneOfType([M.node, M.string]),
  mark: M.bool,
  underline: M.bool,
  link: M.oneOfType([M.object, M.bool]),
  strong: M.bool,
  type: M.oneOf(cn.TYPE),
  size: M.oneOf(cn.SIZE),
  style: M.object,
  className: M.string,
  code: M.bool,
  component: M.string,
};
Hm.defaultProps = {
  rule: "text",
  precision: 0,
  truncate: "round",
  parser: void 0,
  copyable: !1,
  delete: !1,
  icon: "",
  mark: !1,
  underline: !1,
  strong: !1,
  link: !1,
  type: "primary",
  style: {},
  size: "normal",
  className: "",
};
const Ol = p1;
Ol.Text = zm;
Ol.Title = Um;
Ol.Paragraph = jm;
Ol.Numeral = Hm;
const UW = Ol;
var jW = Tr,
  HW = ci,
  VW = "[object Number]";
function WW(n) {
  return typeof n == "number" || (HW(n) && jW(n) == VW);
}
var GW = WW;
const $W = GW;
var XW =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
let i_ = -1;
function YW() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const { id: e, className: t } = n,
    i = XW(n, ["id", "className"]);
  let r = e;
  km(r) && (i_++, (r = i_));
  const o = `linearGradient-${r}`;
  return W.createElement(
    "svg",
    Object.assign({}, i, {
      className: t,
      width: "48",
      height: "48",
      viewBox: "0 0 36 36",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "aria-hidden": !0,
      "data-icon": "spin",
    }),
    W.createElement(
      "defs",
      null,
      W.createElement(
        "linearGradient",
        { x1: "0%", y1: "100%", x2: "100%", y2: "100%", id: o },
        W.createElement("stop", {
          stopColor: "currentColor",
          stopOpacity: "0",
          offset: "0%",
        }),
        W.createElement("stop", {
          stopColor: "currentColor",
          stopOpacity: "0.50",
          offset: "39.9430698%",
        }),
        W.createElement("stop", { stopColor: "currentColor", offset: "100%" })
      )
    ),
    W.createElement(
      "g",
      { stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" },
      W.createElement("rect", {
        fillOpacity: "0.01",
        fill: "none",
        x: "0",
        y: "0",
        width: "36",
        height: "36",
      }),
      W.createElement("path", {
        d: "M34,18 C34,9.163444 26.836556,2 18,2 C11.6597233,2 6.18078805,5.68784135 3.59122325,11.0354951",
        stroke: `url(#${o})`,
        strokeWidth: "4",
        strokeLinecap: "round",
      })
    )
  );
}
const nS = { PREFIX: `${Ye}-button` },
  Ll = {
    sizes: ["default", "small", "large"],
    iconPositions: ["left", "right"],
    htmlTypes: ["button", "reset", "submit"],
    btnTypes: ["primary", "secondary", "tertiary", "warning", "danger"],
    themes: ["solid", "borderless", "light"],
    DEFAULT_ICON_SIZE: "default",
    DEFAULT_ICON_POSITION: "left",
  },
  KW = {
    SIZE: ["extra-small", "small", "default", "large", "extra-large", "custom"],
    ICON_PREFIX: "semi-icon-",
  };
var qW =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const ZW = Ll.sizes,
  { htmlTypes: JW, btnTypes: QW } = Ll;
let Dl = class extends Ce.PureComponent {
  render() {
    const e = this.props,
      {
        children: t,
        block: i,
        htmlType: r,
        loading: o,
        circle: p,
        className: a,
        style: s,
        disabled: u,
        size: d,
        theme: l,
        type: c,
        prefixCls: h,
        iconPosition: m,
      } = e,
      g = qW(e, [
        "children",
        "block",
        "htmlType",
        "loading",
        "circle",
        "className",
        "style",
        "disabled",
        "size",
        "theme",
        "type",
        "prefixCls",
        "iconPosition",
      ]),
      f = Object.assign(
        Object.assign({ disabled: u }, Im(g, ["x-semi-children-alias"])),
        {
          className: Be(
            h,
            {
              [`${h}-${c}`]: !u && c,
              [`${h}-disabled`]: u,
              [`${h}-size-large`]: d === "large",
              [`${h}-size-small`]: d === "small",
              [`${h}-light`]: l === "light",
              [`${h}-block`]: i,
              [`${h}-circle`]: p,
              [`${h}-borderless`]: l === "borderless",
            },
            a
          ),
          type: r,
          "aria-disabled": u,
        }
      ),
      v = {};
    return (
      (a && a.includes("-with-icon")) ||
        (v["x-semi-prop"] = this.props["x-semi-children-alias"] || "children"),
      W.createElement(
        "button",
        Object.assign({}, f, {
          onClick: this.props.onClick,
          onMouseDown: this.props.onMouseDown,
          style: s,
        }),
        W.createElement(
          "span",
          Object.assign(
            {
              className: `${h}-content`,
              onClick: (y) => u && y.stopPropagation(),
            },
            v
          ),
          t
        )
      )
    );
  }
};
Dl.defaultProps = {
  disabled: !1,
  size: "default",
  type: "primary",
  theme: "light",
  block: !1,
  htmlType: "button",
  onMouseDown: Zs,
  onClick: Zs,
  onMouseEnter: Zs,
  onMouseLeave: Zs,
  prefixCls: nS.PREFIX,
};
Dl.propTypes = {
  children: M.node,
  disabled: M.bool,
  prefixCls: M.string,
  style: M.object,
  size: M.oneOf(ZW),
  type: M.oneOf(QW),
  block: M.bool,
  onClick: M.func,
  onMouseDown: M.func,
  circle: M.bool,
  loading: M.bool,
  htmlType: M.oneOf(JW),
  theme: M.oneOf(Ll.themes),
  className: M.string,
  onMouseEnter: M.func,
  onMouseLeave: M.func,
  "aria-label": M.string,
};
var e8 =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const t8 = KW.SIZE;
class Vm extends Ce.PureComponent {
  render() {
    const e = this.props,
      {
        children: t,
        iconPosition: i,
        iconSize: r,
        iconStyle: o,
        style: p,
        icon: a,
        noHorizontalPadding: s,
        theme: u,
        className: d,
        prefixCls: l,
        loading: c,
      } = e,
      h = e8(e, [
        "children",
        "iconPosition",
        "iconSize",
        "iconStyle",
        "style",
        "icon",
        "noHorizontalPadding",
        "theme",
        "className",
        "prefixCls",
        "loading",
      ]),
      m = Object.assign({}, p);
    Array.isArray(s)
      ? (s.includes("left") && (m.paddingLeft = 0),
        s.includes("right") && (m.paddingRight = 0))
      : s === !0
      ? ((m.paddingLeft = 0), (m.paddingRight = 0))
      : typeof s == "string" &&
        (s === "left" && (m.paddingLeft = 0),
        s === "right" && (m.paddingRight = 0));
    let g = null,
      f = null;
    c && !h.disabled
      ? (f = W.createElement(YW, null))
      : W.isValidElement(a) && (f = a);
    const v = Be({
        [`${l}-content-left`]: i === "right",
        [`${l}-content-right`]: i === "left",
      }),
      y = this.props["x-semi-children-alias"] || "children",
      _ =
        t != null
          ? W.createElement("span", { className: v, "x-semi-prop": y }, t)
          : null;
    i === "left"
      ? (g = W.createElement(W.Fragment, null, f, _))
      : (g = W.createElement(W.Fragment, null, _, f));
    const x = Be(d, `${l}-with-icon`, {
      [`${l}-with-icon-only`]: _ == null || _ === "",
      [`${l}-loading`]: c,
    });
    return W.createElement(
      Dl,
      Object.assign({}, h, { className: x, theme: u, style: m }),
      g
    );
  }
}
Vm.defaultProps = {
  iconPosition: Ll.DEFAULT_ICON_POSITION,
  prefixCls: nS.PREFIX,
  loading: !1,
  noHorizontalPadding: !1,
  onMouseEnter: ut,
  onMouseLeave: ut,
};
Vm.propTypes = {
  iconStyle: M.object,
  style: M.object,
  loading: M.bool,
  prefixCls: M.string,
  icon: M.oneOfType([M.object, M.string, M.node]),
  iconSize: M.oneOf(t8),
  noHorizontalPadding: M.oneOfType([M.bool, M.string, M.array]),
  children: M.node,
  theme: M.string,
  iconPosition: M.oneOf(Ll.iconPositions),
  className: M.string,
  onMouseEnter: M.func,
  onMouseLeave: M.func,
};
const Wm = Vm;
class Gm extends W.PureComponent {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e);
  }
  render() {
    const e = Object.assign({}, this.props),
      t = Boolean(e.icon),
      i = Boolean(e.loading),
      r = Boolean(e.disabled);
    return t || (i && !r)
      ? W.createElement(Wm, Object.assign({}, e))
      : W.createElement(Dl, Object.assign({}, e));
  }
}
Gm.propTypes = Object.assign(Object.assign({}, Dl.propTypes), Wm.propTypes);
Gm.elementType = "Button";
const r_ = Gm;
function $m(n) {
  return Object.keys(n).reduce(
    (e, t) => (
      (t.substr(0, 5) === "aria-" ||
        t.substr(0, 5) === "data-" ||
        t === "role") &&
        (e[t] = n[t]),
      e
    ),
    {}
  );
}
var n8 = Rm,
  i8 = 1,
  r8 = 4;
function s8(n) {
  return n8(n, i8 | r8);
}
var s_ = s8,
  o8 = xm,
  a8 = X1,
  l8 = Ho;
function c8(n, e, t) {
  for (var i = -1, r = e.length, o = {}; ++i < r; ) {
    var p = e[i],
      a = o8(n, p);
    t(a, p) && a8(o, l8(p, n), a);
  }
  return o;
}
var u8 = c8;
function h8(n, e) {
  return n != null && e in Object(n);
}
var f8 = h8,
  d8 = Ho,
  p8 = Cl,
  m8 = Fn,
  g8 = ih,
  v8 = Em,
  y8 = Qu;
function _8(n, e, t) {
  e = d8(e, n);
  for (var i = -1, r = e.length, o = !1; ++i < r; ) {
    var p = y8(e[i]);
    if (!(o = n != null && t(n, p))) break;
    n = n[p];
  }
  return o || ++i != r
    ? o
    : ((r = n == null ? 0 : n.length),
      !!r && v8(r) && g8(p, r) && (m8(n) || p8(n)));
}
var x8 = _8,
  b8 = f8,
  S8 = x8;
function w8(n, e) {
  return n != null && S8(n, e, b8);
}
var T8 = w8,
  C8 = u8,
  M8 = T8;
function E8(n, e) {
  return C8(n, e, function (t, i) {
    return M8(n, i);
  });
}
var A8 = E8,
  P8 = A8,
  O8 = V1,
  L8 = O8(function (n, e) {
    return n == null ? {} : P8(n, e);
  }),
  ip = L8;
const fi = { PREFIX: `${Ye}-collapse` },
  D8 = { iconPosition: ["left", "right"] };
class R8 extends Wi {
  constructor(e) {
    super(Object.assign({}, e));
  }
  initActiveKey() {
    const { defaultActiveKey: e, activeKey: t, accordion: i } = this.getProps();
    let r = t || e;
    return (
      i && (r = Array.isArray(r) ? r[0] : r),
      r && r.length ? ((r = Array.isArray(r) ? r : [r]), r) : []
    );
  }
  handleChange(e, t) {
    const { activeKey: i, accordion: r } = this.getProps(),
      { activeSet: o } = this.getStates();
    let p = new Set(o);
    p.has(e) ? p.delete(e) : r ? (p = new Set([e])) : p.add(e),
      this._adapter.handleChange([...p.values()], t),
      typeof i > "u" && this._adapter.addActiveKey(p);
  }
}
class I8 extends Wi {
  constructor(e) {
    super(Object.assign({}, e)),
      (this.updateDOMInRenderTree = (t) => {
        this._adapter.setDOMInRenderTree(t);
      }),
      (this.updateDOMHeight = (t) => {
        this._adapter.setDOMHeight(t);
      }),
      (this.updateVisible = (t) => {
        this._adapter.setVisible(t);
      }),
      (this.updateIsTransitioning = (t) => {
        this._adapter.setIsTransitioning(t);
      });
  }
}
const k8 = I8,
  o_ = { PREFIX: `${Ye}-collapsible` };
class Yo extends bn {
  constructor(e) {
    super(e),
      (this.domRef = W.createRef()),
      (this.handleResize = (t) => {
        const i = t[0];
        if (i) {
          const r = Yo.getEntryInfo(i);
          this.foundation.updateDOMHeight(r.height),
            this.foundation.updateDOMInRenderTree(r.isShown);
        }
      }),
      (this.isChildrenInRenderTree = () =>
        this.domRef.current ? this.domRef.current.offsetHeight > 0 : !1),
      (this.state = {
        domInRenderTree: !1,
        domHeight: 0,
        visible: this.props.isOpen,
        isTransitioning: !1,
      }),
      (this.foundation = new k8(this.adapter));
  }
  get adapter() {
    return Object.assign(Object.assign({}, super.adapter), {
      setDOMInRenderTree: (e) => {
        this.state.domInRenderTree !== e &&
          this.setState({ domInRenderTree: e });
      },
      setDOMHeight: (e) => {
        this.state.domHeight !== e && this.setState({ domHeight: e });
      },
      setVisible: (e) => {
        this.state.visible !== e && this.setState({ visible: e });
      },
      setIsTransitioning: (e) => {
        this.state.isTransitioning !== e &&
          this.setState({ isTransitioning: e });
      },
    });
  }
  componentDidMount() {
    super.componentDidMount(),
      (this.resizeObserver = new ResizeObserver(this.handleResize)),
      this.resizeObserver.observe(this.domRef.current);
    const e = this.isChildrenInRenderTree();
    this.foundation.updateDOMInRenderTree(e),
      e && this.foundation.updateDOMHeight(this.domRef.current.scrollHeight);
  }
  componentDidUpdate(e, t, i) {
    const r = Object.keys(this.props).filter((p) => !bi(this.props[p], e[p])),
      o = Object.keys(this.state).filter((p) => !bi(this.state[p], t[p]));
    r.includes("reCalcKey") &&
      this.foundation.updateDOMHeight(this.domRef.current.scrollHeight),
      o.includes("domInRenderTree") &&
        this.state.domInRenderTree &&
        this.foundation.updateDOMHeight(this.domRef.current.scrollHeight),
      r.includes("isOpen") &&
        (this.props.isOpen || !this.props.motion) &&
        this.foundation.updateVisible(this.props.isOpen),
      this.props.motion &&
        e.isOpen !== this.props.isOpen &&
        this.foundation.updateIsTransitioning(!0);
  }
  componentWillUnmount() {
    super.componentWillUnmount(), this.resizeObserver.disconnect();
  }
  render() {
    const e = Object.assign(
        {
          overflow: "hidden",
          height: this.props.isOpen
            ? this.state.domHeight
            : this.props.collapseHeight,
          opacity:
            this.props.isOpen ||
            !this.props.fade ||
            this.props.collapseHeight !== 0
              ? 1
              : 0,
          transitionDuration: `${
            this.props.motion && this.state.isTransitioning
              ? this.props.duration
              : 0
          }ms`,
        },
        this.props.style
      ),
      t = Be(
        `${o_.PREFIX}-wrapper`,
        {
          [`${o_.PREFIX}-transition`]:
            this.props.motion && this.state.isTransitioning,
        },
        this.props.className
      );
    return W.createElement(
      "div",
      {
        className: t,
        style: e,
        onTransitionEnd: () => {
          var i, r;
          this.props.isOpen || this.foundation.updateVisible(!1),
            this.foundation.updateIsTransitioning(!1),
            (r = (i = this.props).onMotionEnd) === null ||
              r === void 0 ||
              r.call(i);
        },
      },
      W.createElement(
        "div",
        {
          "x-semi-prop": "children",
          ref: this.domRef,
          style: { overflow: "hidden" },
          id: this.props.id,
        },
        (this.props.keepDOM ||
          this.props.collapseHeight !== 0 ||
          this.state.visible ||
          this.props.isOpen) &&
          this.props.children
      )
    );
  }
}
Yo.defaultProps = {
  isOpen: !1,
  duration: 250,
  motion: !0,
  keepDOM: !1,
  collapseHeight: 0,
  fade: !1,
};
Yo.getEntryInfo = (n) => {
  let e;
  n.borderBoxSize
    ? (e = !(
        n.borderBoxSize[0].blockSize === 0 &&
        n.borderBoxSize[0].inlineSize === 0
      ))
    : (e = !(n.contentRect.height === 0 && n.contentRect.width === 0));
  let t = 0;
  return (
    n.borderBoxSize
      ? (t = Math.ceil(n.borderBoxSize[0].blockSize))
      : (t = n.target.clientHeight),
    { isShown: e, height: t }
  );
};
Yo.propTypes = {
  motion: M.bool,
  children: M.node,
  isOpen: M.bool,
  duration: M.number,
  keepDOM: M.bool,
  collapseHeight: M.number,
  style: M.object,
  className: M.string,
  reCalcKey: M.oneOfType([M.string, M.number]),
};
const F8 = Yo,
  N8 = W.createContext({}),
  iS = N8;
var B8 =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
class ah extends Ce.PureComponent {
  constructor() {
    super(...arguments), (this.ariaID = $1({}));
  }
  renderHeader(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const { showArrow: i, header: r, extra: o } = this.props;
    let { expandIcon: p, collapseIcon: a } = this.context;
    const { expandIconPosition: s } = this.context;
    typeof p > "u" && (p = W.createElement(zV, null)),
      typeof a > "u" && (a = W.createElement(YV, null));
    const u = W.createElement(
        "span",
        {
          "aria-hidden": "true",
          className: Be([
            `${fi.PREFIX}-header-icon`,
            { [`${fi.PREFIX}-header-iconDisabled`]: !t },
          ]),
        },
        t && e ? a : p
      ),
      d = s === "left";
    return typeof r == "string"
      ? W.createElement(
          W.Fragment,
          null,
          i && (d ? u : null),
          W.createElement("span", null, r),
          W.createElement(
            "span",
            { className: `${fi.PREFIX}-header-right` },
            W.createElement("span", null, o),
            i && (d ? null : u)
          )
        )
      : W.createElement(
          W.Fragment,
          null,
          i && (d ? u : null),
          r,
          i && (d ? null : u)
        );
  }
  render() {
    const e = this.props,
      {
        className: t,
        children: i,
        itemKey: r,
        reCalcKey: o,
        header: p,
        extra: a,
        showArrow: s,
        disabled: u,
      } = e,
      d = B8(e, [
        "className",
        "children",
        "itemKey",
        "reCalcKey",
        "header",
        "extra",
        "showArrow",
        "disabled",
      ]),
      {
        keepDOM: l,
        expandIconPosition: c,
        activeSet: h,
        onClick: m,
        motion: g,
      } = this.context,
      f = h.has(r),
      v = Be(t, { [`${fi.PREFIX}-item`]: !0 }),
      y = Be({
        [`${fi.PREFIX}-header`]: !0,
        [`${fi.PREFIX}-header-disabled`]: u,
        [`${fi.PREFIX}-header-iconLeft`]: c === "left",
      }),
      _ = Be({ [`${fi.PREFIX}-content`]: !0 });
    return W.createElement(
      "div",
      Object.assign({ className: v }, d),
      W.createElement(
        "div",
        {
          role: "button",
          tabIndex: 0,
          className: y,
          "aria-disabled": u,
          "aria-expanded": f ? "true" : "false",
          "aria-owns": this.ariaID,
          onClick: (x) => !u && m(r, x),
        },
        this.renderHeader(f, i !== void 0 && !u)
      ),
      i &&
        W.createElement(
          F8,
          { isOpen: f, keepDOM: l, motion: g, reCalcKey: o },
          W.createElement(
            "div",
            { className: _, "aria-hidden": !f, id: this.ariaID },
            W.createElement(
              "div",
              { className: `${fi.PREFIX}-content-wrapper` },
              i
            )
          )
        )
    );
  }
}
ah.contextType = iS;
ah.propTypes = {
  itemKey: M.string,
  extra: M.node,
  header: M.oneOfType([M.string, M.node]),
  className: M.string,
  reCalcKey: M.oneOfType([M.string, M.number]),
  showArrow: M.bool,
  disabled: M.bool,
};
ah.defaultProps = { showArrow: !0, disabled: !1 };
var z8 =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
class lh extends bn {
  constructor(e) {
    super(e),
      (this.onChange = (i, r) => {
        this.foundation.handleChange(i, r);
      }),
      (this.foundation = new R8(this.adapter));
    const t = this.foundation.initActiveKey();
    (this.state = { activeSet: new Set(t) }),
      (this.onChange = this.onChange.bind(this));
  }
  get adapter() {
    return Object.assign(Object.assign({}, super.adapter), {
      handleChange: (e, t) => this.props.onChange(e, t),
      addActiveKey: (e) => this.setState({ activeSet: e }),
    });
  }
  static getDerivedStateFromProps(e, t) {
    if (e.activeKey) {
      const i = Array.isArray(e.activeKey) ? e.activeKey : [e.activeKey],
        r = new Set(i);
      return bi(r, t.activeSet)
        ? t
        : Object.assign(Object.assign({}, t), { activeSet: r });
    }
    return t;
  }
  componentWillUnmount() {
    this.foundation.destroy();
  }
  render() {
    const e = this.props,
      {
        defaultActiveKey: t,
        accordion: i,
        style: r,
        motion: o,
        className: p,
        keepDOM: a,
        expandIconPosition: s,
        expandIcon: u,
        collapseIcon: d,
        children: l,
      } = e;
    z8(e, [
      "defaultActiveKey",
      "accordion",
      "style",
      "motion",
      "className",
      "keepDOM",
      "expandIconPosition",
      "expandIcon",
      "collapseIcon",
      "children",
    ]);
    const c = Be(fi.PREFIX, p),
      { activeSet: h } = this.state;
    return W.createElement(
      "div",
      { className: c, style: r },
      W.createElement(
        iS.Provider,
        {
          value: {
            activeSet: h,
            expandIcon: u,
            collapseIcon: d,
            keepDOM: a,
            expandIconPosition: s,
            onClick: this.onChange,
            motion: o,
          },
        },
        l
      )
    );
  }
}
lh.Panel = ah;
lh.propTypes = {
  activeKey: M.oneOfType([M.string, M.array]),
  defaultActiveKey: M.oneOfType([M.string, M.array]),
  accordion: M.bool,
  onChange: M.func,
  expandIcon: M.node,
  collapseIcon: M.node,
  style: M.object,
  className: M.string,
  keepDOM: M.bool,
  motion: M.oneOfType([M.bool, M.func, M.object]),
  expandIconPosition: M.oneOf(D8.iconPosition),
};
lh.defaultProps = {
  defaultActiveKey: "",
  onChange: Zs,
  expandIconPosition: "right",
};
const a_ = lh,
  U8 = { PREFIX: `${Ye}-empty` };
const Dr = U8.PREFIX;
class rS extends bn {
  constructor(e) {
    super(e),
      (this.observe = (t) => {
        for (const i of t)
          i.type === "attributes" &&
            i.attributeName === "theme-mode" &&
            this.updateMode();
      }),
      (this.updateMode = () => {
        const t = this.body.getAttribute("theme-mode");
        t !== this.state.mode && this.setState({ mode: t });
      }),
      (this.state = { mode: null });
  }
  componentDidMount() {
    if (this.props.darkModeImage) {
      (this.body = window.document.body), this.updateMode();
      const e = { attributes: !0, childList: !1, subtree: !1 };
      (this.observer = new MutationObserver(this.observe)),
        this.observer.observe(this.body, e);
    }
  }
  componentWillUnmount() {
    this.observer && this.observer.disconnect();
  }
  render() {
    const {
        className: e,
        image: t,
        description: i,
        style: r,
        title: o,
        imageStyle: p,
        children: a,
        layout: s,
        darkModeImage: u,
      } = this.props,
      d = typeof i == "string" ? i : "empty",
      l = this.state.mode === "dark" && u ? u : t;
    let c = null;
    typeof l == "string"
      ? (c = W.createElement("img", { alt: d, src: l }))
      : l && "id" in l
      ? (c = W.createElement(
          "svg",
          { "aria-hidden": "true" },
          W.createElement("use", { xlinkHref: `#${l.id}` })
        ))
      : (c = l);
    const h = Be(e, Dr, { [`${Dr}-${s}`]: s }),
      m = c ? { heading: 4 } : { heading: 6, style: { fontWeight: 400 } };
    return W.createElement(
      "div",
      { className: h, style: r },
      W.createElement(
        "div",
        {
          className: `${Dr}-image`,
          style: p,
          "x-semi-prop": "image,darkModeImage",
        },
        c
      ),
      W.createElement(
        "div",
        { className: `${Dr}-content` },
        o
          ? W.createElement(
              UW.Title,
              Object.assign({}, m, {
                className: `${Dr}-title`,
                "x-semi-prop": "title",
              }),
              o
            )
          : null,
        i
          ? W.createElement(
              "div",
              { className: `${Dr}-description`, "x-semi-prop": "description" },
              i
            )
          : null,
        a
          ? W.createElement(
              "div",
              { className: `${Dr}-footer`, "x-semi-prop": "children" },
              a
            )
          : null
      )
    );
  }
}
rS.defaultProps = { layout: "vertical" };
const Rl = {
    PREFIX: `${Ye}-dropdown`,
    SELECTED: `${Ye}-dropdown-item-selected`,
    DISABLED: `${Ye}-dropdown-item-disabled`,
  },
  ch = {
    POSITION_SET: ao.POSITION_SET,
    TRIGGER_SET: ["hover", "focus", "click", "custom"],
    DEFAULT_LEAVE_DELAY: 100,
    ITEM_TYPE: ["primary", "secondary", "tertiary", "warning", "danger"],
  },
  l_ = { SPACING: 4, NESTED_SPACING: 2 };
class j8 extends Wi {
  handleVisibleChange(e) {
    this._adapter.setPopVisible(e), this._adapter.notifyVisibleChange(e);
    const { trigger: t } = this.getProps();
    if (e && t === "click") {
      const i = this._adapter.getPopupId();
      this.setFocusToFirstMenuItem(i);
    }
  }
  getMenuItemNodes(e) {
    const t = document.getElementById(e);
    return t
      ? Array.from(t.getElementsByTagName("li")).filter(
          (i) => i.ariaDisabled === "false"
        )
      : null;
  }
  setFocusToFirstMenuItem(e) {
    const t = this.getMenuItemNodes(e);
    t && q6(t);
  }
  setFocusToLastMenuItem(e) {
    const t = this.getMenuItemNodes(e);
    t && Z6(t);
  }
  handleKeyDown(e) {
    var t, i;
    const r =
      (i =
        (t = e.target) === null || t === void 0
          ? void 0
          : t.attributes["data-popupid"]) === null || i === void 0
        ? void 0
        : i.value;
    switch (e.key) {
      case " ":
      case "Enter":
        e.target.click();
        break;
      case "ArrowDown":
        this.setFocusToFirstMenuItem(r), dl(e);
        break;
      case "ArrowUp":
        this.setFocusToLastMenuItem(r), dl(e);
        break;
    }
  }
}
class H8 extends Wi {
  constructor() {
    super(...arguments), (this.menuItemNodes = null), (this.firstChars = []);
  }
  handleEscape(e) {
    this._adapter.getContext("trigger") === "custom" &&
      (e && nH(document.querySelectorAll("[data-popupid]"), e.id)).focus();
  }
  setFocusByFirstCharacter(e, t) {
    const i = eH(this.menuItemNodes, e, this.firstChars, t);
    i >= 0 && Al(this.menuItemNodes, this.menuItemNodes[i]);
  }
  onMenuKeydown(e) {
    const t = tH(e.target, "tooltip");
    this.menuItemNodes ||
      (this.menuItemNodes = [
        ...e.target.parentNode.getElementsByTagName("li"),
      ].filter((r) => r.ariaDisabled !== "true")),
      this.firstChars.length === 0 &&
        this.menuItemNodes.forEach((r) => {
          var o;
          this.firstChars.push(
            (o = r.textContent.trim()[0]) === null || o === void 0
              ? void 0
              : o.toLowerCase()
          );
        });
    const i = this.menuItemNodes.find((r) => r.tabIndex === 0);
    switch (e.key) {
      case " ":
      case "Enter":
        e.target.click();
        break;
      case "Escape":
        this.handleEscape(t);
        break;
      case "ArrowUp":
        J6(this.menuItemNodes, i), dl(e);
        break;
      case "ArrowDown":
        Q6(this.menuItemNodes, i), dl(e);
        break;
      default:
        K6(e.key) && this.setFocusByFirstCharacter(i, e.key);
        break;
    }
  }
}
const V8 = W.createContext({ level: 0 }),
  Eo = V8;
var W8 =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const G8 = Rl.PREFIX;
class Xm extends bn {
  constructor(e) {
    super(e), (this.foundation = new H8(this.adapter));
  }
  get adapter() {
    return Object.assign({}, super.adapter);
  }
  render() {
    const e = this.props,
      { children: t, className: i, style: r } = e,
      o = W8(e, ["children", "className", "style"]);
    return W.createElement(
      "ul",
      Object.assign({ role: "menu", "aria-orientation": "vertical" }, o, {
        className: Be(`${G8}-menu`, i),
        style: r,
        onKeyDown: (p) => this.foundation.onMenuKeydown(p),
      }),
      t
    );
  }
}
Xm.propTypes = { children: M.node, className: M.string, style: M.object };
Xm.contextType = Eo;
const $8 = Xm,
  Rr = Rl.PREFIX;
class Il extends bn {
  render() {
    const {
        children: e,
        disabled: t,
        className: i,
        forwardRef: r,
        style: o,
        type: p,
        active: a,
        icon: s,
        onKeyDown: u,
        showTick: d,
        hover: l,
      } = this.props,
      { showTick: c } = this.context,
      h = Be(i, {
        [`${Rr}-item`]: !0,
        [`${Rr}-item-disabled`]: t,
        [`${Rr}-item-hover`]: l,
        [`${Rr}-item-withTick`]: c ?? d,
        [`${Rr}-item-${p}`]: p,
        [`${Rr}-item-active`]: a,
      }),
      m = {};
    t ||
      ["onClick", "onMouseEnter", "onMouseLeave", "onContextMenu"].forEach(
        (v) => {
          m[v] = this.props[v];
        }
      );
    let g = null;
    switch (!0) {
      case d && a:
        g = W.createElement(np, null);
        break;
      case d && !a:
        g = W.createElement(np, { style: { color: "transparent" } });
        break;
      default:
        g = null;
        break;
    }
    let f = null;
    return (
      s && (f = W.createElement("div", { className: `${Rr}-item-icon` }, s)),
      W.createElement(
        "li",
        Object.assign(
          { role: "menuitem", tabIndex: -1, "aria-disabled": t },
          m,
          { onKeyDown: u, ref: (v) => r(v), className: h, style: o }
        ),
        g,
        f,
        e
      )
    );
  }
}
Il.propTypes = {
  children: M.oneOfType([M.string, M.node]),
  name: M.string,
  disabled: M.bool,
  selected: M.bool,
  onClick: M.func,
  onMouseEnter: M.func,
  onMouseLeave: M.func,
  onContextMenu: M.func,
  className: M.string,
  style: M.object,
  forwardRef: M.func,
  type: M.oneOf(ch.ITEM_TYPE),
  active: M.bool,
  icon: M.node,
};
Il.contextType = Eo;
Il.defaultProps = {
  disabled: !1,
  divided: !1,
  selected: !1,
  onMouseEnter: ut,
  onMouseLeave: ut,
  forwardRef: ut,
};
Il.elementType = "Dropdown.Item";
const X8 = Il,
  Y8 = Rl.PREFIX,
  sS = function () {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { style: e, className: t } = n;
    return W.createElement("div", {
      className: Be(`${Y8}-divider`, t),
      style: e,
    });
  };
sS.propTypes = { style: M.object, className: M.string };
const K8 = sS,
  c_ = Rl.PREFIX;
class Ym extends Ce.PureComponent {
  render() {
    const { className: e, style: t, children: i } = this.props,
      { showTick: r } = this.context,
      o = Be({ [`${c_}-title`]: !0, [`${c_}-title-withTick`]: r }, e);
    return W.createElement("div", { className: o, style: t }, i);
  }
}
Ym.propTypes = { children: M.node, className: M.string, style: M.object };
Ym.contextType = Eo;
const q8 = Ym;
var zf =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const Z8 = ch.POSITION_SET,
  J8 = ch.TRIGGER_SET;
class Pn extends bn {
  constructor(e) {
    super(e),
      (this.handleVisibleChange = (t) =>
        this.foundation.handleVisibleChange(t)),
      (this.state = { popVisible: e.visible }),
      (this.foundation = new j8(this.adapter)),
      (this.tooltipRef = W.createRef());
  }
  get adapter() {
    return Object.assign(Object.assign({}, super.adapter), {
      setPopVisible: (e) => this.setState({ popVisible: e }),
      notifyVisibleChange: (e) => this.props.onVisibleChange(e),
      getPopupId: () => this.tooltipRef.current.getPopupId(),
    });
  }
  renderContent() {
    const {
        render: e,
        menu: t,
        contentClassName: i,
        style: r,
        showTick: o,
        prefixCls: p,
        trigger: a,
      } = this.props,
      s = Be(p, i),
      { level: u = 0 } = this.context,
      d = { showTick: o, level: u + 1, trigger: a };
    let l = null;
    return (
      W.isValidElement(e)
        ? (l = e)
        : Array.isArray(t) && (l = this.renderMenu()),
      W.createElement(
        Eo.Provider,
        { value: d },
        W.createElement(
          "div",
          { className: s, style: r },
          W.createElement(
            "div",
            { className: `${p}-content`, "x-semi-prop": "render" },
            l
          )
        )
      )
    );
  }
  renderMenu() {
    const { menu: e } = this.props,
      t = e.map((i, r) => {
        switch (i.node) {
          case "title": {
            const { name: o, node: p } = i,
              a = zf(i, ["name", "node"]);
            return W.createElement(
              Pn.Title,
              Object.assign({}, a, { key: p + o + r }),
              o
            );
          }
          case "item": {
            const { node: o, name: p } = i,
              a = zf(i, ["node", "name"]);
            return W.createElement(
              Pn.Item,
              Object.assign({}, a, { key: o + p + r }),
              p
            );
          }
          case "divider":
            return W.createElement(Pn.Divider, { key: i.node + r });
          default:
            return null;
        }
      });
    return W.createElement(Pn.Menu, null, t);
  }
  renderPopCard() {
    const {
        render: e,
        contentClassName: t,
        style: i,
        showTick: r,
        prefixCls: o,
      } = this.props,
      p = Be(o, t),
      { level: a = 0 } = this.context,
      s = { showTick: r, level: a + 1 };
    return W.createElement(
      Eo.Provider,
      { value: s },
      W.createElement(
        "div",
        { className: p, style: i },
        W.createElement("div", { className: `${o}-content` }, e)
      )
    );
  }
  render() {
    const e = this.props,
      {
        children: t,
        position: i,
        trigger: r,
        onVisibleChange: o,
        zIndex: p,
        className: a,
        motion: s,
        margin: u,
        style: d,
        prefixCls: l,
      } = e,
      c = zf(e, [
        "children",
        "position",
        "trigger",
        "onVisibleChange",
        "zIndex",
        "className",
        "motion",
        "margin",
        "style",
        "prefixCls",
      ]);
    let { spacing: h } = this.props;
    const { level: m } = this.context,
      { popVisible: g } = this.state,
      f = this.renderContent();
    return (
      m > 0
        ? (h = typeof h == "number" ? h : l_.NESTED_SPACING)
        : (h === null || typeof h > "u") && (h = l_.SPACING),
      W.createElement(
        gs,
        Object.assign(
          {
            zIndex: p,
            motion: s,
            margin: u,
            content: f,
            className: a,
            prefixCls: l,
            spacing: h,
            position: i,
            trigger: r,
            onVisibleChange: this.handleVisibleChange,
            showArrow: !1,
            returnFocusOnClose: !0,
            ref: this.tooltipRef,
          },
          c
        ),
        W.isValidElement(t)
          ? W.cloneElement(t, {
              className: Be(st(t, "props.className"), { [`${l}-showing`]: g }),
              "aria-haspopup": !0,
              "aria-expanded": g,
              onKeyDown: (v) => {
                this.foundation.handleKeyDown(v);
                const y = st(t, "props.onKeyDown");
                y && y(v);
              },
            })
          : t
      )
    );
  }
}
Pn.Menu = $8;
Pn.Item = X8;
Pn.Divider = K8;
Pn.Title = q8;
Pn.contextType = Eo;
Pn.propTypes = {
  children: M.node,
  contentClassName: M.oneOfType([M.string, M.array]),
  className: M.string,
  getPopupContainer: M.func,
  margin: M.oneOfType([M.number, M.object]),
  mouseEnterDelay: M.number,
  mouseLeaveDelay: M.number,
  menu: M.array,
  motion: M.oneOfType([M.bool, M.func, M.object]),
  onVisibleChange: M.func,
  prefixCls: M.string,
  position: M.oneOf(Z8),
  rePosKey: M.oneOfType([M.string, M.number]),
  render: M.node,
  spacing: M.number,
  showTick: M.bool,
  style: M.object,
  trigger: M.oneOf(J8),
  visible: M.bool,
  zIndex: M.number,
};
Pn.defaultProps = {
  onVisibleChange: ut,
  prefixCls: Rl.PREFIX,
  zIndex: tr.DEFAULT_Z_INDEX,
  motion: !0,
  trigger: "hover",
  position: "bottom",
  mouseLeaveDelay: ch.DEFAULT_LEAVE_DELAY,
  showTick: !1,
  closeOnEsc: !0,
  onEscKeyDown: ut,
};
const Uf = Pn,
  Q8 = { PREFIX: Ye + "-overflow-list" },
  u_ = { COLLAPSE: "collapse", SCROLL: "scroll" },
  h_ = { START: "start", END: "end" },
  eG = { NONE: 0, GROW: 1, SHRINK: 2 },
  Jr = {
    BOUNDARY_SET: Object.values(h_),
    POSITION_SET: ["vertical", "horizontal"],
    MODE_SET: Object.values(u_),
    MODE_MAP: u_,
    BOUNDARY_MAP: h_,
    OVERFLOW_DIR: eG,
  },
  f_ = { MINIMUM_HTML_ELEMENT_WIDTH: 4 };
var oS = (function () {
    if (typeof Map < "u") return Map;
    function n(e, t) {
      var i = -1;
      return (
        e.some(function (r, o) {
          return r[0] === t ? ((i = o), !0) : !1;
        }),
        i
      );
    }
    return (function () {
      function e() {
        this.__entries__ = [];
      }
      return (
        Object.defineProperty(e.prototype, "size", {
          get: function () {
            return this.__entries__.length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.get = function (t) {
          var i = n(this.__entries__, t),
            r = this.__entries__[i];
          return r && r[1];
        }),
        (e.prototype.set = function (t, i) {
          var r = n(this.__entries__, t);
          ~r ? (this.__entries__[r][1] = i) : this.__entries__.push([t, i]);
        }),
        (e.prototype.delete = function (t) {
          var i = this.__entries__,
            r = n(i, t);
          ~r && i.splice(r, 1);
        }),
        (e.prototype.has = function (t) {
          return !!~n(this.__entries__, t);
        }),
        (e.prototype.clear = function () {
          this.__entries__.splice(0);
        }),
        (e.prototype.forEach = function (t, i) {
          i === void 0 && (i = null);
          for (var r = 0, o = this.__entries__; r < o.length; r++) {
            var p = o[r];
            t.call(i, p[1], p[0]);
          }
        }),
        e
      );
    })();
  })(),
  rp =
    typeof window < "u" &&
    typeof document < "u" &&
    window.document === document,
  Cu = (function () {
    return typeof global < "u" && global.Math === Math
      ? global
      : typeof self < "u" && self.Math === Math
      ? self
      : typeof window < "u" && window.Math === Math
      ? window
      : Function("return this")();
  })(),
  tG = (function () {
    return typeof requestAnimationFrame == "function"
      ? requestAnimationFrame.bind(Cu)
      : function (n) {
          return setTimeout(function () {
            return n(Date.now());
          }, 1e3 / 60);
        };
  })(),
  nG = 2;
function iG(n, e) {
  var t = !1,
    i = !1,
    r = 0;
  function o() {
    t && ((t = !1), n()), i && a();
  }
  function p() {
    tG(o);
  }
  function a() {
    var s = Date.now();
    if (t) {
      if (s - r < nG) return;
      i = !0;
    } else (t = !0), (i = !1), setTimeout(p, e);
    r = s;
  }
  return a;
}
var rG = 20,
  sG = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
  oG = typeof MutationObserver < "u",
  aG = (function () {
    function n() {
      (this.connected_ = !1),
        (this.mutationEventsAdded_ = !1),
        (this.mutationsObserver_ = null),
        (this.observers_ = []),
        (this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
        (this.refresh = iG(this.refresh.bind(this), rG));
    }
    return (
      (n.prototype.addObserver = function (e) {
        ~this.observers_.indexOf(e) || this.observers_.push(e),
          this.connected_ || this.connect_();
      }),
      (n.prototype.removeObserver = function (e) {
        var t = this.observers_,
          i = t.indexOf(e);
        ~i && t.splice(i, 1),
          !t.length && this.connected_ && this.disconnect_();
      }),
      (n.prototype.refresh = function () {
        var e = this.updateObservers_();
        e && this.refresh();
      }),
      (n.prototype.updateObservers_ = function () {
        var e = this.observers_.filter(function (t) {
          return t.gatherActive(), t.hasActive();
        });
        return (
          e.forEach(function (t) {
            return t.broadcastActive();
          }),
          e.length > 0
        );
      }),
      (n.prototype.connect_ = function () {
        !rp ||
          this.connected_ ||
          (document.addEventListener("transitionend", this.onTransitionEnd_),
          window.addEventListener("resize", this.refresh),
          oG
            ? ((this.mutationsObserver_ = new MutationObserver(this.refresh)),
              this.mutationsObserver_.observe(document, {
                attributes: !0,
                childList: !0,
                characterData: !0,
                subtree: !0,
              }))
            : (document.addEventListener("DOMSubtreeModified", this.refresh),
              (this.mutationEventsAdded_ = !0)),
          (this.connected_ = !0));
      }),
      (n.prototype.disconnect_ = function () {
        !rp ||
          !this.connected_ ||
          (document.removeEventListener("transitionend", this.onTransitionEnd_),
          window.removeEventListener("resize", this.refresh),
          this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
          this.mutationEventsAdded_ &&
            document.removeEventListener("DOMSubtreeModified", this.refresh),
          (this.mutationsObserver_ = null),
          (this.mutationEventsAdded_ = !1),
          (this.connected_ = !1));
      }),
      (n.prototype.onTransitionEnd_ = function (e) {
        var t = e.propertyName,
          i = t === void 0 ? "" : t,
          r = sG.some(function (o) {
            return !!~i.indexOf(o);
          });
        r && this.refresh();
      }),
      (n.getInstance = function () {
        return this.instance_ || (this.instance_ = new n()), this.instance_;
      }),
      (n.instance_ = null),
      n
    );
  })(),
  aS = function (n, e) {
    for (var t = 0, i = Object.keys(e); t < i.length; t++) {
      var r = i[t];
      Object.defineProperty(n, r, {
        value: e[r],
        enumerable: !1,
        writable: !1,
        configurable: !0,
      });
    }
    return n;
  },
  Ao = function (n) {
    var e = n && n.ownerDocument && n.ownerDocument.defaultView;
    return e || Cu;
  },
  lS = uh(0, 0, 0, 0);
function Mu(n) {
  return parseFloat(n) || 0;
}
function d_(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  return e.reduce(function (i, r) {
    var o = n["border-" + r + "-width"];
    return i + Mu(o);
  }, 0);
}
function lG(n) {
  for (
    var e = ["top", "right", "bottom", "left"], t = {}, i = 0, r = e;
    i < r.length;
    i++
  ) {
    var o = r[i],
      p = n["padding-" + o];
    t[o] = Mu(p);
  }
  return t;
}
function cG(n) {
  var e = n.getBBox();
  return uh(0, 0, e.width, e.height);
}
function uG(n) {
  var e = n.clientWidth,
    t = n.clientHeight;
  if (!e && !t) return lS;
  var i = Ao(n).getComputedStyle(n),
    r = lG(i),
    o = r.left + r.right,
    p = r.top + r.bottom,
    a = Mu(i.width),
    s = Mu(i.height);
  if (
    (i.boxSizing === "border-box" &&
      (Math.round(a + o) !== e && (a -= d_(i, "left", "right") + o),
      Math.round(s + p) !== t && (s -= d_(i, "top", "bottom") + p)),
    !fG(n))
  ) {
    var u = Math.round(a + o) - e,
      d = Math.round(s + p) - t;
    Math.abs(u) !== 1 && (a -= u), Math.abs(d) !== 1 && (s -= d);
  }
  return uh(r.left, r.top, a, s);
}
var hG = (function () {
  return typeof SVGGraphicsElement < "u"
    ? function (n) {
        return n instanceof Ao(n).SVGGraphicsElement;
      }
    : function (n) {
        return n instanceof Ao(n).SVGElement && typeof n.getBBox == "function";
      };
})();
function fG(n) {
  return n === Ao(n).document.documentElement;
}
function dG(n) {
  return rp ? (hG(n) ? cG(n) : uG(n)) : lS;
}
function pG(n) {
  var e = n.x,
    t = n.y,
    i = n.width,
    r = n.height,
    o = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object,
    p = Object.create(o.prototype);
  return (
    aS(p, {
      x: e,
      y: t,
      width: i,
      height: r,
      top: t,
      right: e + i,
      bottom: r + t,
      left: e,
    }),
    p
  );
}
function uh(n, e, t, i) {
  return { x: n, y: e, width: t, height: i };
}
var mG = (function () {
    function n(e) {
      (this.broadcastWidth = 0),
        (this.broadcastHeight = 0),
        (this.contentRect_ = uh(0, 0, 0, 0)),
        (this.target = e);
    }
    return (
      (n.prototype.isActive = function () {
        var e = dG(this.target);
        return (
          (this.contentRect_ = e),
          e.width !== this.broadcastWidth || e.height !== this.broadcastHeight
        );
      }),
      (n.prototype.broadcastRect = function () {
        var e = this.contentRect_;
        return (
          (this.broadcastWidth = e.width), (this.broadcastHeight = e.height), e
        );
      }),
      n
    );
  })(),
  gG = (function () {
    function n(e, t) {
      var i = pG(t);
      aS(this, { target: e, contentRect: i });
    }
    return n;
  })(),
  vG = (function () {
    function n(e, t, i) {
      if (
        ((this.activeObservations_ = []),
        (this.observations_ = new oS()),
        typeof e != "function")
      )
        throw new TypeError(
          "The callback provided as parameter 1 is not a function."
        );
      (this.callback_ = e), (this.controller_ = t), (this.callbackCtx_ = i);
    }
    return (
      (n.prototype.observe = function (e) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
          if (!(e instanceof Ao(e).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var t = this.observations_;
          t.has(e) ||
            (t.set(e, new mG(e)),
            this.controller_.addObserver(this),
            this.controller_.refresh());
        }
      }),
      (n.prototype.unobserve = function (e) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
          if (!(e instanceof Ao(e).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var t = this.observations_;
          t.has(e) &&
            (t.delete(e), t.size || this.controller_.removeObserver(this));
        }
      }),
      (n.prototype.disconnect = function () {
        this.clearActive(),
          this.observations_.clear(),
          this.controller_.removeObserver(this);
      }),
      (n.prototype.gatherActive = function () {
        var e = this;
        this.clearActive(),
          this.observations_.forEach(function (t) {
            t.isActive() && e.activeObservations_.push(t);
          });
      }),
      (n.prototype.broadcastActive = function () {
        if (this.hasActive()) {
          var e = this.callbackCtx_,
            t = this.activeObservations_.map(function (i) {
              return new gG(i.target, i.broadcastRect());
            });
          this.callback_.call(e, t, e), this.clearActive();
        }
      }),
      (n.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
      }),
      (n.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
      }),
      n
    );
  })(),
  cS = typeof WeakMap < "u" ? new WeakMap() : new oS(),
  uS = (function () {
    function n(e) {
      if (!(this instanceof n))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var t = aG.getInstance(),
        i = new vG(e, t, this);
      cS.set(this, i);
    }
    return n;
  })();
["observe", "unobserve", "disconnect"].forEach(function (n) {
  uS.prototype[n] = function () {
    var e;
    return (e = cS.get(this))[n].apply(e, arguments);
  };
});
var yG = (function () {
  return typeof Cu.ResizeObserver < "u" ? Cu.ResizeObserver : uS;
})();
const p_ = yG;
class Ua extends bn {
  constructor(e) {
    super(e),
      (this.getElement = () => {
        try {
          return co.findDOMNode(this.childNode || this);
        } catch {
          return null;
        }
      }),
      (this.mergeRef = (t, i) => {
        (this.childNode = i),
          typeof t == "function"
            ? t(i)
            : typeof t == "object" && t && "current" in t && (t.current = i);
      }),
      (this.observer = new p_(e.onResize));
  }
  componentDidMount() {
    this.observeElement();
  }
  componentDidUpdate(e) {
    this.observeElement(this.props.observeParent !== e.observeParent);
  }
  componentWillUnmount() {
    this.observer &&
      (this.observer.disconnect(),
      (this.observer = null),
      (this.element = null));
  }
  observeElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const t = this.getElement();
    if (
      (this.observer || (this.observer = new p_(this.props.onResize)),
      !(t && t instanceof Element))
    ) {
      this.observer.disconnect();
      return;
    }
    (t === this.element && !e) ||
      (this.observer.disconnect(),
      (this.element = t),
      this.observer.observe(t),
      this.props.observeParent &&
        t.parentNode &&
        t.parentNode.ownerDocument &&
        t.parentNode.ownerDocument.defaultView &&
        t.parentNode instanceof
          t.parentNode.ownerDocument.defaultView.HTMLElement &&
        ((this._parentNode = t.parentNode),
        this.observer.observe(this._parentNode)));
  }
  render() {
    const e = W.Children.only(this.props.children),
      { ref: t } = e;
    return W.cloneElement(e, { ref: (i) => this.mergeRef(t, i) });
  }
}
Ua.propTypes = { onResize: M.func, observeParent: M.bool };
Ua.defaultProps = { onResize: () => {}, observeParent: !1 };
class Km extends W.PureComponent {
  componentDidMount() {
    const { items: e } = this.props;
    this.cachedKeys = Object.keys(e);
    const {
      root: t,
      threshold: i,
      rootMargin: r,
      option: o,
      onIntersect: p,
    } = this.props;
    (this.observer = new IntersectionObserver(
      p,
      Object.assign({ root: t, threshold: i, rootMargin: r }, o)
    )),
      this.observeElement();
  }
  componentDidUpdate() {
    const { items: e } = this.props,
      t = Object.keys(e);
    bi(this.cachedKeys, t) || (this.observeElement(!0), (this.cachedKeys = t));
  }
  componentWillUnmount() {
    this.observer && (this.observer.disconnect(), (this.observer = null));
  }
  observeElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const { items: t } = this.props;
    if (gi(t)) {
      this.observer.disconnect();
      return;
    }
    e && this.observer.disconnect(),
      Object.keys(t).forEach((i) => {
        const r = t[i];
        r && qs(r) && this.observer.observe(r);
      });
  }
  render() {
    const { children: e } = this.props;
    return e;
  }
}
Km.propTypes = {
  onIntersect: M.func,
  option: M.object,
  root: M.any,
  threshold: M.number,
  rootMargin: M.string,
  items: M.object,
};
Km.defaultProps = {
  onIntersect: () => {},
  threshold: 0.75,
  rootMargin: "0px",
  option: {},
  items: {},
};
const _G = Jr.BOUNDARY_MAP;
class xG extends Wi {
  constructor(e) {
    super(Object.assign({}, e)),
      (this.previousY = void 0),
      (this.isScrollMode = () => {
        const { renderMode: t } = this.getProps();
        return t === "scroll";
      }),
      (this.getReversedItems = () => {
        const { items: t } = this.getProps();
        return s_(t).reverse();
      });
  }
  getOverflowItem() {
    const { items: e } = this.getProps(),
      { visibleState: t, overflow: i } = this.getStates();
    if (!this.isScrollMode()) return i;
    const r = e.map((s) => {
        let { key: u } = s;
        return Boolean(t.get(u));
      }),
      o = r.indexOf(!0),
      p = r.lastIndexOf(!0),
      a = [];
    return (
      (a[0] = o >= 0 ? e.slice(0, o) : []),
      (a[1] = p >= 0 ? e.slice(p + 1, e.length) : e),
      a
    );
  }
  handleIntersect(e) {
    const t = s_(this.getState("visibleState")),
      i = {};
    e.forEach((s) => {
      const u = st(s, "target.dataset.scrollkey"),
        d = s.isIntersecting;
      (i[u] = s), t.set(u, d);
    });
    let r = !1;
    for (const s of t.values())
      if (s) {
        r = !0;
        break;
      }
    const o = r,
      [p] = e,
      a = p.boundingClientRect.y;
    if (!o && this.previousY !== void 0 && a !== this.previousY) {
      this.previousY = a;
      return;
    }
    (this.previousY = a),
      this._adapter.updateVisibleState(t),
      this._adapter.notifyIntersect(i);
  }
  handleCollapseOverflow() {
    const { minVisibleItems: e, collapseFrom: t } = this.getProps(),
      {
        overflowWidth: i,
        containerWidth: r,
        pivot: o,
        overflowStatus: p,
      } = this.getStates(),
      { items: a, onOverflow: s } = this.getProps();
    let u = i,
      d = 0,
      l = !1;
    for (const c of this._adapter.getItemSizeMap().values()) {
      if (((u += c), u > r)) {
        l = !0;
        break;
      }
      if (d === a.length - 1) {
        this._adapter.updateStates({
          overflowStatus: "normal",
          pivot: a.length - 1,
          visible: a,
          overflow: [],
        });
        break;
      }
      d++;
    }
    if (l) {
      const c = Math.max(e, d),
        h = t === _G.START,
        m = h ? this.getReversedItems().slice(0, c).reverse() : a.slice(0, c),
        g = h ? this.getReversedItems().slice(c).reverse() : a.slice(c);
      this._adapter.updateStates({
        overflowStatus: "overflowed",
        pivot: c,
        visible: m,
        overflow: g,
      }),
        o !== c && s(g);
      return;
    }
  }
}
const bG = xG;
const ya = Q8.PREFIX,
  jf = Jr.BOUNDARY_MAP,
  m_ = Jr.OVERFLOW_DIR,
  _a = Jr.MODE_MAP;
class qm extends bn {
  constructor(e) {
    var t;
    super(e),
      (t = this),
      (this.scroller = null),
      (this.spacer = null),
      (this.isScrollMode = () => {
        const { renderMode: i } = this.props;
        return i === _a.SCROLL;
      }),
      (this.resize = function () {
        let i =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var r;
        const o =
          (r = i[0]) === null || r === void 0 ? void 0 : r.target.clientWidth;
        t.setState({ containerWidth: o, overflowStatus: "calculating" });
      }),
      (this.reintersect = (i) => {
        this.foundation.handleIntersect(i);
      }),
      (this.mergeRef = (i, r, o) => {
        (this.itemRefs[o] = r),
          typeof i == "function"
            ? i(r)
            : typeof i == "object" && i && "current" in i && (i.current = r);
      }),
      (this.renderOverflow = () => {
        const i = this.foundation.getOverflowItem();
        return this.props.overflowRenderer(i);
      }),
      (this.getItemKey = (i, r) => {
        const { itemKey: o } = this.props;
        return Bo(o) ? o(i) : st(i, o || "key", r);
      }),
      (this.renderItemList = () => {
        const {
            className: i,
            wrapperClassName: r,
            wrapperStyle: o,
            style: p,
            visibleItemRenderer: a,
            renderMode: s,
            collapseFrom: u,
          } = this.props,
          { visible: d, overflowStatus: l } = this.state;
        let c = this.renderOverflow();
        if (
          !this.isScrollMode() &&
          (Array.isArray(c) && (c = W.createElement(W.Fragment, null, c)),
          W.isValidElement(c))
        ) {
          const g = W.cloneElement(c);
          c = W.createElement(
            Ua,
            {
              onResize: (f) => {
                let [v] = f;
                this.setState({
                  overflowWidth: v.target.clientWidth,
                  overflowStatus: "calculating",
                });
              },
            },
            W.createElement("div", { className: `${ya}-overflow` }, g)
          );
        }
        const h =
          s === _a.SCROLL
            ? [
                c[0],
                W.createElement(
                  "div",
                  {
                    className: Be(r, `${ya}-scroll-wrapper`),
                    ref: (g) => {
                      this.scroller = g;
                    },
                    style: Object.assign({}, o),
                    key: `${ya}-scroll-wrapper`,
                  },
                  d.map(a).map((g) => {
                    const { forwardRef: f, key: v } = g;
                    return W.cloneElement(g, {
                      ref: (y) => this.mergeRef(f, y, v),
                      "data-scrollkey": `${v}`,
                      key: v,
                    });
                  })
                ),
                c[1],
              ]
            : [
                u === jf.START ? c : null,
                d.map((g, f) => {
                  const { key: v } = g,
                    y = a(g, f),
                    _ = W.cloneElement(y);
                  return W.createElement(
                    Ua,
                    {
                      key: v,
                      onResize: (x) => {
                        let [b] = x;
                        return this.onItemResize(b, g, f);
                      },
                    },
                    W.createElement(
                      "div",
                      { key: v, className: `${ya}-item` },
                      _
                    )
                  );
                }),
                u === jf.END ? c : null,
              ];
        return W.createElement(
          "div",
          {
            className: Be(`${ya}`, i),
            style: Object.assign(
              Object.assign({}, p),
              s === _a.COLLAPSE
                ? {
                    maxWidth: "100%",
                    visibility: l === "calculating" ? "hidden" : "visible",
                  }
                : null
            ),
          },
          ...h
        );
      }),
      (this.onItemResize = (i, r, o) => {
        const p = this.getItemKey(r, o),
          a = this.itemSizeMap.get(p);
        a
          ? a !== i.target.clientWidth &&
            (this.itemSizeMap.set(p, i.target.clientWidth),
            this.setState({ overflowStatus: "calculating" }))
          : this.itemSizeMap.set(p, i.target.clientWidth);
        const { maxCount: s } = this.state;
        this.itemSizeMap.size === s &&
          this.setState({ overflowStatus: "calculating" });
      }),
      (this.state = {
        direction: m_.GROW,
        lastOverflowCount: 0,
        overflow: [],
        visible: [],
        containerWidth: 0,
        visibleState: new Map(),
        itemSizeMap: new Map(),
        overflowStatus: "calculating",
        pivot: -1,
        overflowWidth: 0,
        maxCount: 0,
      }),
      (this.foundation = new bG(this.adapter)),
      (this.previousWidths = new Map()),
      (this.itemRefs = {}),
      (this.itemSizeMap = new Map());
  }
  static getDerivedStateFromProps(e, t) {
    const { prevProps: i } = t,
      r = {};
    r.prevProps = e;
    const o = (p) => (!i && p in e) || (i && !bi(i[p], e[p]));
    if (o("items") || o("style")) {
      if (
        ((r.direction = m_.GROW),
        (r.lastOverflowCount = 0),
        (r.maxCount = 0),
        e.renderMode === _a.SCROLL)
      )
        (r.visible = e.items), (r.overflow = []);
      else {
        let p = e.items.length;
        Math.floor(t.containerWidth / f_.MINIMUM_HTML_ELEMENT_WIDTH) !== 0 &&
          (p = Math.min(
            p,
            Math.floor(t.containerWidth / f_.MINIMUM_HTML_ELEMENT_WIDTH)
          ));
        const a = e.collapseFrom === jf.START,
          s = a ? Jy(e.items).reverse().slice(0, p) : e.items.slice(0, p),
          u = a ? Jy(e.items).reverse().slice(p) : e.items.slice(p);
        (r.visible = s), (r.overflow = u), (r.maxCount = p);
      }
      (r.pivot = -1), (r.overflowStatus = "calculating");
    }
    return r;
  }
  get adapter() {
    return Object.assign(Object.assign({}, super.adapter), {
      updateVisibleState: (e) => {
        this.setState({ visibleState: e });
      },
      updateStates: (e) => {
        this.setState(Object.assign({}, e));
      },
      notifyIntersect: (e) => {
        this.props.onIntersect && this.props.onIntersect(e);
      },
      getItemSizeMap: () => this.itemSizeMap,
    });
  }
  componentDidUpdate(e, t) {
    bi(e.items, this.props.items) ||
      ((this.itemRefs = {}), this.setState({ visibleState: new Map() }));
    const {
      overflow: i,
      containerWidth: r,
      visible: o,
      overflowStatus: p,
    } = this.state;
    this.isScrollMode() ||
      p !== "calculating" ||
      this.foundation.handleCollapseOverflow();
  }
  render() {
    const e = this.renderItemList(),
      { renderMode: t } = this.props;
    return t === _a.SCROLL
      ? W.createElement(
          Km,
          {
            onIntersect: this.reintersect,
            root: this.scroller,
            threshold: this.props.threshold,
            items: this.itemRefs,
          },
          e
        )
      : W.createElement(Ua, { onResize: this.resize }, e);
  }
}
qm.defaultProps = {
  collapseFrom: "end",
  minVisibleItems: 0,
  overflowRenderer: () => null,
  renderMode: "collapse",
  threshold: 0.75,
  visibleItemRenderer: () => null,
  onOverflow: () => null,
};
qm.propTypes = {
  className: M.string,
  collapseFrom: M.oneOf(Jr.BOUNDARY_SET),
  direction: M.oneOf(Jr.POSITION_SET),
  items: M.array,
  minVisibleItems: M.number,
  onIntersect: M.func,
  onOverflow: M.func,
  overflowRenderer: M.func,
  renderMode: M.oneOf(Jr.MODE_SET),
  style: M.object,
  threshold: M.number,
  visibleItemRenderer: M.func,
  wrapperClassName: M.string,
  wrapperStyle: M.object,
};
const SG = qm,
  Ke = {
    TABS: `${Ye}-tabs`,
    TABS_BAR: `${Ye}-tabs-bar`,
    TABS_BAR_LINE: `${Ye}-tabs-bar-line`,
    TABS_BAR_CARD: `${Ye}-tabs-bar-card`,
    TABS_BAR_BUTTON: `${Ye}-tabs-bar-button`,
    TABS_BAR_EXTRA: `${Ye}-tabs-bar-extra`,
    TABS_TAB: `${Ye}-tabs-tab`,
    TABS_TAB_ACTIVE: `${Ye}-tabs-tab-active`,
    TABS_TAB_DISABLED: `${Ye}-tabs-tab-disabled`,
    TABS_CONTENT: `${Ye}-tabs-content`,
    TABS_CONTENT_ANIMATED: `${Ye}-tabs-content-animated`,
    TABS_CONTENT_NO_ANIMATED: `${Ye}-tabs-content-no-animated`,
    TABS_PANE: `${Ye}-tabs-pane`,
    TABS_PANE_INACTIVE: `${Ye}-tabs-pane-inactive`,
    TABS_PANE_ACTIVE: `${Ye}-tabs-pane-active`,
    TABS_PANE_MOTION_OVERLAY: `${Ye}-tabs-pane-motion-overlay`,
    TABS_PANE_ANIMATING: `${Ye}-tabs-pane-animating`,
    TABS_PANE_ANIMATE_LEFT_SHOW: `${Ye}-tabs-pane-animate-leftShow`,
    TABS_PANE_ANIMATE_RIGHT_SHOW: `${Ye}-tabs-pane-animate-rightShow`,
    TABS_PANE_ANIMATE_TOP_SHOW: `${Ye}-tabs-pane-animate-topShow`,
    TABS_PANE_ANIMATE_BOTTOM_SHOW: `${Ye}-tabs-pane-animate-bottomShow`,
  },
  lo = {
    TYPE_MAP: ["line", "card", "button"],
    SIZE: ["small", "medium", "large"],
    POSITION_MAP: ["top", "left"],
  };
class wG extends Wi {
  constructor(e) {
    super(Object.assign({}, e)),
      (this.destroy = ut),
      (this.handlePrevent = (t) => {
        t.stopPropagation(), t.preventDefault();
      }),
      (this.handleKeyDown = (t, i, r) => {
        const { preventScroll: o } = this.getProps(),
          p = [...t.target.parentNode.childNodes].filter(
            (a) =>
              st(a, "attributes.data-tabkey.value", "").includes("semiTab") &&
              st(a, "attributes.aria-disabled.value", "") !== "true"
          );
        switch (t.key) {
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "ArrowDown":
            this.determineOrientation(t, p);
            break;
          case "Backspace":
          case "Delete":
            this.handleDeleteKeyDown(t, p, i, r);
            break;
          case "Enter":
          case " ":
            this.handleTabClick(i, t), this.handlePrevent(t);
            break;
          case "Home":
            p[0].focus({ preventScroll: o }), this.handlePrevent(t);
            break;
          case "End":
            p[p.length - 1].focus({ preventScroll: o }), this.handlePrevent(t);
            break;
        }
      });
  }
  init() {
    this._adapter.collectPane();
  }
  _notifyChange(e) {
    const { activeKey: t } = this.getStates();
    t !== e && this._adapter.notifyChange(e);
  }
  handleTabClick(e, t) {
    this._isInProps("activeKey")
      ? this._notifyChange(e)
      : (this._notifyChange(e), this.handleNewActiveKey(e)),
      this._adapter.notifyTabClick(e, t);
  }
  handleNewActiveKey(e) {
    const { activeKey: t } = this.getStates();
    t !== e && this._adapter.setNewActiveKey(e);
  }
  getDefaultActiveKey() {
    let e;
    const t = this.getProps();
    return (
      "activeKey" in t
        ? (e = t.activeKey)
        : "defaultActiveKey" in t
        ? (e = t.defaultActiveKey)
        : (e = this._adapter.getDefaultActiveKeyFromChildren()),
      e
    );
  }
  handleTabListChange() {
    this._adapter.collectPane();
  }
  handleTabPanesChange() {
    this._adapter.collectPane(), this._adapter.collectActiveKey();
  }
  handleTabDelete(e) {
    this._adapter.notifyTabDelete(e);
  }
  determineOrientation(e, t) {
    const { tabPosition: i } = this.getProps();
    i === "left"
      ? (e.key === "ArrowUp" || e.key === "ArrowDown") &&
        (this.switchTabOnArrowPress(e, t), this.handlePrevent(e))
      : (e.key === "ArrowLeft" || e.key === "ArrowRight") &&
        (this.switchTabOnArrowPress(e, t), this.handlePrevent(e));
  }
  handleDeleteKeyDown(e, t, i, r) {
    const { preventScroll: o } = this.getProps();
    if (r) {
      this.handleTabDelete(i);
      const p = t.indexOf(e.target);
      t.length !== 1 &&
        t[p + 1 >= t.length ? p - 1 : p + 1].focus({ preventScroll: o });
    }
  }
  switchTabOnArrowPress(e, t) {
    const { preventScroll: i } = this.getProps(),
      r = t.indexOf(e.target),
      o = { ArrowLeft: -1, ArrowUp: -1, ArrowRight: 1, ArrowDown: 1 };
    o[e.key] &&
      r !== void 0 &&
      (t[r + o[e.key]]
        ? t[r + o[e.key]].focus({ preventScroll: i })
        : e.key === "ArrowLeft" || e.key === "ArrowUp"
        ? t[t.length - 1].focus({ preventScroll: i })
        : (e.key === "ArrowRight" || e.key == "ArrowDown") &&
          t[0].focus({ preventScroll: i }));
  }
}
const TG = wG;
var CG =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const MG = (n, e) => {
    const {
        tab: t,
        size: i,
        type: r,
        icon: o,
        selected: p,
        closable: a,
        disabled: s,
        itemKey: u,
        deleteTabItem: d,
        tabPosition: l,
        handleKeyDown: c,
        onClick: h,
      } = n,
      m = CG(n, [
        "tab",
        "size",
        "type",
        "icon",
        "selected",
        "closable",
        "disabled",
        "itemKey",
        "deleteTabItem",
        "tabPosition",
        "handleKeyDown",
        "onClick",
      ]),
      g = Ce.useMemo(
        () =>
          r === "card" && a
            ? W.createElement(J1, {
                "aria-label": "Close",
                role: "button",
                className: `${Ke.TABS_TAB}-icon-close`,
                onClick: (b) => d(u, b),
              })
            : null,
        [r, a, d, u]
      ),
      f = Ce.useCallback((b) => W.createElement("span", null, b), []),
      v = Ce.useCallback(
        (b) => {
          c && c(b, u, a);
        },
        [c, u, a]
      ),
      y = Ce.useCallback(
        (b) => {
          !s && h && h(u, b);
        },
        [u, s, h]
      ),
      _ = o ? f(o) : null,
      x = Be(
        Ke.TABS_TAB,
        `${Ke.TABS_TAB}-${r}`,
        `${Ke.TABS_TAB}-${l}`,
        `${Ke.TABS_TAB}-single`,
        {
          [Ke.TABS_TAB_ACTIVE]: p,
          [Ke.TABS_TAB_DISABLED]: s,
          [`${Ke.TABS_TAB}-small`]: i === "small",
          [`${Ke.TABS_TAB}-medium`]: i === "medium",
        }
      );
    return W.createElement(
      "div",
      Object.assign(
        {
          role: "tab",
          id: `semiTab${u}`,
          "data-tabkey": `semiTab${u}`,
          "aria-controls": `semiTabPanel${u}`,
          "aria-disabled": s ? "true" : "false",
          "aria-selected": p ? "true" : "false",
          tabIndex: p ? 0 : -1,
          onKeyDown: v,
          onClick: y,
          className: x,
        },
        m,
        { ref: e }
      ),
      _,
      t,
      g
    );
  },
  hS = Ce.forwardRef(MG);
hS.elementType = "Tabs.TabItem";
const fS = hS;
var EG =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
class dS extends W.Component {
  constructor(e) {
    super(e),
      (this.handleItemClick = (t, i) => {
        if ((this.props.onTabClick(t, i), this.props.collapsible)) {
          const r = this._getItemKey(t);
          document
            .querySelector(
              `[data-uuid="${this.state.uuid}"] .${Ke.TABS_TAB}[data-scrollkey="${r}"]`
            )
            .scrollIntoView({
              behavior: "smooth",
              block: "nearest",
              inline: "nearest",
            });
        }
      }),
      (this.handleKeyDown = (t, i, r) => {
        this.props.handleKeyDown(t, i, r);
      }),
      (this.renderTabItem = (t) => {
        const {
            size: i,
            type: r,
            deleteTabItem: o,
            handleKeyDown: p,
            tabPosition: a,
          } = this.props,
          s = this._isActive(t.itemKey);
        return W.createElement(
          fS,
          Object.assign(
            {},
            ip(t, ["disabled", "icon", "itemKey", "tab", "closable"]),
            {
              key: this._getItemKey(t.itemKey),
              selected: s,
              size: i,
              type: r,
              tabPosition: a,
              handleKeyDown: p,
              deleteTabItem: o,
              onClick: this.handleItemClick,
            }
          )
        );
      }),
      (this.renderTabComponents = (t) => t.map((i) => this.renderTabItem(i))),
      (this.handleArrowClick = (t, i) => {
        const r = i === "start" ? t.pop() : t.shift();
        if (!r) return;
        const o = this._getItemKey(r.itemKey);
        document
          .querySelector(
            `[data-uuid="${this.state.uuid}"] .${Ke.TABS_TAB}[data-scrollkey="${o}"]`
          )
          .scrollIntoView({
            behavior: "smooth",
            block: "nearest",
            inline: "nearest",
          });
      }),
      (this.renderCollapse = (t, i, r) => {
        if (gi(t))
          return W.createElement(r_, {
            disabled: !0,
            icon: i,
            theme: "borderless",
          });
        const { dropdownClassName: o, dropdownStyle: p } = this.props,
          { rePosKey: a } = this.state,
          s = !t.length,
          u = W.createElement(
            Uf.Menu,
            null,
            t.map((c) => {
              const { icon: h, tab: m, itemKey: g } = c,
                f = h ? this.renderIcon(c.icon) : null;
              return W.createElement(
                Uf.Item,
                {
                  key: g,
                  onClick: (v) => this.handleItemClick(g, v),
                  active: this._isActive(g),
                },
                f,
                m
              );
            })
          ),
          d = Be({
            [`${Ke.TABS_BAR}-arrow-${r}`]: r,
            [`${Ke.TABS_BAR}-arrow`]: !0,
          }),
          l = Be(o, { [`${Ke.TABS_BAR}-dropdown`]: !0 });
        return W.createElement(
          Uf,
          {
            className: l,
            clickToHide: !0,
            clickTriggerToHide: !0,
            key: `${a}-${r}`,
            position: r === "start" ? "bottomLeft" : "bottomRight",
            render: s ? null : u,
            showTick: !0,
            style: p,
            trigger: "hover",
            disableFocusListener: !0,
          },
          W.createElement(
            "div",
            {
              role: "presentation",
              className: d,
              onClick: (c) => this.handleArrowClick(t, r),
            },
            W.createElement(r_, { disabled: s, icon: i, theme: "borderless" })
          )
        );
      }),
      (this.renderOverflow = (t) =>
        t.map((i, r) => {
          const o =
              r === 0 ? W.createElement(HV, null) : W.createElement(GV, null),
            p = r === 0 ? "start" : "end";
          return this.renderCollapse(i, o, p);
        })),
      (this.renderCollapsedTab = () => {
        const { list: t } = this.props,
          i = t.map((r) => {
            const { itemKey: o } = r;
            return Object.assign(
              { key: this._getItemKey(o), active: this._isActive(o) },
              r
            );
          });
        return W.createElement(SG, {
          items: i,
          overflowRenderer: this.renderOverflow,
          renderMode: "scroll",
          className: `${Ke.TABS_BAR}-overflow-list`,
          visibleItemRenderer: this.renderTabItem,
        });
      }),
      (this._isActive = (t) => t === this.props.activeKey),
      (this._getItemKey = (t) => `${t}-bar`),
      (this.state = {
        endInd: e.list.length,
        rePosKey: 0,
        startInd: 0,
        uuid: "",
      });
  }
  componentDidMount() {
    this.setState({ uuid: sH() });
  }
  renderIcon(e) {
    return W.createElement("span", null, e);
  }
  renderExtra() {
    const { tabBarExtraContent: e, type: t, size: i } = this.props,
      r = { float: "right" },
      o = e && e.props ? e.props.style : {},
      p = Be(Ke.TABS_BAR_EXTRA, {
        [`${Ke.TABS_BAR}-${t}-extra`]: t,
        [`${Ke.TABS_BAR}-${t}-extra-${i}`]: i,
      });
    if (e) {
      const a = Object.assign(Object.assign({}, r), o);
      return W.createElement(
        "div",
        { className: p, style: a, "x-semi-prop": "tabBarExtraContent" },
        e
      );
    }
    return null;
  }
  render() {
    const e = this.props,
      {
        type: t,
        style: i,
        className: r,
        list: o,
        tabPosition: p,
        collapsible: a,
      } = e,
      s = EG(e, [
        "type",
        "style",
        "className",
        "list",
        "tabPosition",
        "collapsible",
      ]),
      u = Be(r, {
        [Ke.TABS_BAR]: !0,
        [Ke.TABS_BAR_LINE]: t === "line",
        [Ke.TABS_BAR_CARD]: t === "card",
        [Ke.TABS_BAR_BUTTON]: t === "button",
        [`${Ke.TABS_BAR}-${p}`]: p,
        [`${Ke.TABS_BAR}-collapse`]: a,
      }),
      d = this.renderExtra(),
      l = a ? this.renderCollapsedTab() : this.renderTabComponents(o);
    return W.createElement(
      "div",
      Object.assign(
        {
          role: "tablist",
          "aria-orientation": p === "left" ? "vertical" : "horizontal",
          className: u,
          style: i,
        },
        $m(s),
        { "data-uuid": this.state.uuid }
      ),
      l,
      d
    );
  }
}
dS.propTypes = {
  activeKey: M.string,
  className: M.string,
  collapsible: M.bool,
  list: M.array,
  onTabClick: M.func,
  size: M.oneOf(lo.SIZE),
  style: M.object,
  tabBarExtraContent: M.node,
  tabPosition: M.oneOf(lo.POSITION_MAP),
  type: M.oneOf(lo.TYPE_MAP),
  closable: M.bool,
  deleteTabItem: M.func,
};
const g_ = dS,
  AG = W.createContext({}),
  pS = AG;
var PG =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
class hh extends Ce.PureComponent {
  constructor() {
    super(...arguments),
      (this.ref = Ce.createRef()),
      (this.getDirection = (e, t, i, r) => {
        if (t !== null && e !== null && Array.isArray(i) && i.length) {
          const o = i.findIndex((s) => s.itemKey === e),
            p = i.findIndex((s) => s.itemKey === t),
            a = i.findIndex((s) => s.itemKey === r);
          return o === p ? a > o : p < o;
        }
        return !1;
      }),
      (this.shouldRender = () => {
        const { itemKey: e } = this.props,
          { activeKey: t, lazyRender: i } = this.context,
          r = t === e;
        return (this._active = this._active || r), i ? this._active : !0;
      });
  }
  render() {
    const { tabPaneMotion: e, tabPosition: t, prevActiveKey: i } = this.context,
      r = this.props,
      { className: o, style: p, children: a, itemKey: s, tabIndex: u } = r,
      d = PG(r, ["className", "style", "children", "itemKey", "tabIndex"]),
      l = this.context.activeKey === s,
      c = Be(o, {
        [Ke.TABS_PANE_INACTIVE]: !l,
        [Ke.TABS_PANE_ACTIVE]: l,
        [Ke.TABS_PANE]: !0,
      }),
      h = this.shouldRender(),
      m = (() => {
        const v = this.getDirection(
          this.context.activeKey,
          s,
          this.context.panes,
          i
        );
        return t === "top"
          ? v
            ? Ke.TABS_PANE_ANIMATE_RIGHT_SHOW
            : Ke.TABS_PANE_ANIMATE_LEFT_SHOW
          : v
          ? Ke.TABS_PANE_ANIMATE_BOTTOM_SHOW
          : Ke.TABS_PANE_ANIMATE_TOP_SHOW;
      })(),
      g = !this.context.panes.find((v) => v.itemKey === i),
      f = e && l && !g && !this.context.forceDisableMotion;
    return W.createElement(
      "div",
      Object.assign(
        {
          ref: this.ref,
          role: "tabpanel",
          id: `semiTabPanel${s}`,
          "aria-labelledby": `semiTab${s}`,
          className: c,
          style: p,
          "aria-hidden": l ? "false" : "true",
          tabIndex: u || 0,
        },
        $m(d),
        { "x-semi-prop": "children" }
      ),
      W.createElement(
        Fm,
        { motion: f, animationState: l ? "enter" : "leave", startClassName: m },
        (v) => {
          let { animationClassName: y, animationEventsNeedBind: _ } = v;
          return W.createElement(
            "div",
            Object.assign(
              {
                className: `${Ke.TABS_PANE_MOTION_OVERLAY} ${y}`,
                "x-semi-prop": "children",
              },
              _
            ),
            h ? a : null
          );
        }
      )
    );
  }
}
hh.isTabPane = !0;
hh.contextType = pS;
hh.propTypes = {
  className: M.string,
  style: M.object,
  children: M.node,
  disabled: M.bool,
  itemKey: M.string,
  tab: M.node,
  icon: M.node,
  closable: M.bool,
};
const ml = hh;
var OG =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const v_ = ["className", "style", "disabled", "itemKey", "tab", "icon"];
class kl extends bn {
  constructor(e) {
    super(e),
      (this.setContentRef = (t) => {
        this.contentRef = { current: t };
      }),
      (this.onTabClick = (t, i) => {
        this.foundation.handleTabClick(t, i);
      }),
      (this.rePosChildren = (t, i) => {
        const r = [],
          o = W.Children.toArray(t);
        return (
          t.length &&
            (r.push(...o.filter((p) => p.props && p.props.itemKey === i)),
            r.push(...o.filter((p) => p.props && p.props.itemKey !== i))),
          r
        );
      }),
      (this.getActiveItem = () => {
        const { activeKey: t } = this.state,
          { children: i, tabList: r } = this.props;
        return r || !Array.isArray(i)
          ? i
          : W.Children.toArray(i).filter((o) =>
              Ce.isValidElement(o) && o.type && o.type.isTabPane
                ? o.props.itemKey === t
                : !0
            );
      }),
      (this.deleteTabItem = (t, i) => {
        i.stopPropagation(), this.foundation.handleTabDelete(t);
      }),
      (this.foundation = new TG(this.adapter)),
      (this.state = {
        activeKey: this.foundation.getDefaultActiveKey(),
        panes: [],
        prevActiveKey: null,
        forceDisableMotion: !1,
      }),
      (this.contentRef = Ce.createRef()),
      (this.contentHeight = "auto");
  }
  get adapter() {
    return Object.assign(Object.assign({}, super.adapter), {
      collectPane: () => {
        const { tabList: e, children: t } = this.props;
        if (Array.isArray(e) && e.length) {
          this.setState({ panes: e });
          return;
        }
        const i = W.Children.map(t, (r) => {
          if (r) {
            const {
              tab: o,
              icon: p,
              disabled: a,
              itemKey: s,
              closable: u,
            } = r.props;
            return { tab: o, icon: p, disabled: a, itemKey: s, closable: u };
          }
        });
        this.setState({ panes: i });
      },
      collectActiveKey: () => {
        let e = [];
        const { tabList: t, children: i, activeKey: r } = this.props;
        if (typeof r < "u") return;
        const { activeKey: o } = this.state;
        Array.isArray(t) && t.length
          ? (e = t)
          : (e = W.Children.map(i, (p) => {
              if (p) {
                const {
                  tab: a,
                  icon: s,
                  disabled: u,
                  itemKey: d,
                  closable: l,
                } = p.props;
                return {
                  tab: a,
                  icon: s,
                  disabled: u,
                  itemKey: d,
                  closable: l,
                };
              }
            })),
          e.findIndex((p) => p.itemKey === o) === -1 &&
            (e.length > 0
              ? this.setState({ activeKey: e[0].itemKey })
              : this.setState({ activeKey: "" }));
      },
      notifyTabClick: (e, t) => {
        this.props.onTabClick(e, t);
      },
      notifyChange: (e) => {
        this.props.onChange(e);
      },
      setNewActiveKey: (e) => {
        this.setState({ activeKey: e });
      },
      getDefaultActiveKeyFromChildren: () => {
        const { tabList: e, children: t } = this.props;
        let i = "";
        return (
          (
            e ||
            W.Children.toArray(t).map((o) =>
              Ce.isValidElement(o) ? o.props : null
            )
          ).forEach((o) => {
            o && !i && !o.disabled && (i = o.itemKey);
          }),
          i
        );
      },
      notifyTabDelete: (e) => {
        this.props.onTabClose && this.props.onTabClose(e);
      },
    });
  }
  static getDerivedStateFromProps(e, t) {
    const i = {};
    return (
      !km(e.activeKey) &&
        e.activeKey !== t.activeKey &&
        ((t.prevActiveKey = t.activeKey), (i.activeKey = e.activeKey)),
      i
    );
  }
  componentDidUpdate(e, t) {
    const i = W.Children.toArray(e.children).map((p) =>
        ip(Ce.isValidElement(p) ? p.props : null, v_)
      ),
      r = W.Children.toArray(this.props.children).map((p) =>
        ip(Ce.isValidElement(p) ? p.props : null, v_)
      ),
      o = this.props.tabList || e.tabList;
    if (
      (bi(this.props.tabList, e.tabList) ||
        this.foundation.handleTabListChange(),
      t.activeKey !== this.state.activeKey &&
        t.activeKey !== this.state.prevActiveKey &&
        this.setState({ prevActiveKey: t.activeKey }),
      e.activeKey !== this.props.activeKey)
    ) {
      const p = (() => {
        const a = new Set(i.map((s) => s.itemKey));
        return r.map((s) => s.itemKey).filter((s) => !a.has(s));
      })();
      this.setState({ forceDisableMotion: p.includes(this.props.activeKey) });
    }
    !bi(i, r) && !o && this.foundation.handleTabPanesChange();
  }
  render() {
    const e = this.props,
      {
        children: t,
        className: i,
        collapsible: r,
        contentStyle: o,
        keepDOM: p,
        lazyRender: a,
        renderTabBar: s,
        size: u,
        style: d,
        tabBarClassName: l,
        tabBarExtraContent: c,
        tabBarStyle: h,
        tabPaneMotion: m,
        tabPosition: g,
        type: f,
      } = e,
      v = OG(e, [
        "children",
        "className",
        "collapsible",
        "contentStyle",
        "keepDOM",
        "lazyRender",
        "renderTabBar",
        "size",
        "style",
        "tabBarClassName",
        "tabBarExtraContent",
        "tabBarStyle",
        "tabPaneMotion",
        "tabPosition",
        "type",
      ]),
      { panes: y, activeKey: _ } = this.state,
      x = Be(i, { [Ke.TABS]: !0, [`${Ke.TABS}-${g}`]: g }),
      b = Be({ [Ke.TABS_CONTENT]: !0, [`${Ke.TABS_CONTENT}-${g}`]: g }),
      S = {
        activeKey: _,
        className: l,
        collapsible: r,
        list: y,
        onTabClick: this.onTabClick,
        size: u,
        style: h,
        tabBarExtraContent: c,
        tabPosition: g,
        type: f,
        deleteTabItem: this.deleteTabItem,
        handleKeyDown: this.foundation.handleKeyDown,
      },
      T = s ? s(S, g_) : W.createElement(g_, Object.assign({}, S)),
      w = p ? t : this.getActiveItem();
    return W.createElement(
      "div",
      Object.assign({ className: x, style: d }, $m(v)),
      T,
      W.createElement(
        pS.Provider,
        {
          value: {
            activeKey: _,
            lazyRender: a,
            panes: y,
            tabPaneMotion: m,
            tabPosition: g,
            prevActiveKey: this.state.prevActiveKey,
            forceDisableMotion: this.state.forceDisableMotion,
          },
        },
        W.createElement(
          "div",
          {
            ref: this.setContentRef,
            className: b,
            style: Object.assign({}, o),
          },
          w
        )
      )
    );
  }
}
kl.TabPane = ml;
kl.TabItem = fS;
kl.propTypes = {
  activeKey: M.string,
  className: M.string,
  collapsible: M.bool,
  contentStyle: M.oneOfType([M.object]),
  defaultActiveKey: M.string,
  keepDOM: M.bool,
  lazyRender: M.bool,
  onChange: M.func,
  onTabClick: M.func,
  renderTabBar: M.func,
  size: M.oneOf(lo.SIZE),
  style: M.object,
  tabBarClassName: M.string,
  tabBarExtraContent: M.node,
  tabBarStyle: M.object,
  tabList: M.array,
  tabPaneMotion: M.bool,
  tabPosition: M.oneOf(lo.POSITION_MAP),
  type: M.oneOf(lo.TYPE_MAP),
  onTabClose: M.func,
  preventScroll: M.bool,
};
kl.defaultProps = {
  children: [],
  collapsible: !1,
  keepDOM: !0,
  lazyRender: !1,
  onChange: () => {},
  onTabClick: () => {},
  size: "large",
  tabPaneMotion: !0,
  tabPosition: "top",
  type: "line",
  onTabClose: () => {},
};
const mS = kl;
class Zm extends Wi {
  constructor(e) {
    super(Object.assign(Object.assign({}, Zm.defaultAdapter), e));
  }
  hasToast(e) {
    return this._adapter
      .getState("list")
      .map((i) => {
        let { id: r } = i;
        return r;
      })
      .includes(e);
  }
  addToast(e) {
    const t = this._adapter.getState("list");
    t.push(e), this._adapter.updateToast(t, [], []);
  }
  updateToast(e, t) {
    let i = this._adapter.getState("list");
    i = i.map((o) => (o.id === e ? Object.assign(Object.assign({}, o), t) : o));
    const r = i.filter((o) => o.id === e);
    this._adapter.updateToast(i, [], r);
  }
  removeToast(e) {
    let t = this._adapter.getState("list");
    const i = [];
    (t = t.filter((r) => (r.id === e ? (i.push(r), !1) : !0))),
      this._adapter.updateToast(t, i, []);
  }
  destroyAll() {
    const e = this._adapter.getState("list");
    e.length > 0 && this._adapter.updateToast([], e, []);
  }
}
const Hf = `${Ye}-toast`,
  Xc = { PREFIX: Hf, WRAPPER: `${Hf}-wrapper`, LIST: `${Hf}-list` },
  Yc = {
    types: ["warning", "success", "info", "error", "default"],
    themes: ["normal", "light"],
    directions: ["ltr", "rtl"],
  },
  LG = { duration: 3 };
class Jm extends Wi {
  constructor(e) {
    super(Object.assign(Object.assign({}, Jm.defaultAdapter), e)),
      (this._timer = null),
      (this._id = null);
  }
  init() {
    this.startCloseTimer_(), (this._id = this._adapter.getProp("id"));
  }
  destroy() {
    this.clearCloseTimer_();
  }
  startCloseTimer_() {
    const e = this._adapter.getProp("duration");
    e &&
      $W(e) &&
      (this._timer = setTimeout(() => {
        this.close();
      }, e * 1e3));
  }
  close(e) {
    e && e.stopPropagation(),
      this._adapter.notifyWrapperToRemove(this._id),
      this._adapter.notifyClose();
  }
  clearCloseTimer_() {
    this._timer && (clearTimeout(this._timer), (this._timer = null));
  }
  restartCloseTimer() {
    this.clearCloseTimer_(), this.startCloseTimer_();
  }
}
const hi = Xc.PREFIX;
let fh = class extends bn {
  constructor(e) {
    super(e),
      (this.clearCloseTimer = () => {
        this.foundation.clearCloseTimer_();
      }),
      (this.startCloseTimer = () => {
        this.foundation.startCloseTimer_();
      }),
      (this.restartCloseTimer = () => {
        this.foundation.restartCloseTimer();
      }),
      (this.state = {}),
      (this.foundation = new Jm(this.adapter));
  }
  get adapter() {
    return Object.assign(Object.assign({}, super.adapter), {
      notifyWrapperToRemove: (e) => {
        this.props.close(e);
      },
      notifyClose: () => {
        this.props.onClose();
      },
    });
  }
  componentDidMount() {
    this.foundation.init();
  }
  componentWillUnmount() {
    this.foundation.destroy();
  }
  close(e) {
    this.foundation.close(e);
  }
  renderIcon() {
    const { type: e, icon: t } = this.props,
      r = {
        warning: W.createElement(FV, null),
        success: W.createElement(SW, null),
        info: W.createElement(hW, null),
        error: W.createElement(RV, null),
      }[e],
      o = "large",
      p = Be(`${hi}-icon`, `${hi}-icon-${e}`);
    return t
      ? Y1(t)
        ? W.cloneElement(t, { size: o, className: `${hi}-icon` })
        : t
      : e && r
      ? W.cloneElement(r, { size: o, className: p })
      : null;
  }
  render() {
    const {
        content: e,
        type: t,
        theme: i,
        showClose: r,
        textMaxWidth: o,
        className: p,
        style: a,
      } = this.props,
      s = this.props.direction || this.context.direction,
      u = Be(hi, p, {
        [`${hi}-${t}`]: !0,
        [`${hi}-${i}`]: i === "light",
        [`${hi}-rtl`]: s === "rtl",
      }),
      d = {};
    d.maxWidth = o;
    const l = "borderless",
      c = "small";
    return W.createElement(
      "div",
      {
        role: "alert",
        "aria-label": `${t || "default"} type`,
        className: u,
        style: a,
        onMouseEnter: this.clearCloseTimer,
        onMouseLeave: this.startCloseTimer,
        onAnimationStart: this.props.onAnimationStart,
        onAnimationEnd: this.props.onAnimationEnd,
      },
      W.createElement(
        "div",
        { className: `${hi}-content` },
        this.renderIcon(),
        W.createElement(
          "span",
          {
            className: `${hi}-content-text`,
            style: d,
            "x-semi-prop": "content",
          },
          e
        ),
        r &&
          W.createElement(
            "div",
            { className: `${hi}-close-button` },
            W.createElement(Wm, {
              onClick: (h) => this.close(h),
              type: "tertiary",
              icon: W.createElement(J1, { "x-semi-prop": "icon" }),
              theme: l,
              size: c,
            })
          )
      )
    );
  }
};
fh.contextType = Pl;
fh.propTypes = {
  onClose: M.func,
  content: M.node,
  close: M.func,
  duration: M.number,
  theme: M.oneOf(Yc.themes),
  type: M.oneOf(Yc.types),
  textMaxWidth: M.oneOfType([M.string, M.number]),
  style: M.object,
  className: M.string,
  showClose: M.bool,
  icon: M.oneOfType([M.string, M.node]),
  direction: M.oneOf(Yc.directions),
};
fh.defaultProps = {
  onClose: ut,
  content: "",
  close: ut,
  duration: LG.duration,
  textMaxWidth: 450,
  showClose: !0,
  theme: "normal",
};
const gS = fh;
var DG =
  (globalThis && globalThis.__rest) ||
  function (n, e) {
    var t = {};
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) &&
        e.indexOf(i) < 0 &&
        (t[i] = n[i]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var r = 0, i = Object.getOwnPropertySymbols(n); r < i.length; r++)
        e.indexOf(i[r]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, i[r]) &&
          (t[i[r]] = n[i[r]]);
    return t;
  };
const RG = (n, e) => {
    var { afterClose: t } = n,
      i = DG(n, ["afterClose"]);
    const [r, o] = Ce.useState(!0),
      p = () => {
        o(!1);
      };
    return (
      W.useImperativeHandle(e, () => ({
        close: () => {
          o(!1);
        },
      })),
      Ce.useEffect(() => {
        r || t(i.id);
      }, [r]),
      r ? W.createElement(gS, Object.assign({}, i, { close: p })) : null
    );
  },
  IG = W.forwardRef(RG),
  xa = { motion: !0, zIndex: 1010, duration: 3 };
function kG() {
  const [n, e] = W.useState([]);
  function t(i, r) {
    return (
      e((o) => [{ element: i, config: r }, ...o]),
      (o) => {
        e((p) =>
          p.filter((a) => {
            let { config: s } = a;
            return s.id !== o;
          })
        );
      }
    );
  }
  return [n, t];
}
function FG() {
  const [n, e] = kG(),
    t = new Map(),
    i = (o) => {
      const p = wu("semi_toast_"),
        a = Object.assign(Object.assign({}, o), { id: p });
      let s;
      const u = (l) => {
          t.set(p, l);
        },
        d = W.createElement(
          IG,
          Object.assign({}, a, { key: p, afterClose: (l) => s(l), ref: u })
        );
      return (s = e(d, Object.assign({}, a))), p;
    },
    r = (o) => {
      const p = t.get(o);
      p && p.close();
    };
  return [
    {
      success: (o) =>
        i(
          Object.assign(Object.assign(Object.assign({}, xa), o), {
            type: "success",
          })
        ),
      info: (o) =>
        i(
          Object.assign(Object.assign(Object.assign({}, xa), o), {
            type: "info",
          })
        ),
      error: (o) =>
        i(
          Object.assign(Object.assign(Object.assign({}, xa), o), {
            type: "error",
          })
        ),
      warning: (o) =>
        i(
          Object.assign(Object.assign(Object.assign({}, xa), o), {
            type: "warning",
          })
        ),
      open: (o) =>
        i(
          Object.assign(Object.assign(Object.assign({}, xa), o), {
            type: "default",
          })
        ),
      close: (o) => r(o),
    },
    W.createElement(
      W.Fragment,
      null,
      Array.isArray(n) && n.length
        ? W.createElement(
            W.Fragment,
            null,
            n.map((o) => o.element)
          )
        : null
    ),
  ];
}
const NG = () => {
  var n;
  return (
    (n = class ft extends bn {
      constructor(t) {
        super(t),
          (this.state = { list: [], removedItems: [], updatedItems: [] }),
          (this.foundation = new Zm(this.adapter));
      }
      get adapter() {
        return Object.assign(Object.assign({}, super.adapter), {
          updateToast: (t, i, r) => {
            this.setState({ list: t, removedItems: i, updatedItems: r });
          },
        });
      }
      static create(t) {
        var i;
        const r = (i = t.id) !== null && i !== void 0 ? i : wu("toast");
        if (ft.ref) {
          const o = document.querySelector(`#${this.wrapperId}`);
          ["top", "left", "bottom", "right"].map((p) => {
            p in t &&
              (o.style[p] = typeof t[p] == "number" ? `${t[p]}px` : t[p]);
          }),
            ft.ref.has(r)
              ? ft.ref.update(r, Object.assign(Object.assign({}, t), { id: r }))
              : ft.ref.add(Object.assign(Object.assign({}, t), { id: r }));
        } else {
          const o = document.createElement("div");
          this.wrapperId || (this.wrapperId = wu("toast-wrapper").slice(0, 26)),
            (o.className = Xc.WRAPPER),
            (o.id = this.wrapperId),
            (o.style.zIndex = String(
              typeof t.zIndex == "number" ? t.zIndex : ft.defaultOpts.zIndex
            )),
            ["top", "left", "bottom", "right"].map((p) => {
              if (p in ft.defaultOpts || p in t) {
                const a = t[p] ? t[p] : ft.defaultOpts[p];
                o.style[p] = typeof a == "number" ? `${a}px` : a;
              }
            }),
            ft.defaultOpts.getPopupContainer
              ? ft.defaultOpts.getPopupContainer().appendChild(o)
              : document.body.appendChild(o),
            Yr.render(
              W.createElement(ft, { ref: (p) => (ft.ref = p) }),
              o,
              () => {
                ft.ref.add(Object.assign(Object.assign({}, t), { id: r }));
              }
            );
        }
        return r;
      }
      static close(t) {
        ft.ref && ft.ref.remove(t);
      }
      static destroyAll() {
        if (ft.ref) {
          ft.ref.destroyAll();
          const t = document.querySelector(`#${this.wrapperId}`);
          Yr.unmountComponentAtNode(t),
            t && t.parentNode.removeChild(t),
            (ft.ref = null),
            (this.wrapperId = null);
        }
      }
      static getWrapperId() {
        return this.wrapperId;
      }
      static info(t) {
        return (
          typeof t == "string" && (t = { content: t }),
          this.create(
            Object.assign(Object.assign(Object.assign({}, ft.defaultOpts), t), {
              type: "info",
            })
          )
        );
      }
      static warning(t) {
        return (
          typeof t == "string" && (t = { content: t }),
          this.create(
            Object.assign(Object.assign(Object.assign({}, ft.defaultOpts), t), {
              type: "warning",
            })
          )
        );
      }
      static error(t) {
        return (
          typeof t == "string" && (t = { content: t }),
          this.create(
            Object.assign(Object.assign(Object.assign({}, ft.defaultOpts), t), {
              type: "error",
            })
          )
        );
      }
      static success(t) {
        return (
          typeof t == "string" && (t = { content: t }),
          this.create(
            Object.assign(Object.assign(Object.assign({}, ft.defaultOpts), t), {
              type: "success",
            })
          )
        );
      }
      static config(t) {
        ["top", "left", "bottom", "right"].forEach((i) => {
          i in t && (ft.defaultOpts[i] = t[i]);
        }),
          typeof t.zIndex == "number" && (ft.defaultOpts.zIndex = t.zIndex),
          typeof t.duration == "number" &&
            (ft.defaultOpts.duration = t.duration),
          typeof t.getPopupContainer == "function" &&
            (ft.defaultOpts.getPopupContainer = t.getPopupContainer);
      }
      has(t) {
        return this.foundation.hasToast(t);
      }
      add(t) {
        return this.foundation.addToast(t);
      }
      update(t, i) {
        return this.foundation.updateToast(t, i);
      }
      remove(t) {
        return this.foundation.removeToast(t);
      }
      destroyAll() {
        return this.foundation.destroyAll();
      }
      render() {
        let { list: t } = this.state;
        const { removedItems: i, updatedItems: r } = this.state;
        t = Array.from(new Set([...t, ...i]));
        const o = r.map((a) => {
            let { id: s } = a;
            return s;
          }),
          p = (a) => {
            var s;
            !(
              (s = a == null ? void 0 : a.foundation) === null || s === void 0
            ) &&
              s._id &&
              o.includes(a.foundation._id) &&
              (a.foundation.setState({ duration: a.props.duration }),
              a.foundation.restartCloseTimer());
          };
        return W.createElement(
          W.Fragment,
          null,
          t.map((a, s) => {
            const u = i.find((d) => d.id === a.id) !== void 0;
            return W.createElement(
              Fm,
              {
                key: a.id,
                motion: a.motion,
                animationState: u ? "leave" : "enter",
                startClassName: u
                  ? `${Xc.PREFIX}-animation-hide`
                  : `${Xc.PREFIX}-animation-show`,
              },
              (d) => {
                let {
                  animationClassName: l,
                  animationEventsNeedBind: c,
                  isAnimating: h,
                } = d;
                return u && !h
                  ? null
                  : W.createElement(
                      gS,
                      Object.assign(
                        {},
                        a,
                        {
                          className: Be({
                            [a.className]: Boolean(a.className),
                            [l]: !0,
                          }),
                        },
                        c,
                        {
                          style: Object.assign({}, a.style),
                          close: (m) => this.remove(m),
                          ref: p,
                        }
                      )
                    );
              }
            );
          })
        );
      }
    }),
    (n.defaultOpts = { motion: !0, zIndex: 1010, content: "" }),
    (n.propTypes = {
      content: M.node,
      duration: M.number,
      onClose: M.func,
      icon: M.node,
      direction: M.oneOf(Yc.directions),
    }),
    (n.defaultProps = {}),
    n
  );
};
class BG {
  static create(e) {
    const t = NG();
    return (t.useToast = FG), e && t.config(e), t;
  }
}
const zG = BG.create();
function UG({ className: n }) {
  return Ne.jsx("nav", {
    className: `tooyea-nav ${n}`,
    children: Ne.jsx("a", {
      href: "/",
      children: Ne.jsx("img", { src: "./logo.png", alt: "logo", height: "40" }),
    }),
  });
}
const vS = Ce.createContext({ state: new HL(), dispatch: (n) => {} }),
  jG = () => Ce.useContext(vS);
function HG(n, e) {
  return { ...n, [e.key]: e.value };
}
function VG({ children: n }) {
  const [e, t] = Ce.useReducer(HG, r1),
    i = { state: e, dispatch: t };
  return Ne.jsx(vS.Provider, { value: i, children: n });
}
function WG() {
  jG();
  const n = [
    {
      icon: Ne.jsx(nW, {}),
      title: "",
      key: "style",
      panel: Ne.jsx(Ne.Fragment, {}),
    },
    {
      icon: Ne.jsx(lW, {}),
      title: "",
      key: "image",
      panel: Ne.jsx(Ne.Fragment, {}),
    },
    {
      icon: Ne.jsx(vW, {}),
      title: "",
      key: "text",
      panel: Ne.jsx(Ne.Fragment, {}),
    },
  ];
  return Ne.jsx(Ne.Fragment, {
    children: Ne.jsx(a_, {
      keepDOM: !0,
      defaultActiveKey: ["style"],
      children: n.map((e) =>
        Ne.jsx(a_.Panel, {
          header: Ne.jsxs("span", {
            className: "collapse-item-header",
            children: [e.icon, e.title],
          }),
          itemKey: e.key,
          children: Ne.jsx(Ne.Fragment, { children: e.panel }),
        })
      ),
    }),
  });
}
function GG({ className: n }) {
  return (
    Ce.useState({ count: 1 }),
    Ne.jsxs(mS, {
      className: `side-bar ${n}`,
      defaultActiveKey: "2",
      children: [
        Ne.jsx(ml, {
          tab: Ne.jsxs("div", {
            className: "tab-card",
            children: [Ne.jsx(pW, {}), ""],
          }),
          itemKey: "1",
          children: Ne.jsx(rS, {
            title: "",
            description: "",
          }),
        }),
        Ne.jsx(ml, {
          tab: Ne.jsxs("div", {
            className: "tab-card",
            children: [Ne.jsx(QV, {}), ""],
          }),
          itemKey: "2",
          children: Ne.jsx(WG, {}),
        }),
      ],
    })
  );
}
function $G({ className: n }) {
  return Ne.jsxs(mS, {
    type: "line",
    className: `canvas-operator ${n}`,
    children: [
      Ne.jsx(ml, {
        tab: Ne.jsx("div", { className: "tab-card", children: "" }),
        itemKey: "1",
        children: Ne.jsx("div", {
          id: "tooyea-canvas",
          className: "canvas-panel",
        }),
      }),
      Ne.jsx(ml, {
        tab: Ne.jsx("div", { className: "tab-card", children: "" }),
        itemKey: "2",
        children: Ne.jsx("div", {
          id: "tooyea-canvas2",
          className: "canvas-panel",
        }),
      }),
    ],
  });
}
function XG({ modelScene: n, className: e }) {
  return Ne.jsx("div", { className: `tooyea-right-panel ${e}`, children: n });
}
function YG() {
  return (
    Ce.useEffect(() => {
      (async () => {
        Pf.mount("webgl", { width: 400, height: 400 });
        const { meshes: n, meshTextures: e } = await Pf.load(
          {
            format: "obj",
            fileSrc: "football/model2.obj",
            textureImageArrays: [
              [
                {
                  overlayImageSrc: "football/top.png",
                  backgroundColor: "#ff6a1f",
                },
              ],
            ],
            position: [0, -80, -30],
          },
          [["tooyea-canvas"]]
        );
        Pf.load(
          {
            format: "obj",
            fileSrc: "kuzi/model.obj",
            textureImageArrays: [
              [{ overlayImageSrc: "kuzi/top.png", backgroundColor: "#ff6a1f" }],
            ],
            position: [0, -100, -30],
          },
          [["tooyea-canvas2"]]
        );
        const t = e[0].getCanvasOperator();
        t == null || t.addImage("logo/Cleveland_Cavaliers.png"),
          zG.success({ content: "welcome" });
      })();
    }, []),
    Ne.jsxs(Ne.Fragment, {
      children: [
        Ne.jsx(UG, { className: "Nav" }),
        Ne.jsxs("div", {
          className: "App",
          children: [
            Ne.jsx(GG, { className: "SideBar" }),
            Ne.jsx($G, { className: "CanvasOperator" }),
            Ne.jsx(XG, {
              className: "right-panel",
              modelScene: Ne.jsx("canvas", {
                id: "webgl",
                className: "three-container",
              }),
            }),
          ],
        }),
      ],
    })
  );
}
Vf.createRoot(document.getElementById("root")).render(
  Ne.jsx(VG, { children: Ne.jsx(YG, {}) })
);
